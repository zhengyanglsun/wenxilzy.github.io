<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022暑假每日一题</title>
      <link href="/2022/06/14/2022%E6%9A%91%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2022/06/14/2022%E6%9A%91%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 自律 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础第五章课后习题</title>
      <link href="/2022/06/10/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
      <url>/2022/06/10/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="思考与练习">思考与练习</h2><p>已知关系数据库的模式包含如下关系模式：<br>S（S#，NAME，AGE，SEX）<br>C（C#，COURSE）<br>SC（S#，C#，GRADE）<br>其中：S#，C#，（S#，C#）分别为S，C，SC的候选码。<br>用关系代数表达式表达如下查询：</p><ul><li>找出至少学习课程名为“数据库”和“数据结构”的所有学生的学号、姓名。</li><li>求学号为“2006601234”的学生姓名、年龄。</li><li>找出选修“数据库”课程且成绩在85以上的学生学号。</li><li>找出没有选修“数据库”课程的学生学号。<br>$$\Pi_{S\#,NAME}(S\infty(SC\infty(\delta_{COURSE='数据库’andCOURSE=‘数据结构’}©)))$$<br>$$\Pi{NAME,AGE}(\delta_{S\#=‘2006601234’}(S))$$<br><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_8139ed94e8-4.png" alt="4.png"></li></ul><h2 id="课后作业">课后作业</h2><ol><li>设计一个能够动态配置的、基于角色的用户权限应用数据库。</li></ol><ul><li>需要存储用户、角色、程序模块等信息；</li><li>一个用户可以加入多个角色，一个角色可以包含多个用户；</li><li>一个程序模块可以包含多个子模块；</li><li>一个角色可以使用多个程序模块，一个程序模块可以供多个角色使用；</li><li>设计E-R模型、逻辑模型，判断你所设计的数据库模式的范式级别。<br><strong>设计思路</strong><br>系统中抽象出操作、角色、用户三个概念，其中操作由项目中抽象出来，一个操作可以是一个URI，也可以是一个方法，比如创建用户的操作，删除用户的操作。角色是权限管理的核心，一个角色具有某些操作的权限，比如用户管理员，这个角色具有的权限有添加用户的权限、修改用户的权限、删除用户的权限。系统中的用户则被赋予若干个角色，比如如果有一个用户A被赋予了用户管理员的角色，那他就能添加、修改、删除用户。<br>表结构设计</li></ul><p>项目表</p><table><thead><tr><th style="text-align:center"><strong>字段名</strong></th><th style="text-align:center"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">token</td><td style="text-align:center">密钥</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">项目名</td></tr><tr><td style="text-align:center">ctime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">mtime</td><td style="text-align:center">修改时间</td></tr></tbody></table><p>操作表</p><table><thead><tr><th style="text-align:center"><strong>字段名</strong></th><th style="text-align:center"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">project_id</td><td style="text-align:center">项目id</td></tr><tr><td style="text-align:center">uri</td><td style="text-align:center">操作地址</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">操作名称</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">状态</td></tr><tr><td style="text-align:center">ctime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">mtime</td><td style="text-align:center">修改时间</td></tr></tbody></table><p>角色表</p><table><thead><tr><th style="text-align:center"><strong>字段名</strong></th><th style="text-align:center"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">project_id</td><td style="text-align:center">项目id</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">用户名</td></tr><tr><td style="text-align:center">roles</td><td style="text-align:center">所属角色</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">状态</td></tr><tr><td style="text-align:center">ctime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">mtime</td><td style="text-align:center">修改时间</td></tr></tbody></table><ol start="2"><li>某企业集团有若干工厂，每个工厂生产多种产品，且每一种产品可以在多个工厂生产，每个工厂按照固定的计划数量生产产品；每个工厂聘用多名职工，且每名职工只能在一个工厂工作，工厂聘用职工有聘期和工资。工厂的属性有工厂编号、厂名、地址，产品的属性有产品编号、产品名、规格，职工的属性有职工号、姓名。</li></ol><ul><li>根据上述语义画上E-R图，在E-R图中需注明实体的属性、联系的类型及实体的标识符。</li><li>将E-R模型转换成关系模型，并指出每个关系模式的主键和外键。<br>注：把圆角矩形换成椭圆<br><img src="https://img-blog.csdnimg.cn/20200903090336373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Byb2dyYW1Ob3ZpY2U=,size_16,color_FFFFFF,t_70#pic_center" alt=""></li></ul><p>关系模型：<br>工厂（工厂编号，厂名，地址）<br>产品（产品编号，产品名，规格）<br>职工（职工号，姓名，工厂编号，聘期，工资）<br>生产（工厂编号，产品编号，计划数量）</p><p>每个关系模式的主键、外键如下：<br>工厂：主键是工厂编号，没有外键。<br>产品：主键是产品编号，没有外键。<br>职工：主键是职工号，外键是工厂编号。<br>生产：主键是（工厂编号，产品编号），外键是工厂编号、产品编号。</p><ol start="3"><li>设有系、教师、学生、课程等实体，其中：</li></ol><ul><li>每一个系包括系名、系址、系主任姓名、办公电话等属性；</li><li>教师实体包括工作证号码、教师姓名、出生日期、党派等属性；</li><li>学生实体包括学号、学生姓名、性别等属性；</li><li>课程实体包括课程号、课程名、先修课程号等属性。</li><li>设一个系可以有多名教师，每名教师可以教多门课程，一门课程由一名教师教。每一名学生可选多门课程，每门课程只有一门先修课，每一名学生选修一门课程有一个成绩，试根据以上语义完成下述要求：</li></ul><ol><li>画出E-R图；</li><li>将以上实体及实体集间的联系用关系模型表示出来。<br>注：把圆角矩形换成椭圆<br><img src="https://img-blog.csdnimg.cn/20200903090358671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Byb2dyYW1Ob3ZpY2U=,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>关系模型：<br>系（系名，系址，系主任姓名，办公电话）<br>教师（工作证号码，教师姓名，出生日期，党派，所属系名）<br>课程（课程号，课程名，先修课程号，授课教师）<br>学生（学号，学生姓名，性别）<br>选修（学号，课程号，成绩）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础第四章课后习题</title>
      <link href="/2022/06/10/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
      <url>/2022/06/10/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="课堂练习">课堂练习</h2><p>根据以下文法构建下面句子的语法树。</p><p>设有文法G[S]=({S,A,B},{a,b},P,S)，其中P为：<br>S→AB<br>A→Aa| bB<br>B→a | Sb<br>求句子 baSb的语法树</p><p>首先根据句型baSb的推导过程画出对应的语法树如下：<br>$$SAB\Rightarrow bBB\Rightarrow baB\Rightarrow baSb$$<br>$$S\Rightarrow AB\Rightarrow ASb\Rightarrow bBSb\Rightarrow baSb$$<br>语法树如下图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_6cf66d7ee8-6.png" alt="6.png"></p><h2 id="课后作业-2">课后作业</h2><ol><li><p>已知文法G[T]：T→T*F | F ；F→F↑P | P ；P→(T) | i<br>画出B：T*P↑(T *F)的语法树<br><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_288019cde8-1.png" alt="1.png"></p></li><li><p>试描述由下列⽂法所产⽣的语⾔<br>S→aAd A→aAd∣bBc B→bBc∣e<br>$$L(S)=\{a^ib^jec^jd^i|i,j \in N^*\}$$</p></li><li><p>S→A|S:A<br>A→A+B| B<br>B→bS* | a</p></li></ol><p>消除文法的左递归<br>$S\to AS’$<br>$S’\to :AS’|\varepsilon$<br>$A\to BA’$<br>$A’\to +BA’|\varepsilon$<br>$B\to bS*|a$<br>构造预测分析表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-built_in">First</span>(S)=&#123;b, a&#125; <br><span class="hljs-built_in">First</span>(S<span class="hljs-number">&#x27;</span>)=&#123;:, ε&#125;  <br><span class="hljs-built_in">First</span>(A)=&#123;b, a&#125;  <br><span class="hljs-built_in">First</span>(A<span class="hljs-number">&#x27;</span>)=&#123;+, ε&#125;  <br><span class="hljs-built_in">First</span>(B)=&#123;b, a&#125;   <br><span class="hljs-built_in">Follow</span>(S)=&#123;*, #&#125;  <br><span class="hljs-built_in">Follow</span>(S<span class="hljs-number">&#x27;</span>)=&#123;*, #&#125;  <br><span class="hljs-built_in">Follow</span>(A)=&#123;:, *, #&#125;  <br><span class="hljs-built_in">Follow</span>(A<span class="hljs-number">&#x27;</span>)=&#123;:, *,#&#125;  <br><span class="hljs-built_in">Follow</span>(B)=&#123;:, +, *, #&#125;  <br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">b</th><th style="text-align:center">a</th><th style="text-align:center">:</th><th style="text-align:center">+</th><th style="text-align:center">*</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">$S\to AS’$</td><td style="text-align:center">$S\to AS’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">S’</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$S’\to AS’$</td><td style="text-align:center"></td><td style="text-align:center">$S’\to \varepsilon$</td><td style="text-align:center">$S’\to \varepsilon$</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">$A\to BA’$</td><td style="text-align:center">$A\to BA’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">A’</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$A’\to \varepsilon$</td><td style="text-align:center">$A’\to +BA’$</td><td style="text-align:center">$A’\to \varepsilon$</td><td style="text-align:center">$A’\to \#$</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">$B\to bs*$</td><td style="text-align:center">$B\to a$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><ol start="4"><li><p>有文法G[s]:<br>S→BA       A→BS|d     B→aA|bS|c</p><p>写出句子adccd的至下而上和之上而下分析过程<br>自上而下:<br><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_cef60245e8-2.png" alt="2.png"></p><p>自下而上:</p><ol><li>a<u>d</u>ccd</li><li><u>aA</u>ccd</li><li>B<u>c</u>cd</li><li>BB<u>c</u>d</li><li>BBB<u>d</u></li><li>BB<u>BA</u></li><li>B<u>BS</u></li><li><u>BA</u></li><li>S</li></ol></li><li><p>请将表达式-(a+b)*(c+d)-(a+b)分别表示成三元式和四元式序列<br>三元式</p></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">op</th><th style="text-align:center">arg1</th><th style="text-align:center">arg2</th></tr></thead><tbody><tr><td style="text-align:center">(0)</td><td style="text-align:center">+</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">(1)</td><td style="text-align:center">uminus</td><td style="text-align:center">(0)</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">(2)</td><td style="text-align:center">+</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">(3)</td><td style="text-align:center">*</td><td style="text-align:center">(1)</td><td style="text-align:center">(2)</td></tr><tr><td style="text-align:center">(4)</td><td style="text-align:center">+</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">(5)</td><td style="text-align:center">-</td><td style="text-align:center">(3)</td><td style="text-align:center">(4)</td></tr></tbody></table><p>四元式<br>$(+, a, b, t_1)$<br>$(uminus, t_1, -, t_2)$<br>$(+, c, d, t_3)$<br>$(*, t_2, t_3, t_4)$<br>$(+, a, b, t_5)$<br>$(-, t_4, t_5, t_6)$</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础第三章课后习题</title>
      <link href="/2022/06/10/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
      <url>/2022/06/10/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="作业4">作业4</h2><h3 id="1-什么是临界资源、临界区，临界区的使用原则有哪些？">1. 什么是临界资源、临界区，临界区的使用原则有哪些？</h3><p>临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。<br>每个进程中访问临界资源的那段代码称为临界区，每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p><p><strong>临界区使用原则：</strong></p><ol><li>空闲让进：无进程处于临界区时，若有进程要求进入临界区应立即允许进入。</li><li>忙则等待：当已有进程进入临界区时，其他试图进入各自临界区的进程必须等待，以保证诸进程互斥地进入临界区。</li><li>有限等待：有若干进程要求进入临界区时，应在有限时间内使一进程进入临界区，即它们不应相互等待而谁都不进入临界区。</li><li>让权等待：对于等待进入临界区的进程必须释放其占有地CPU。</li></ol><h3 id="2-简述信号量的含义及作用。">2. 简述信号量的含义及作用。</h3><p>含义：信号量相当于一个信号灯，表示状态，是在多线程环境下使用的一种设施，可以用来保证两个或多个关键代码段不被并发调用。<br>作用：用来解决进程同步于互斥问题的机制，包括一个称为信号量的变量和对它进行的两个原语操作。</p><h3 id="3-请用P、V操作描述下列过程">3. 请用P、V操作描述下列过程</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_3edb9faae8-1.png" alt="1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">int</span> S1=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> S2=<span class="hljs-number">0</span>;<br><br>司机进程：<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-built_in">P</span>(S1);<br>启动;<br>正常运行;<br>到站停;<br><span class="hljs-built_in">V</span>(S2);<br>&#125;<br><br>售票员进程：<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br>关门;<br><span class="hljs-built_in">V</span>(S1);<br>售票;<br><span class="hljs-built_in">P</span>(S2);<br>开门;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-图书馆有N个座位，一张登记表，要求-1-阅读者进入时登记，取得座位号；-2-出来时注销。请用P、V操作描述一个读者的使用过程。">4. 图书馆有N个座位，一张登记表，要求(1)阅读者进入时登记，取得座位号；(2)出来时注销。请用P、V操作描述一个读者的使用过程。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP">semaphore empty = N; <span class="hljs-comment">//记录空闲座位数量</span><br>semaphore mutex = <span class="hljs-number">1</span>;<span class="hljs-comment">// 作为互斥的登记和注销操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(empty);<br>    <span class="hljs-built_in">P</span>(mutex);<br>    <span class="hljs-comment">//登记</span><br>    <span class="hljs-built_in">V</span>(mutex);<br>    <span class="hljs-comment">//阅读</span><br>    <span class="hljs-built_in">P</span>(mutex);<br>    <span class="hljs-comment">//注销</span><br>    <span class="hljs-built_in">V</span>(empty);<br>    <span class="hljs-built_in">V</span>(mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有3个进程PA，PB和PC合作解决文件打印问题：-1-PA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录；-2-PB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；-3-PC将缓冲区2的内容打印出来，每执行一次打印一个记录。缓冲区的大小等于一个记录大小。请用P，V操作来保证文件的正确打印。">有3个进程PA，PB和PC合作解决文件打印问题：(1)PA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录；(2)PB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；(3)PC将缓冲区2的内容打印出来，每执行一次打印一个记录。缓冲区的大小等于一个记录大小。请用P，V操作来保证文件的正确打印。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> empty1=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录缓冲区 1 是否为空</span><br><span class="hljs-type">int</span> empty2=<span class="hljs-number">1</span>; <span class="hljs-comment">//记录缓冲区 2 是否为空</span><br><span class="hljs-type">int</span> full1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录缓冲区 1 是否有数据</span><br><span class="hljs-type">int</span> full2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录缓冲区 2 是否有数据</span><br><span class="hljs-type">int</span> mutex1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//对缓冲区 1 的访问互斥</span><br><span class="hljs-type">int</span> mutex2 = <span class="hljs-number">1</span>;<span class="hljs-comment">//对缓冲区 2 的访问互斥</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">cobegin</span><br><span class="hljs-function">    <span class="hljs-title">PA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-built_in">PB</span>();<br>    <span class="hljs-built_in">PC</span>();<br>    coend<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//从磁盘读数据</span><br>    <span class="hljs-built_in">P</span>(empty1);<br>    <span class="hljs-built_in">P</span>(mutex1);<br>    <span class="hljs-comment">//将数据存入缓冲区 1</span><br>    <span class="hljs-built_in">V</span>(mutex1);<br>    <span class="hljs-built_in">V</span>(full1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PB</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(full1);<br>    <span class="hljs-built_in">P</span>(mutex1);<br>    <span class="hljs-comment">//从缓冲区 1 读数据</span><br>    <span class="hljs-built_in">V</span>(mutex1);<br>    <span class="hljs-built_in">V</span>(empty1);<br>    <span class="hljs-built_in">P</span>(empty2);<br>    <span class="hljs-built_in">P</span>(mutex2);<br>    <span class="hljs-comment">//将数据写入缓冲区 2</span><br>    <span class="hljs-built_in">V</span>(mutex2);<br>    <span class="hljs-built_in">V</span>(full2);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PC</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(full2);<br>    <span class="hljs-built_in">P</span>(mutex2);<br>    <span class="hljs-comment">//读取缓冲区 2 的数据并打印</span><br>    <span class="hljs-built_in">V</span>(mutex2);<br>    <span class="hljs-built_in">V</span>(empty2)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="项目2">项目2</h2><h3 id="题目描述">题目描述</h3><p>抽烟者问题。假设一个系统中有三个抽烟者进程，每个抽烟者不断地卷烟并抽烟。抽烟者卷起并抽掉一颗烟需要有三种材料：烟草、纸和胶水。一个抽烟者有烟草，一个有纸，另一个有胶水。系统中还有两个供应者进程，它们无限地供应所有三种材料，但每次仅轮流提供三种材料中的两种。得到缺失的两种材料的抽烟者在卷起并抽掉一颗烟后会发信号通知供应者，让它继续提供另外的两种材料。这一过程重复进行。  请用信号量机制编程，实现该问题要求的功能。</p><h3 id="问题分析">问题分析</h3><p>这个问题主要涉及到操作系统中的进程见的同步与互斥的，是一个非常经典的问题。可以看做是生产者消费者这一类。</p><p>三个抽烟者相当于三个不同的消费者，他们每次只会有一个抽烟者可以抽到烟，其余两个则需要等待。而在这里默认空间大小只有一个单元，即供应者每次放下两种材料后都会停下来等待直到有消费者使用了这两种材料，他才会继续放另两种材料。相当于说缓冲区的大小为1。为了方便起见，我们把要放的两种材料捆绑到一起，看成一个单位，分别用A、B、C表示，三个吸烟着分别用1,2,3号表示。</p><h3 id="大致操作流程和关键代码">大致操作流程和关键代码</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_46c1b6bde8-2.png" alt="2.png"><br>设置五个信号量分别为三个抽烟者对应的glue、tobacco、paper和与供应者相应的同步信号量表示缓存区为空的empty信号量。最后还有一个保证临界资源安全访问的互斥信号量mutex。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs CPP">供应者：                  <span class="hljs-number">1</span>号抽烟者：               <span class="hljs-number">2</span>号抽烟者：                  <span class="hljs-number">3</span>号抽烟者:<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)                    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)                       <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)                          <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br><br>&#123;                                 &#123;                                   &#123; &#123;<br><span class="hljs-built_in">p</span>(empty);                  <span class="hljs-built_in">p</span>(glue);                          <span class="hljs-built_in">p</span>(tobacco); <span class="hljs-built_in">p</span>(paper);<br><br><span class="hljs-built_in">p</span>(mutex);                  <span class="hljs-built_in">p</span>(mutex);                      <span class="hljs-built_in">p</span>(mutex); <span class="hljs-built_in">p</span>(mutex);<br><br>供应材料。                抽烟                              抽烟 抽烟<br><br><span class="hljs-built_in">v</span>(mutex)                    <span class="hljs-built_in">v</span>(mutex);                      <span class="hljs-built_in">v</span>(mutex); <span class="hljs-built_in">v</span>(mutex);<br><br><span class="hljs-keyword">if</span>（材料为A）           <span class="hljs-built_in">v</span>(empty);                        <span class="hljs-built_in">v</span>(empty); <span class="hljs-built_in">v</span>(empty);<br><br><span class="hljs-built_in">v</span>(glue)                        &#125;                                &#125; &#125;<br><br><span class="hljs-keyword">if</span>(材料为B)<br><br><span class="hljs-built_in">v</span>(tobacco)<br><br><span class="hljs-keyword">if</span>(材料为C)<br><br><span class="hljs-built_in">v</span>(paper)<br><br>&#125;   <br><br>信号量的初始值:<br><br>empty=<span class="hljs-number">1</span>;mutex=<span class="hljs-number">1</span>;glue=<span class="hljs-number">0</span>;paper=<span class="hljs-number">0</span>;tobacco=<span class="hljs-number">0</span>;    <br></code></pre></td></tr></table></figure><h3 id="测试结果">测试结果</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/10/99310_0e79e541e8-3.png" alt="3.png"></p><h3 id="完整代码">完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;process.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> random=<span class="hljs-number">0</span>;<br>HANDLE offer1,offer2,offer3;<br>HANDLE finish;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> __stdcall <span class="hljs-title">threadProvider</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        random=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(random == <span class="hljs-number">0</span>) <span class="hljs-built_in">ReleaseSemaphore</span>(offer1,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(random == <span class="hljs-number">1</span>) <span class="hljs-built_in">ReleaseSemaphore</span>(offer2,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">ReleaseSemaphore</span>(offer3,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">WaitForSingleObject</span>(finish,INFINITE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> __stdcall <span class="hljs-title">threadSmoker1</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">WaitForSingleObject</span>(offer1,INFINITE);<br>        cout&lt;&lt;<span class="hljs-string">&quot;Smoker 1 is smoking highly&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">ReleaseSemaphore</span>(finish,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> __stdcall <span class="hljs-title">threadSmoker2</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">WaitForSingleObject</span>(offer2,INFINITE);<br>        cout&lt;&lt;<span class="hljs-string">&quot;Smoker 2 is smoking highly&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">ReleaseSemaphore</span>(finish,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> __stdcall <span class="hljs-title">threadSmoker3</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">WaitForSingleObject</span>(offer3,INFINITE);<br>        cout&lt;&lt;<span class="hljs-string">&quot;Smoker 3 is smoking highly&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">ReleaseSemaphore</span>(finish,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_Smoker</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    offer1=<span class="hljs-built_in">CreateSemaphore</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    offer2=<span class="hljs-built_in">CreateSemaphore</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    offer3=<span class="hljs-built_in">CreateSemaphore</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    finish=<span class="hljs-built_in">CreateSemaphore</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>);<br>    HANDLE hth1,hth2,hth3,hth4;<br><br>    hth1=(HANDLE)_beginthreadex(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,threadProvider,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    hth2=(HANDLE)_beginthreadex(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,threadSmoker1,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    hth3=(HANDLE)_beginthreadex(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,threadSmoker2,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    hth4=(HANDLE)_beginthreadex(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,threadSmoker3,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">WaitForSingleObject</span>(hth1,INFINITE);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hth2,INFINITE);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hth3,INFINITE);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hth4,INFINITE);<br><br>    <span class="hljs-built_in">CloseHandle</span>(hth1);<br>    <span class="hljs-built_in">CloseHandle</span>(hth2);<br>    <span class="hljs-built_in">CloseHandle</span>(hth3);<br>    <span class="hljs-built_in">CloseHandle</span>(hth4);<br>    <span class="hljs-built_in">CloseHandle</span>(offer1);<br>    <span class="hljs-built_in">CloseHandle</span>(offer2);<br>    <span class="hljs-built_in">CloseHandle</span>(offer3);<br>    <span class="hljs-built_in">CloseHandle</span>(finish);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">process_Smoker</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第368-380题</title>
      <link href="/2022/06/08/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC368-380%E9%A2%98/"/>
      <url>/2022/06/08/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC368-380%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目368">题目368</h2><p>$设 (f(x)) 为连续函数，(\lim\limits_{x\to0}\dfrac{xf(x) - \ln(1 + x)}{x^2} = 2).$</p><p>$(F(x) = \displaystyle\int_0^x tf(x-t)dt)，当 (x\to0) 时，(F(x) - \dfrac{1}{2}x^2) 与 (bx^k) 为等价无穷小$</p><p>$其中常数 (b \ne 0)，(k) 为某正整数，求 (k, b, f(0), f’(0))$</p><h3 id="解答-127">解答</h3><p>$先用等式脱帽法，把 (f(x)) 表达式写出来：$</p><p>$[ \dfrac{xf(x)-\ln(1+x)}{x^2} = 2 + o(1) \quad\Rightarrow\quad f(x) = 2x + \dfrac{\ln(1 + x)}{x} + o(x) ]$</p><p>$又 (\ln(1 + x) = x - \dfrac{1}{2}x^2 + o(x^2))，故 (f(x) = 1 + \dfrac{3}{2}x + o(x))$</p><p>$又 (F(x) = \displaystyle x\int_0^xf(u) du - \int_0^x uf(u)du)$</p><p>$(\displaystyle \int_0^x f(u)du = x + \dfrac{3}{4}x^2 + o(x^2))，(\displaystyle \int_0^x uf(u)du = \dfrac{1}{2}x^2 + \dfrac{1}{2}x^3 + o(x^3))$</p><p>$(F(x) = \dfrac{1}{2}x^2 + \dfrac{1}{4}x^3 + o(x^3))，由于 (F(x) - \dfrac{1}{2}x^2) 与 (bx^k) 为等价无穷小$</p><p>$因此 (bx^k \sim \dfrac{1}{4}x^3)，易得：(b = \dfrac{1}{4}, k = 3)$</p><p>$(f(0) = 1)$</p><p>$(f’(0) = \lim\limits_{x\to0}\dfrac{1 + \dfrac{3}{2}x + o(x) - 1}{x} = \dfrac{3}{2})$</p><h2 id="题目369">题目369</h2><p>$设 (f(x) = \lim\limits_{n\to\infty}\dfrac{2e^{(n+1)x} + 1}{e^{nx}+x^n+1})，求 (f(x)) 的间断点$</p><h3 id="解答-128">解答</h3><p>严选题 P3 No.18</p><p>$常用极限结论：(\lim\limits_{n\to\infty} e^{nx} = \begin{cases} \infty &amp; x &gt; 0 \\ 1 &amp; x = 0\\ 0 &amp; x &lt; 0 \end{cases})，以及 (\lim\limits_{n\to\infty} x^n = \begin{cases} \infty &amp; |x| &gt; 1 \\ 0 &amp; |x| &lt; 1 \\ 1 &amp; x = 1\\ \not\exists &amp; x = -1 \end{cases})，还有常用不等式：(e^x - 1 &gt; x)$</p><p>$(x &gt; 0) 时：(f(x) = \lim\limits_{n\to\infty}\dfrac{2e^{x} + \dfrac{1}{e^{nx}}}{1+(\dfrac{x}{e^x})^n+\dfrac{1}{e^{nx}}} = 2e^x)$</p><p>$(x = 0) 时：(f(x) = \dfrac{3}{2})$</p><p>$(-1 &lt; x &lt; 0) 时：(f(x) = 1)$</p><p>$(x &lt; -1) 时：(f(x) = \lim\limits_{n\to\infty} \dfrac{1}{x^n + 1} = 0)$</p><p>$故 (f(x) = \begin{cases} 0 &amp; x &lt; -1 \\ 1 &amp; -1 &lt; x &lt; 0 \\ \dfrac{3}{2} &amp; x = 0 \\ 2e^x &amp; x &gt; 0 \end{cases})$</p><p>$故有两个跳跃间断点 (x = -1, x = 0)$</p><h2 id="题目370">题目370</h2><p>下列命题成立的是（ ）</p><p>$（A）若 (\lim\limits_{x\to0}\varphi(x)=0)，且 (\lim\limits_{x\to0}\dfrac{f[\varphi(x)] - f(0)}{\varphi(x)}) 存在，则 (f(x)) 在 (x=0) 处可导$</p><p>$（B）若 (f(x)) 在 (x=0) 处可导，且 (\lim\limits_{x \to 0}\varphi(x) = 0)，则 (\lim\limits_{x\to0}\dfrac{f[\varphi(x)]-f(0)}{\varphi(x)} = f’(0))$</p><p>$（C）若 (\lim\limits_{x\to0}\dfrac{f(\sin x) - f(0)}{\sqrt{x^2}}) 存在，则 (f(x)) 在 (x=0) 处可导$</p><p>$（D）若 (\lim\limits_{x\to0}\dfrac{f(\sqrt[3]{x})-f(0)}{\sqrt{x^2}}) 存在，则 (f(x)) 在 (x=0) 处可导$</p><h3 id="解答-129">解答</h3><p>$（A）选项 显然错误，反例：(\varphi(x) = x^2) 只能说明存在右导数$</p><p>$（B）选项 显然错误，反例：(\varphi(x) \equiv 0)，等式不成立$</p><p>$（C）选项 先凑导数定义看看：$</p><p>$[ \lim\limits_{x\to0}\dfrac{f(\sin x) - f(0)}{\sqrt{x^2}} = \lim\limits_{x\to0}\dfrac{f(\sin x) - f(0)}{\sin x} \cdot \dfrac{\sin x}{|x|} = \lim\limits_{x\to0}\dfrac{f(\sin x) - f(0)}{\sin x} \cdot \dfrac{x}{|x|} ]$</p><p>$(\lim\limits_{x\to0}\dfrac{x}{|x|}) 有界，不一定要用 (0) 去抵消，可以考虑反向构造一个可以抵消正负号的极限即可$</p><p>$欲使极限存在，且导数定义的极限不存在，构造反例：(f_{+}‘(0)=1, f_{-}’(0)=-1)$</p><p>$有 (\lim\limits_{x\to0}\dfrac{f(\sin x) - f(0)}{\sin x} \cdot \dfrac{x}{|x|} = 1) 极限存在，且导数不存在$</p><p>$（D）选项 先凑导数定义看看：$</p><p>$[ \lim\limits_{x\to0}\dfrac{f(\sqrt[3]{x})-f(0)}{\sqrt{x^2}} = \lim\limits_{x\to0}\dfrac{f(\sqrt[3]{x})-f(0)}{\sqrt[3]{x}} \cdot \dfrac{\sqrt[3]{x}}{|x|} ]$</p><p>$显然 (\lim\limits_{x\to0}\dfrac{\sqrt[3]{x}}{|x|}) 无界振荡，欲使极限存在，则必然有：(\lim\limits_{x\to0}\dfrac{f(\sqrt[3]{x})-f(0)}{\sqrt[3]{x}} = 0)，即 (f’(0) = 0)$</p><p>$因此答案选择 ((\mathbf{D})) 选项$</p><h2 id="题目371">题目371</h2><p>$设 (f(x)) 在 (x_0) 点可导，(\alpha_n,\beta_n) 为趋于零的正向数列，求极限 [ \lim_{n\to\infty}\dfrac{f(x_0+\alpha_n) - f(x_0-\beta_n)}{\alpha_n + \beta_n} ]$</p><h3 id="解答-130">解答</h3><p>$考虑写出在 (f(x)) 在 (x_0) 点的可微定义式：$</p><p>$(f(x_0 + \alpha_n) - f(x_0) = f’(x_0)\alpha_n + o(\alpha_n))$</p><p>$(f(x_0 - \beta_n) - f(x_0) = -f’(x_0)\beta_n + o(\beta_n))$</p><p>$[ \begin{aligned} &amp; \lim_{n\to\infty}\dfrac{f(x_0+\alpha_n) - f(x_0-\beta_n)}{\alpha_n + \beta_n} \\ =&amp; \lim\limits_{n\to\infty}\dfrac{f(x_0)+f’(x_0)\alpha_n + o(\alpha_n) - f(x_0)+f’(x_0)\beta_n + o(\beta_n)}{\alpha_n + \beta_n} \\ =&amp; f’(x_0) + \lim\limits_{n\to\infty}\dfrac{o(\alpha_n)+ o(\beta_n)}{\alpha_n + \beta_n} \\ =&amp; f’(x_0) \end{aligned} ]$</p><h2 id="题目372">题目372</h2><p>$设函数 (\varphi(x) = \displaystyle\int_0^{\sin x}f(tx^2)dt)，其中 (f(x)) 是连续函数，且 (f(0) = 2)$</p><p>$（1）求 (\varphi’(x))$</p><p>$（2）讨论 (\varphi’(x)) 的连续性$</p><h3 id="解答-131">解答</h3><p>$当 (x = 0) 时：(\varphi(0) = 0)$</p><p>$当 (x \ne 0) 时：先对被积函数换元：令 (tx^2 = u)，有 (\varphi(x) = \dfrac{1}{x^2}\displaystyle\int_0^{x^2\sin x} f(u)du)$</p><p>$于是有：(\varphi(x) = \begin{cases} \dfrac{1}{x^2}\displaystyle\int_0^{x^2\sin x} f(u)du &amp;,x\ne0 \\ 0 &amp;,x=0 \end{cases})$</p><p>$然后直接求导即可：(\varphi’(x) = \dfrac{(2\sin x + x\cos x) f(x^2\sin x) x^2 - 2\displaystyle\int_0^{x^2\sin x}f(u)du}{x^3})$</p><p>$(x=0) 点用导数定义：$</p><p>$[ \begin{aligned} \varphi’(0) = \lim_{x\to0}\dfrac{\displaystyle\int_0^{x^2\sin x} f(u)du}{x^3} = \lim_{x\to0}\dfrac{\displaystyle\int_0^{x^3} f(u)du}{x^3} = \lim_{\xi\to0}f(\xi) = 2 \end{aligned} ]$</p><p>$综上：(\varphi’(x) = \begin{cases} \dfrac{(2\sin x + x\cos x) f(x^2\sin x) x^2 - 2\displaystyle\int_0^{x^2\sin x}f(u)du}{x^3} &amp;,x\ne0 \\ 2&amp;,x=0 \end{cases})$</p><p>$讨论 (x=0) 处的连续性$</p><p>$[ \begin{aligned} \lim_{x\to0}\varphi(x) &amp;= \lim_{x\to0}\dfrac{(2\sin x + x\cos x) f(x^2\sin x) x^2 - 2\displaystyle\int_0^{x^2\sin x}f(u)du}{x^3} \\ &amp;= \lim_{x\to0}\dfrac{(2\sin x + x\cos x) f(x^2\sin x) x^2}{x^3} - 2\lim_{x\to0}\dfrac{\displaystyle\int_0^{x^2\sin x}f(u)du}{x^3} \\ &amp;= 3f(0) - 2f(0) \\ &amp;= 2 \end{aligned} ]$</p><p>$由 (\lim\limits_{x\to0}\varphi’(x) = \varphi(0))，故 (\varphi’(x)) 在 (x = 0) 处连续$</p><p>$因此 (\varphi’(x)) 在 (\mathbf{R}) 上连续$</p><h2 id="题目373">题目373</h2><p>$设 (x = \displaystyle\int_0^1 e^{tu^2}du, y = y(t)) 由方程 (t - \displaystyle\int_1^{y+t}e^{-u^2}du=0) 所确定，求$</p><p>$(y’_{t}(0), y’‘_t(0), x’_t(0), x’'_t(0))$</p><p>$(y’_x(0), y’'_x(0))$</p><h3 id="解答-132">解答</h3><p>$隐函数问题，先确定初值：(y|_{t=0} = 1)，然后方程两侧关于 (t) 求导：$</p><p>$[ 1 - (y’+1) e^{-(y+t)^2} = 0 \quad\Rightarrow\quad y’= e^{(y+t)^2} - 1 ]$</p><p>$代入可得： (y’|_{t=0}= e-1)，再求一次导：$</p><p>$[ y’’ = 2e^{(y+t)^2} \cdot (y+t) \cdot (y’ + 1) ]$</p><p>$代入可得：(y’'|_{t=0} = 2e^2)$</p><p>$对于 (x) 的方程很难直接求导，需要换元分段，不妨试试求解高阶导数的方法之一：泰勒展开$</p><p>$[ x = \displaystyle\int_0^1 tu^2 + \dfrac{1}{2}t^2u^4 + o(t^2u^4) du = \dfrac{1}{3}t + \dfrac{1}{10}t^2 + o(t^2) ]$</p><p>$于是有 (x’(0) = \dfrac{1}{3})，(x’'(0) = \dfrac{1}{5})$</p><p>$第二问直接用公式即可：(\dfrac{d^2y}{dx^2} = \dfrac{y’‘x’-y’x’‘}{x’^3})$</p><p>$(\dfrac{dy}{dx} = \dfrac{e-1}{1/3} = 3e-3)，(\dfrac{d^2y}{dx^2} = 27 \cdot (\dfrac{2}{3}e^2 - \dfrac{1}{5}(e-1)) = 18e^2 - \dfrac{27}{5}(e-1))$</p><h2 id="题目374">题目374</h2><p>$设 (f(x) = \begin{cases} \dfrac{x-\sin x}{x^3} &amp;,x\ne0\\ a&amp;,x=0 \end{cases}) 处处连续，则 f’'(0) = $</p><h3 id="解答-133">解答</h3><p>$求一点处的高阶导数，可以用泰勒展开或洛必达$</p><p>$本题不妨把 (f(x)) 在 (x=0) 处泰勒展开：$</p><p>$[ f(x) = \dfrac{1}{6} - \dfrac{1}{120}x^2 + o(x^2) ]$</p><p>$故 (a = f(0) = \dfrac{1}{6}, f’(0) = 0, f’'(0) = -\dfrac{1}{60})$</p><h2 id="题目375">题目375</h2><p>$设有方程 (a^x = bx (a&gt;1))，则下列结论不正确的是$</p><p>$（A）当 (b &lt; 0) 时原方程有唯一实根$</p><p>$（B）当 (0 &lt; b &lt; 2\ln a) 时原方程无实根$</p><p>$（C）当 (b = 3\ln a) 时原方程有唯一实根$</p><p>$（D）当 (b &gt; 3\ln a) 时原方程有两实根$</p><h3 id="解答-134">解答</h3><p>$令 (F(x) = a^x - bx)，于是原方程有根问题，就化归到函数 (F(x)) 有零点问题$</p><p>$求导找单调性：(F’(x) = \ln a \cdot a^x - b, F’'(x) = \ln^2 a \cdot a^x)$</p><p>$由于 (a &gt; 1)，故 (\ln a &gt; 0) (\quad\Rightarrow\quad) (F’'(x) &gt; 0)$</p><p>$故 (F’(x)) 单调递增，又 (F’(-\infty) = -b)，(F’(+\infty) = +\infty)$</p><p>$（1）若 (-b &lt; 0)，即 (b &gt; 0)，则可由推广的零点定理可得：(F’(x)) 存在唯一零点$</p><p>$则可知 (F(x)) 先单调递减，后单调递增，令 (F’(x) = 0)，易得极小值点：(x = \dfrac{\ln \dfrac{b}{\ln a}}{\ln a})$</p><p>$由于该极值点为唯一极值点，根据已知结论可知，其为区间上的最小值点$</p><p>$令 (F(x) &lt; 0)，有 (b &gt; e\ln a)，方程有两个零点；反之 (0 &lt; b &lt; e\ln a) 时，方程无零点$</p><p>$(b = e\ln a) 时，函数有唯一零点$</p><p>$（2）若 (-b &gt; 0)，即 (b &lt; 0)，则 (F’(x) &gt; 0)，即 (F(x)) 单调递增$</p><p>$又 (F(-\infty) = - \infty &lt; 0, F(+\infty) = +\infty &gt; 0)，由零点定理，有唯一零点$</p><p>$综上，经过函数性态分析可得，错误结论为：(\mathbf{C})$</p><h2 id="题目376">题目376</h2><p>$设 (f(x)) 是可微函数，当 (0 &lt; a &lt; x &lt; b) 时，恒有 (xf’(x) &lt; 2f(x))，则$</p><p>$（A）(a^2f(x) &gt; x^2f(a))$</p><p>$（B）(b^2f(x) &gt; x^2f(b))$</p><p>$（C）(xf(x) &lt; bf(b))$</p><p>$（D）(xf(x) &gt; af(a))$</p><h3 id="解答-135">解答</h3><p>屑题，构造函数求导找单调性即可</p><p>$A/B 选项：令 (F(x) = \dfrac{f(x)}{x^2})，则 (F’(x) = \dfrac{f’(x)x - 2f(x)}{x^3})$</p><p>$又 (x &gt; 0) &amp; (xf’(x) &lt; 2f(x))，故 (F’(x) &lt; 0) (\quad\Rightarrow\quad) (F(x)) 单调递减$</p><p>$于是有 (F(a) &gt; F(x) &gt; F(b))，故 (x^2f(a) &gt; a^2f(x))，(b^2f(x) &gt; x^2f(b))$</p><p>$故正确选项为 (\mathbf{B})$</p><h2 id="题目377">题目377</h2><p>$设 (f(x)) 二阶可导，且 (f(1) = 6)，(f’(1) = 0)，且当 (x \ge 1) 时，(x^2f’‘(x) - 2xf’(x) - 5f(x) \ge 0)$</p><p>$证明：当 (x \ge 1) 时，(f(x) \ge x^5 + \dfrac{5}{x})$</p><h3 id="解答-136">解答</h3><p>利用不等式，找原函数构造辅助函数，然后利用单调性求解不等式</p><p>$由于 (x^2f’‘(x) - 2xf’(x) - 5f(x) = x^2f’‘(x)+2xf’(x) - (5xf’(x) + 5f(x)))$</p><p>$可得原函数为：(F(x) = x^2f’(x) - 5xf(x))，则 (F’(x) \ge 0)，函数 (F(x)) 单调递增$</p><p>$又 (F(1) = -30)，故 (F(x) \ge -30) (\quad\Rightarrow\quad) (x^2f’(x) - 5xf(x) + 30\ge 0)$</p><p>$不等式两侧同除 (x^2) 化简不等式：(y’ - \dfrac{5}{x} y + \dfrac{30}{x^2} \ge 0)$</p><p>$观察到 (y’ - \dfrac{5}{x} y) 可以用积分因子还原到：(y \cdot x^{-5})：(y’x^{-5} - \dfrac{5}{x^6}y + \dfrac{30}{x^7} = (yx^{-5} - \dfrac{5}{x^6} + C)’ \ge 0)$</p><p>在结论中凑出来即可证明完毕：</p><p>$令 (G(x) = yx^{-5} - 5 x^{-6} - 1)，则 (G(1) = 0)$</p><p>$(G’(x) = y’x^{-5} -\dfrac{5}{x^6}y + \dfrac{30}{x^7} = \dfrac{1}{x^5}(y’ - \dfrac{5}{x}y + \dfrac{30}{x^2}) \ge 0)$</p><p>$于是 (G(x)) 单调递增，故 (G(x) \ge G(1) = 0)$</p><p>$(\mathbf{QED})$</p><h2 id="题目378">题目378</h2><p>$设 (f(x) = \displaystyle\int_0^x t|x-t|dt - \dfrac{x^2}{6})，试求：$</p><p>$（1）函数 (f(x)) 的极值和曲线 (y = f(x)) 的凹凸区间及拐点$</p><p>$（2）曲线 (y = f(x)) 与 (x) 轴围成的区域的面积及绕 (y) 轴旋转所得旋转体的体积$</p><h3 id="解答-137">解答</h3><p>$有绝对值，先去绝对值，写出函数的分段：(f(x) = \begin{cases} \displaystyle\int_0^x (tx-t^2) dt - \dfrac{x^2}{6} &amp; x \ge 0 \\ \displaystyle\int_0^x (t^2-tx) dt - \dfrac{x^2}{6} &amp; x \lt 0 \end{cases})$</p><p>$被积函数幂函数，不妨直接积分出来，有：(f(x) = \begin{cases} \dfrac{1}{6}x^3 - \dfrac{1}{6}x^2 &amp; x \ge 0 \\ -\dfrac{1}{6}x^3 - \dfrac{1}{6}x^2 &amp; x \lt 0 \end{cases})$</p><p>$求导 并配合 导数定义，有：(f’(x) = \begin{cases} \dfrac{1}{2}x^2 - \dfrac{1}{3}x &amp; x \ge 0 \\ -\dfrac{1}{2}x^2 - \dfrac{1}{3}x &amp; x \lt 0 \end{cases})，有 驻点 (x = 0, \pm\dfrac{2}{3})$</p><p>$易得有极大值 (f(0) = 0)，极小值 (f(\dfrac{2}{3}) = -\dfrac{2}{81}, f(-\dfrac{2}{3}) = -\dfrac{2}{81})$</p><p>$再求一阶导并配合 导数定义 有： (f’'(x) = \begin{cases} x - \dfrac{1}{3} &amp; x \gt 0 \\ -x - \dfrac{1}{3}&amp; x \lt 0 \end{cases})，易得拐点 ((\dfrac{1}{3}, -\dfrac{1}{81}), (-\dfrac{1}{3}, -\dfrac{1}{81}))$</p><p>体积可以直接用面积微元法：</p><p>$[ \begin{aligned} V = 2\pi \iint\limits_D |x| d\sigma = 2\pi \int_{0}^{1}dx\int_{f(x)}^0 x dy = \dfrac{1}{3}\pi \int_0^1 (x^3 - x^4)dx = \dfrac{1}{60}\pi \end{aligned} ]$</p><h2 id="题目379">题目379</h2><p>$曲线：(y = e^{\frac{1}{x}}\sqrt{1+x^2}) 的渐进线条数$</p><h3 id="解答-138">解答</h3><p>$铅锤渐近线：(x=0)$</p><p>没有水平，找斜渐近线可以考虑泰勒展开:</p><p>$[ \begin{aligned} e^{\frac{1}{x}}\sqrt{1+x^2} &amp;= |x|e^{\frac{1}{x}}\sqrt{1+\frac{1}{x^2}} \\ &amp;= |x|(1+\frac{1}{x} + o(\frac{1}{x}))(1+\frac{1}{2x^2} + o(\frac{1}{x^2})) \\ &amp;= |x|(1+\frac{1}{x} + o(\frac{1}{x})) \\ &amp;= |x|+\frac{|x|}{x}+o(\frac{|x|}{x}) \end{aligned} ]$</p><p>$故有些渐进线：(y = x + 1) 和 (y = -x - 1)$</p><p>共三条</p><h2 id="题目380">题目380</h2><p>$设 (f(x)) 在 ([-2,2]) 上二阶可导，且 (|f(x)|\le1)，又 ([f(0)]^2 + [f’(0)]^2 = 4)$</p><p>$证明：(\exists \xi \in (-2, 2), s.t. f’'(\xi) + f(\xi) = 0)$</p><h3 id="解答-139">解答</h3><p>$[ (y^2 + y’^2)’ = 2y’(y’’ + y) ]$</p><p>$故令 (F(x) = f^2(x) + f’^2(x))，则 (F(0) = 4)$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常生活中吸取的教训</title>
      <link href="/2022/06/08/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%90%B8%E5%8F%96%E7%9A%84%E6%95%99%E8%AE%AD/"/>
      <url>/2022/06/08/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%90%B8%E5%8F%96%E7%9A%84%E6%95%99%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主码和候选码的区别</title>
      <link href="/2022/06/07/%E4%B8%BB%E7%A0%81%E5%92%8C%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/07/%E4%B8%BB%E7%A0%81%E5%92%8C%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>主码  $in$ 候选码 $in$ 码</p><p>ps：元组理解为一张表的某一行，属性理解为一张表的某一列，属性名就是列的名字（字段）。</p><p>1（码）：码是可以确定一个元组的所有信息的属性名或属性名组。</p><p>例如在 { a, b, c, d } 中，</p><p>假设知道 a 的值就能确定  a, b, c, d  的值，</p><p>假设知道 c, d 的值就可以确定  a, b, c, d  的值，</p><p>那么 { a } 就是码，{ c, d } 就是码。</p><p>并且 { a, b }, { a, c }, { a, b, c }, { a, b, c, d } 等也都是码，因为它们也可以确定一个元组的所有值，即使很多余。</p><p>2（候选码）：候选码的真子集中不存在码，候选码可以有多个。</p><p>就上面的例子而言，{ a } 是候选码，{ c, d } 是候选码，因为它们的真子集中不存在码。</p><p>而诸如 { a, b } 并不是候选码，因为它的真子集中含有 { a }， 且 { a } 是码。</p><p>3（主码）：主码就是主键的意思，主码是任意一个候选码。</p><p>还是上面的例子，主码是候选码 { a }， { c, d } 中的其中一个。</p><p>既可以是 { a }， 也可以是 { c, d }。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训搜索与字符串专题</title>
      <link href="/2022/06/06/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/"/>
      <url>/2022/06/06/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="B题">B题</h2><h3 id="题意分析-21">题意分析</h3><p>给定仅由数码组成的串 a 和非负整数 l 与 r，求满足该划分中任意一个串都是一个正当整数（没有多余的前导零）且属于闭区间 [l, r]的划分个数。</p><p>ExKMP+前缀和优化 DP。</p><p>令f[i]为划分到i为止的方案数<br>然后朴素的暴力转移是$O(n^2)$的，非常显然一个状态i能够转移的j是一段连续的，进而想到使用前缀和，优化<br>令l的长度为sl，r的长度为sr，那么长度为len(sl&lt; len &lt; sr)的一段数字必然满足l &lt; s &lt; r。然后后那么我们只需要考虑当前状态ii的时候[i, i + sl)和[i,i+sr)这两段区间分别和l，r的大小关系。<br>如果要比较两个字符串aa和bb的大小关系，我们完全先特判掉两个完全一样的情况，然后再求出它们的lcp，然后那么a和b的大小关系就是a[lcp+1]和b[lcp+1]的大小关系了<br>lcp可以用哈希+二分解决，接下来的事情就是DP的了。</p><h3 id="代码-23">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ULL unsigned long long</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1000010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> LL Mod=<span class="hljs-number">998244353</span>;<br><br>LL n,m,p,f[MAXN+<span class="hljs-number">5</span>],s[MAXN+<span class="hljs-number">5</span>];<br><span class="hljs-type">char</span> S[MAXN+<span class="hljs-number">5</span>],L[MAXN+<span class="hljs-number">5</span>],R[MAXN+<span class="hljs-number">5</span>];<br><br>ULL P,pw[MAXN+<span class="hljs-number">5</span>],Hash[MAXN+<span class="hljs-number">5</span>],Hashl[MAXN+<span class="hljs-number">5</span>],Hashr[MAXN+<span class="hljs-number">5</span>];<br><span class="hljs-function">ULL <span class="hljs-title">GetHash</span><span class="hljs-params">(ULL *H,LL L,LL R)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> H[R]-pw[R-L+<span class="hljs-number">1</span>]*H[L<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">LCP</span><span class="hljs-params">(ULL *A,LL l1,LL r1,ULL *B,LL l2,LL r2)</span></span><br><span class="hljs-function"></span>&#123;<br>LL L=<span class="hljs-number">0</span>,R=r1;<br><span class="hljs-keyword">while</span>(L+<span class="hljs-number">1</span>&lt;R)<br>&#123;<br>LL Mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">GetHash</span>(A,l1,l1+Mid<span class="hljs-number">-1</span>)==<span class="hljs-built_in">GetHash</span>(B,l2,l2+Mid<span class="hljs-number">-1</span>))<br>L=Mid;<br><span class="hljs-keyword">else</span> R=Mid;<br>&#125;<br><span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkl</span><span class="hljs-params">(LL x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(m&gt;n-x+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>LL lcpl=<span class="hljs-built_in">LCP</span>(Hash,x,n,Hashl,<span class="hljs-number">1</span>,m);<br><span class="hljs-keyword">if</span>(lcpl==m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> L[lcpl+<span class="hljs-number">1</span>]&lt;S[x+lcpl];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkr</span><span class="hljs-params">(LL x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(p&gt;n-x+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>LL lcpr=<span class="hljs-built_in">LCP</span>(Hash,x,n,Hashr,<span class="hljs-number">1</span>,p);<br><span class="hljs-keyword">if</span>(lcpr==p) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> S[lcpr+x]&lt;R[<span class="hljs-number">1</span>+lcpr];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,S+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,L+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,R+<span class="hljs-number">1</span>);<br>n=<span class="hljs-built_in">strlen</span>(S+<span class="hljs-number">1</span>),m=<span class="hljs-built_in">strlen</span>(L+<span class="hljs-number">1</span>),p=<span class="hljs-built_in">strlen</span>(R+<span class="hljs-number">1</span>);<br>P=<span class="hljs-number">13331</span>,pw[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(m,p),n)+<span class="hljs-number">1</span>;i++)<br>pw[i]=pw[i<span class="hljs-number">-1</span>]*P;<br><br><span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>Hash[i]=P*Hash[i<span class="hljs-number">-1</span>]+(S[i]-<span class="hljs-string">&#x27;a&#x27;</span>);<br><br><span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>Hashl[i]=P*Hashl[i<span class="hljs-number">-1</span>]+(L[i]-<span class="hljs-string">&#x27;a&#x27;</span>);<br><br><span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>;i&lt;=p;i++)<br>Hashr[i]=P*Hashr[i<span class="hljs-number">-1</span>]+(R[i]-<span class="hljs-string">&#x27;a&#x27;</span>);<br><br>f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(i)<br>&#123;<br>s[i]=(s[i]+s[i<span class="hljs-number">-1</span>])%Mod;<br>f[i]=(f[i]+s[i])%Mod;<br>&#125;<br><span class="hljs-keyword">if</span>(S[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>&amp;&amp;L[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>f[i+<span class="hljs-number">1</span>]=(f[i+<span class="hljs-number">1</span>]+f[i])%Mod;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(m==p)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkl</span>(i+<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-built_in">checkr</span>(i+<span class="hljs-number">1</span>))<br>f[i+m]=(f[i+m]+f[i])%Mod;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>s[m+i+<span class="hljs-number">1</span>]=(s[m+i+<span class="hljs-number">1</span>]+f[i])%Mod;<br>s[i+p]=(s[i+p]+Mod-f[i])%Mod;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkl</span>(i+<span class="hljs-number">1</span>))<br>f[i+m]=(f[i+m]+f[i])%Mod;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkr</span>(i+<span class="hljs-number">1</span>))<br>f[i+p]=(f[i+p]+f[i])%Mod;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C题">C题</h2><h3 id="题意分析-22">题意分析</h3><p>考虑贪心，我们可以发现每次比较 A 或 B 串目前剩下的首个字母的字典序大小关系，取较小的一个，有很大机率获得正确答案。但存在一种情况,  $A_i=B_j$ 需要思考，我们应该取A串首字母，还是B串首字母。</p><p>假设当前我们看到了 $$A_i$$ 和 $$B_j$$，接着又有连续 k 个相同字符（包括当前位置）,不妨设 $$A_{i+k} &lt; B_{j+k}$$ 出现，则会有两种策略：</p><ol><li>先取 $$A_i$$  ，然后逐位比较，在若干次比较后，必然会对 $$A_{i+k}$$ 和 $$B_{x}$$ 进行比较，且满足 $$x\leq i + k$$ , $$A_{i+k}&lt;B_x$$ 这两个条件。然后选入 $$A_{i+k}$$ 这个字符。</li><li>先取 $$B_i$$，同理，必然会对 $$B_{i+k}$$ 和 $$A_{x}$$ 进行比较，但不同的是x不一定满足一策略中的条件。若 $$x\leq i+k$$ 且 $$B_{i+k}&lt;A_x$$ ，则 $$B_{i+k}$$ 一定会在 $$A_{i+k}$$ 之前被选出。所以字典序不为最小，若 $$x&gt;i+k$$ ，则无影响<br>综上，利用后缀数组将每个位置所对应的 $$RK_i$$求出用于维护选择。即可求出答案。注意，由于是两个串，所以需要将两串合并，中间需要用分隔符隔开。</li></ol><h3 id="代码-24">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">400010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p, q = <span class="hljs-number">1</span>, k;<br><span class="hljs-type">int</span> a[N],b[N],c[N],sa[<span class="hljs-number">2</span>][N],rk[<span class="hljs-number">2</span>][N],cnt[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> sa[],<span class="hljs-type">int</span> rk[],<span class="hljs-type">int</span> SA[],<span class="hljs-type">int</span> RK[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cnt[rk[sa[i]]]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i -- )<br><span class="hljs-keyword">if</span>(sa[i] &gt; k) SA[cnt[rk[sa[i]-k]]--]=sa[i]-k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - k + <span class="hljs-number">1</span>; i &lt;= n; i ++ ) SA[cnt[rk[i]]--]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; i ++ )<br>RK[SA[i]]=RK[SA[i<span class="hljs-number">-1</span>]]+(rk[SA[i]]!=rk[SA[i<span class="hljs-number">-1</span>]]||rk[SA[i]+k]!=rk[SA[i<span class="hljs-number">-1</span>]+k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),c[i] =a [i];<br><br>c[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1001</span>;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]),c[n + i + <span class="hljs-number">1</span>] = b[i];<br><br>n += m + <span class="hljs-number">2</span>;<br><br>c[n]=<span class="hljs-number">1001</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cnt[c[i]] ++ ;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">1001</span>; i ++ ) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) sa[p][cnt[c[i]]--]=i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++ )<br>rk[p][sa[p][i]]=rk[p][sa[p][i<span class="hljs-number">-1</span>]]+(c[sa[p][i]]!=c[sa[p][i<span class="hljs-number">-1</span>]]);<br><br><span class="hljs-keyword">for</span>(k = <span class="hljs-number">1</span>;k &lt; n ;k &lt;&lt;=<span class="hljs-number">1</span> , <span class="hljs-built_in">swap</span>(p,q) ) <span class="hljs-built_in">calc</span>(sa[p],rk[p],sa[q],rk[q]);<br><br>n -= m + <span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>,y = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(x &lt;= n || y &lt;= m)<br><span class="hljs-keyword">if</span>(y &gt; m||( x &lt;=n &amp;&amp;(rk[p][x] &lt; rk[p][y+n+<span class="hljs-number">1</span>]))) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[x++]);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[y++]);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D题">D题</h2><h3 id="题意分析-23">题意分析</h3><p>给定一些可以组成大立方体的小立方体的相对位置，需要还原原来的立方体</p><p>如果我们知道了原来立方体的各个小立方体的坐标，那么直接O(6x a)次枚举是可以得到答案的。</p><p>因此难点在于如何还原立方体。</p><p>现在我们令(x,y,z)表示在平面上坐标(x,y)，高度z的点。</p><p>我们不难看出，度数为3的点只能出现在6个顶点的位置。</p><p>因此我们可以将其中一个3度点标为(1,1,1)开始搜。</p><p>用(x,y,z)表示在平面上坐标(x,y)，高度z的点。</p><p>首先，我们找一个度数为3的点，把他当成(1,1,1)。</p><p>假如得到高度为1的那一层平面，我们就可以一层层推上去。</p><p>考虑如何从当前1-a,1-a这样的一个正方形扩展成a+1的。</p><p>高度为1的点的特点是度数=4(如果在边缘上)或5，而上面的点的度数是5或6。</p><p>所以我们可以先用原来度数=4的两个点找出现在度数=4的两个点，</p><p>之后从他们开始bfs,只有当一个点有两个已访问的相邻点时才访问它。</p><h3 id="代码-25">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">343500</span>;<br><br><span class="hljs-type">char</span> c;<br><span class="hljs-type">int</span> n, bb[N], val[N], q[N], bbb[N], cnt, maxx, minn = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">bool</span> st[N];<br>vector &lt;<span class="hljs-type">int</span>&gt; To[N], zero, dire[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == zero.<span class="hljs-built_in">size</span>())<br>    &#123;<br>    maxx &lt; cnt ? maxx = cnt : <span class="hljs-number">0</span>;<br>    minn &gt; cnt ? minn = cnt : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vector &lt;<span class="hljs-type">int</span>&gt; now;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> T = <span class="hljs-number">0</span>; T &lt;= <span class="hljs-number">5</span>; T++)<br>    &#123;<br>        now.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, y; j &lt; dire[x][T].<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            y = dire[x][T][j];<br>            <span class="hljs-keyword">if</span>(!st[y])<br>                now.<span class="hljs-built_in">push_back</span>(y), st[y] = <span class="hljs-number">1</span>, cnt += val[y];<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; now.<span class="hljs-built_in">size</span>(); j++)<br>st[now[j]] = <span class="hljs-number">0</span>, cnt -= val[now[j]];<br><br>        <span class="hljs-keyword">if</span>(dire[x][T].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    n = n * n * n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, num; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val[i]);<br>        <span class="hljs-keyword">if</span>(!val[i]) zero.<span class="hljs-built_in">push_back</span>(i);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            num = <span class="hljs-number">0</span>, c = <span class="hljs-built_in">getchar</span>();<br>            <span class="hljs-keyword">while</span>(c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>            <span class="hljs-keyword">while</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) num = num * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>, c = <span class="hljs-built_in">getchar</span>();<br>To[i].<span class="hljs-built_in">push_back</span>(num);<br><span class="hljs-keyword">if</span>((c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, l, r, now; i &lt; zero.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>, now = zero[i], bb[now] = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; To[now].<span class="hljs-built_in">size</span>(); j++)<br>bb[To[now][j]] = j + <span class="hljs-number">1</span>, bbb[To[now][j]] = <span class="hljs-number">1</span>, q[++r] = To[now][j];<br>        <span class="hljs-keyword">while</span>(l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> x = q[l++];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, to; j &lt; To[x].<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                to = To[x][j];<br>                <span class="hljs-keyword">if</span>(bb[to] == <span class="hljs-number">0</span>)<br>bb[to] = bb[x], bbb[to] = bbb[x] + <span class="hljs-number">1</span>, q[++r] = to;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bbb[to] == bbb[x] + <span class="hljs-number">1</span>)<br>st[to] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= r; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st[q[j]]) <br>dire[i][bb[q[j]] - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(q[j]);<br>            st[q[j]] = <span class="hljs-number">0</span>, bb[q[j]] = bbb[q[j]] = <span class="hljs-number">0</span>;<br>        &#125;<br>        bb[now] = bbb[now] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, minn, maxx);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="G题">G题</h2><h3 id="题意分析-24">题意分析</h3><p>初始场上有一个数字，每轮选择一个数字并获得它模7的得分，清除其它数字后，以刚刚选的数字为种子按照伪随机方式生成两个新数字。求至少几轮能让总分大于等于S。</p><p>可行性剪枝<br>设当前最多走maxd步，已经走了curd步，距离为cur，当前最远距离为curans，若<br><img src="https://cdn.acwing.com/media/article/image/2022/06/11/99310_de731288e9-1.png" alt="1.png"><br>则可以剪枝<br>然后这道题就做完了</p><h3 id="代码-26">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> LL P = <span class="hljs-number">4294967296</span>;<br><br>LL seed, s, maxd, curans, ans = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(LL cur, LL curd, LL a0)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cur &gt;= s) &#123;curans = <span class="hljs-built_in">max</span>(curans, cur); ans = <span class="hljs-built_in">min</span>(ans, curd) ; <span class="hljs-keyword">return</span> ;&#125;<br>    <span class="hljs-keyword">if</span> (cur + <span class="hljs-number">6</span> * (maxd - curd) &lt;= s) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (cur + <span class="hljs-number">6</span> * (maxd - curd) &lt;= curans) <span class="hljs-keyword">return</span> ;<br>    LL a1 = (<span class="hljs-number">213346089</span> * a0 + <span class="hljs-number">870413</span>) % P;<br>    LL a2 = (<span class="hljs-number">166042049</span> * a0 + <span class="hljs-number">598777</span>) % P;<br>    LL d1 = a1 % <span class="hljs-number">7</span>, d2 = a2 % <span class="hljs-number">7</span>;<br>   <span class="hljs-comment">// cout &lt;&lt; curd &lt;&lt; &quot;: &quot;  &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; &quot; &quot; &lt;&lt; d1 &lt;&lt; &quot; &quot; &lt;&lt; d2 &lt;&lt; endl; </span><br>    <span class="hljs-built_in">dfs</span>(cur + d1, curd + <span class="hljs-number">1</span>, a1);<br>    <span class="hljs-built_in">dfs</span>(cur + d2, curd + <span class="hljs-number">1</span>, a2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; seed &gt;&gt; s;<br>    maxd = s / <span class="hljs-number">6</span> + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (ans == <span class="hljs-number">0x3f3f3f3f</span>)<br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(seed % <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, seed);<br>        maxd ++ ;<br>    &#125;<br>    <br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="H题">H题</h2><h3 id="题意分析-25">题意分析</h3><p>对于一个串 s，定义 s 的某个子串的权值为其在原串的出现次数乘以该子串的长度。给定串 s， 求其所有回文子串的最大权值。</p><p>PAM 版题，在 PAM 上统计每个状态在原串的出现次数即可。<br>考虑构造 PAM 的过程中，每次新增一个字符，所有以当前字符结尾的回文串都是新增的回文子串，那么从当前状态不断跳 fail 指针，每次把 cnt 加一即可。<br>优化一下就是每次在当前状态打个标记，构造完了之后在 fail 树上向上传递即可。<br>复杂度 O(n)</p><h3 id="代码-27">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> lst = <span class="hljs-number">0</span>, id = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> fail[N], len[N], ne[N][<span class="hljs-number">27</span>], cnt[N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-type">int</span> n;<br>ll res;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>fail[<span class="hljs-number">0</span>] = fail[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>len[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_fail</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pos)</span></span>&#123;<br><span class="hljs-keyword">while</span> (pos - len[x] &lt;= <span class="hljs-number">0</span> || s[pos - len[x] - <span class="hljs-number">1</span>] != s[pos]) x = fail[x];<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">get_fail</span>(lst, pos), ch = s[pos] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (ne[u][ch] == <span class="hljs-number">0</span>)&#123;<br>id++;<br>len[id] = len[u] + <span class="hljs-number">2</span>;<br>fail[id] = ne[<span class="hljs-built_in">get_fail</span>(fail[u], pos)][ch];<br>ne[u][ch] = id;<br>&#125;<br>lst = ne[u][ch];<br>cnt[lst]++;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">max</span><span class="hljs-params">(ll a, ll b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;s[<span class="hljs-number">1</span>]);<br><br>n = <span class="hljs-built_in">strlen</span>(&amp;s[<span class="hljs-number">1</span>]);<br><br><span class="hljs-built_in">init</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )    <span class="hljs-built_in">insert</span>(i);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = id; i &gt;= <span class="hljs-number">0</span>; i -- )   cnt[fail[i]] += cnt[i];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= id; i ++ ) res = <span class="hljs-built_in">max</span>(res, (ll)cnt[i] * len[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Q题">Q题</h2><h3 id="题意分析-26">题意分析</h3><p>KMP板题<br>首先，什么是KMP算法。这是一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低（我不会算时间复杂度。。。，目前也只能这么理解，还有KMP是取的三个发明人的名字首字母组成的名字）。</p><p>​ 然后是一些基本概念：</p><p>1、s[ ]是模式串，即比较长的字符串。<br>2、p[ ]是模板串，即比较短的字符串。（这样可能不严谨。。。）<br>3、“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。<br>4、“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。（后面会有例子，均简称为前/后缀）<br>5、“部分匹配值”：前缀和后缀的最长共有元素的长度。<br>6、next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。（后面作详细讲解）。</p><p>核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。</p><h3 id="代码-28">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> s[N], p[N];<br><span class="hljs-type">int</span> ne[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; (s + <span class="hljs-number">1</span>) &gt;&gt; (p + <span class="hljs-number">1</span>);<br>    <br>    n = <span class="hljs-built_in">strlen</span>(p + <span class="hljs-number">1</span>);<br>    m = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        ne[i] = j;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        <span class="hljs-keyword">if</span> (j == n)<br>        &#123;<br>            res ++ ;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="R题">R题</h2><h3 id="题意分析-27">题意分析</h3><p>12个白马，12个黑马，一个空格，要求15步内走到目标状态，输出步数，否则输出-1。<br>棋牌类搜索经典trick：不枚举哪一匹马移动，而是枚举空格往哪个方向移动，这样可以在派生状态时减少无用的搜索。<br>如何判断当前状态是否为终状态：计算初状态与终状态有多少格子不同，每次派生状态时修改这个差值。若最终差值为0，说明已经到达终状态，而不用每次都比对所有格子。<br>假设我们举例搜索上限只剩n步，那么我们最多可以影响n+1个格子。如果当前状态与终状态的差异大于n+1，直接放弃搜索即可。<br>实际上，由于题目已经限制了最大搜索深度为15，是否使用迭代加深搜索对最坏时间复杂度无影响，也可以直接将搜索深度设为15。再次强调：关键是要利用**“被限制的搜索深度”**这一信息进行剪枝。</p><h3 id="代码-29">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> des[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] = &#123;&#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>    <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mve[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;&#125;;<br><br><span class="hljs-type">int</span> cnt, Dep, stx, sty;<br><span class="hljs-type">char</span> cur[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">H</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">4</span>; ++j)<br><span class="hljs-keyword">if</span>(cur[i][j] != des[i][j]) ++res;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">4</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt;= <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;step, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(step &gt; Dep)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">H</span>() == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">H</span>() + step - <span class="hljs-number">1</span> &gt; Dep) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">7</span>; ++i) <br>&#123;<br><span class="hljs-type">int</span> dx = x + mve[i][<span class="hljs-number">0</span>], dy = y + mve[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(dx, dy)) <br>&#123;<br><span class="hljs-built_in">swap</span>(cur[x][y], cur[dx][dy]);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(step + <span class="hljs-number">1</span>, dx, dy)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">swap</span>(cur[x][y], cur[dx][dy]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span>(T -- ) <br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, cur[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">4</span>; ++j)<br><span class="hljs-keyword">if</span>(cur[i][j] == <span class="hljs-string">&#x27;*&#x27;</span>) <br>&#123;<br>stx = i, sty= j;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(Dep = <span class="hljs-number">0</span>; Dep &lt;= <span class="hljs-number">15</span>; ++Dep) <br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, stx, sty)) <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(Dep &gt; <span class="hljs-number">15</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Dep);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="S题">S题</h2><h3 id="题意分析-28">题意分析</h3><p>注意到虽然一局内的走法最高就可达9!=362880种，但是可能出现的状态只有2×3^9=39366种，这是因为许多不同的走法能走向相同的状态，这样就产生了许多重复的搜索。</p><p>本题中，每个位置可能有三种状态：“空”，“O”，“X”。因此可以用一个9位三进制数唯一表示一种棋盘状态。<br>然而，三进制数并不适合用位运算处理，因此，可以考虑牺牲一定的空间，将状态用二进制表示。<br>例如，用两位二进制数表示一格的状态，“00”表示“空”，“01”表示“O”，“10”表示“X”，“11”无意义。这样就用18位的二进制数表示了一个唯一的棋盘状态。</p><p>检查某个位置是否为空，相当于检查x &amp; (3&lt;&lt;(2∗i))是否为0。<br>找到在某个位置上下一步棋后的状态，相当于x | (1 or 2&lt;&lt;(2∗i))。<br>不管是写法还是速度上都比用三进制表示优秀。</p><h3 id="代码-30">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">524300</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> x, sta, cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> k)</span> <span class="hljs-comment">// 找从k+1个位置开始的空位</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">9</span>; i ++ )<br>        <span class="hljs-keyword">if</span> (!(st &amp; (<span class="hljs-number">3</span> &lt;&lt; (<span class="hljs-number">2</span> * i)))) <br>            <span class="hljs-keyword">return</span> i;<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span><span class="hljs-comment">//计算答案</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = st &amp; <span class="hljs-number">3</span>;<br>        s[i / <span class="hljs-number">3</span>][i % <span class="hljs-number">3</span>] = t;<br>        st &gt;&gt;= <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i][<span class="hljs-number">0</span>] == s[i][<span class="hljs-number">1</span>] &amp;&amp; s[i][<span class="hljs-number">1</span>] == s[i][<span class="hljs-number">2</span>])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) res ++ ;<br>            <span class="hljs-keyword">else</span> res -- ;<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>][i] == s[<span class="hljs-number">1</span>][i] &amp;&amp; s[<span class="hljs-number">1</span>][i] == s[<span class="hljs-number">2</span>][i])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) res ++ ;<br>            <span class="hljs-keyword">else</span> res -- ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &amp;&amp; s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == s[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) res ++ ;<br>        <span class="hljs-keyword">else</span> res -- ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] == s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &amp;&amp; s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == s[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) res ++ ;<br>        <span class="hljs-keyword">else</span> res -- ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span><span class="hljs-comment">//debug</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = st &amp; <span class="hljs-number">3</span>;<br>        s[i / <span class="hljs-number">3</span>][i % <span class="hljs-number">3</span>] = t;<br>        st &gt;&gt;= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j ++ )<br>            cout &lt;&lt; s[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <br>        cout &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> op)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>)<br>    &#123;<br>        f[st] = <span class="hljs-built_in">count</span>(st);<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;f_st:&quot; &lt;&lt; f[st] &lt;&lt; endl;</span><br>        <span class="hljs-keyword">return</span> f[st];<br>    &#125;<br>    <span class="hljs-comment">//if (f[st] != -INF)  return f[st];//记忆化搜索</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">find</span>(st, t) != <span class="hljs-number">-1</span>)<br>    &#123;<br>        t = <span class="hljs-built_in">find</span>(st, t);<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;t:&quot; &lt;&lt; t &lt;&lt; endl;</span><br>        <span class="hljs-type">int</span> tmp = st;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) tmp = tmp | (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">2</span> * t));<span class="hljs-comment">//op为1，加入O即1</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>) tmp = tmp | (<span class="hljs-number">2</span> &lt;&lt; (<span class="hljs-number">2</span> * t));<span class="hljs-comment">//op为2，加入X即2</span><br>        <span class="hljs-comment">// cout &lt;&lt; &quot;cnt:&quot; &lt;&lt; cnt - 1&lt;&lt; endl;</span><br>        <span class="hljs-comment">// print(tmp);</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) f[st] = <span class="hljs-built_in">max</span>(f[st], <span class="hljs-built_in">dfs</span>(tmp, cnt - <span class="hljs-number">1</span>, op ^ <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">if</span> (f[st] == -INF) f[st] = <span class="hljs-built_in">dfs</span>(tmp, cnt - <span class="hljs-number">1</span>, op ^ <span class="hljs-number">1</span>);<br>            f[st] = <span class="hljs-built_in">min</span>(f[st], <span class="hljs-built_in">dfs</span>(tmp, cnt - <span class="hljs-number">1</span>, op ^ <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;f_tmp:&quot; &lt;&lt; f[tmp] &lt;&lt; endl;</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> f[st];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ ) f[i] = -INF;<br>    <br>    <span class="hljs-keyword">while</span> (T -- )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        sta = <span class="hljs-number">0</span>;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> s[<span class="hljs-number">10</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ )<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j ++ )<br>            &#123;<br>                <span class="hljs-type">int</span> t = <span class="hljs-number">3</span> * i + j;<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;.&#x27;</span>) cnt ++ ;<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;O&#x27;</span>) sta = sta | (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">2</span> * t));<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;X&#x27;</span>) sta = sta | (<span class="hljs-number">2</span> &lt;&lt; (<span class="hljs-number">2</span> * t));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// cout &lt;&lt; sta &lt;&lt; endl;</span><br>        <span class="hljs-comment">// count(sta);</span><br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">count</span>(sta));<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dfs</span>(sta, cnt, x));<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="V题">V题</h2><h3 id="题意分析-29">题意分析</h3><p>要做一个体积为Nπ的M层生日蛋糕</p><p>每层蛋糕的半径和高度递增，高度半径为整数</p><p>要求蛋糕的最小表面积</p><p><img src="https://cdn.acwing.com/media/article/image/2022/06/11/99310_5166ce80e9-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/11/99310_dc3773bbe9-2.png" alt="2.png"></p><p>优化搜索顺序</p><ol><li>层间：从下到上</li><li>层内：先枚举半径在枚举高度（半径的数量级更大），半径，高度由大到小</li></ol><p>$记总体积为n，当前层位u, 第u层的高度为H_u, 半径为R_u， 体积为V_u, 第m层到第u层体积的累计值V$</p><p>$对于R, 当前为第u层, 第u层的体积为 V_u。R最小的取值应该是当前的层号u ，$<br>$R的最大值应该由两部分决定u+1层的半径减1, 记R_u+1 −1$<br>剩下蛋糕体积$(n−v)π=πR^2H$(H最小取1)<br>这两者的最小值, 故有以下等式成立</p><p>$$u≤R≤min⁡(R_u+1−1,√n−v)$$</p><p>$对于H,同理， 当前为第u层, 第u层的体积为 V_u。H最小的取值应该是当前的层号u ，h的最大值应该由两部分决定<br>u+1层的高度减1, 记H_u+1 −1  $<br>$剩下蛋糕体积(n−v)π=πR^2H  $<br>$这两者的最小值, 故有以下等式成立  $<br>$u≤H≤min⁡(H_u+1−1,n−v/R^2) $</p><p>可行性剪枝 &amp; 最优性剪枝</p><p>我们预处理出 前u层的最小体积$$minV┬uminS┬u $$</p><p>$$v+minV_u≤n$$<br>$$S+minS_u&lt;ans$$<br><img src="https://cdn.acwing.com/media/article/image/2022/06/11/99310_de0aeacfe9-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/11/99310_e10989d8e9-4.png" alt="4.png"></p><h3 id="代码-31">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> minv[N], mins[N];<br><span class="hljs-type">int</span> R[N], H[N];<br><span class="hljs-type">int</span> ans = INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (v + minv[u] &gt; n) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (s + mins[u] &gt;= ans) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (s + <span class="hljs-number">2</span> * (n - v) / R[u + <span class="hljs-number">1</span>] &gt;= ans) <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-keyword">if</span> (!u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (v == n) ans = s;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-built_in">min</span>(R[u + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(n - v)); r &gt;= u; r -- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(H[u + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, (n - v) / r / r); h &gt;= u; h -- )<br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (u == m) t = r * r;<br>            H[u] = h, R[u] = r;<br>            <span class="hljs-built_in">dfs</span>(u - <span class="hljs-number">1</span>, v + r * r * h, s + <span class="hljs-number">2</span> * r * h + t);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>    &#123;<br>        minv[i] = minv[i - <span class="hljs-number">1</span>] + i * i * i;<br>        mins[i] = mins[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span> * i * i;<br>    &#125;<br>    <br>    R[m + <span class="hljs-number">1</span>] = H[m + <span class="hljs-number">1</span>] = INF;<br>    <br>    <span class="hljs-built_in">dfs</span>(m, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span> (ans == INF) ans = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="W题">W题</h2><h3 id="题意分析-30">题意分析</h3><p>字符串多串匹配</p><p>AC自动机板题<br>（AC自动机)<br>对于Trie图，其实最难理解的是它的Fail指针，也就是当前单词的后缀可以匹配的最长前缀，当然这里写的是ne数组，意思是一样的。<br>类似于下面的这张图示：<br><img src="https://cdn.acwing.com/media/article/image/2020/05/04/12161_36f00b208d-1.png" alt=""><br>考虑完这个问题之后，我们用题目中的例子画一张图理解一下：<br><img src="https://cdn.acwing.com/media/article/image/2020/05/04/12161_44b3aaa08d-2.png" alt=""><br>为什么可以这样呢，其实就是做了一个巧妙的转化，我们发现，要找所有单词中某个单词出现的次数，其实就是看在所有的前缀的后缀中某个单词出现的次数，这不就是ne数组的定义吗，问题也就解决了！<br>时间复杂度$O(n)$</p><h3 id="代码-32">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000101</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">200011</span>;<br><br><span class="hljs-type">int</span> n; <span class="hljs-type">char</span> s[N],t[M];<br><span class="hljs-type">int</span> tr[M][<span class="hljs-number">26</span>],fail[M],map[N],cnt = <span class="hljs-number">1</span>;<br><br>queue &lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-type">int</span> d[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++) tr[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) <br>    &#123;<br>        <span class="hljs-type">int</span> v = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++) <br>        &#123;<br>            <span class="hljs-type">int</span> &amp;u = tr[v][i];<br>            <span class="hljs-keyword">if</span>(!u) u = tr[fail[v]][i];<br>            <span class="hljs-keyword">else</span> fail[u] = tr[fail[v]][i], q.<span class="hljs-built_in">push</span>(u);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> f[M],adj[M],nxt[M],to[M],ec;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> u)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = ++ec; to[k] = u;<br>    nxt[k] = adj[v], adj[v] = k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = adj[v];i;i = nxt[i]) <br>    &#123;<br>        <span class="hljs-type">int</span> u = to[i];<br>        <span class="hljs-built_in">Dfs</span>(u), f[v] += f[u];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) <br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,t + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;t[j];j++) &#123;<br>            <span class="hljs-type">int</span> &amp;v = tr[k][t[j] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(!v) v = ++cnt, d[v] = d[k] + <span class="hljs-number">1</span>;<br>            k = v;<br>        &#125;<br>        map[i] = k;<br>    &#125;<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;s[i];i++)<br>    &#123;<br>        k = tr[k][s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        f[k]++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= cnt;i++) <span class="hljs-built_in">ins</span>(fail[i],i);<br>    <span class="hljs-built_in">Dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[map[i]]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="X题">X题</h2><h3 id="题意分析-31">题意分析</h3><p>给定一个字符串，求解在取到的前后缀没有公共部分的情况下，最长的前缀+后缀满足其为回文串的长度为多少</p><p>可以通过 Manacher 来优化上述过程，从而将时间复杂度降到 $O(n)$</p><p>下面我们来介绍下manacher算法</p><p>manacher算法是一种可以在O(N)时间复杂度下求字符串所有回文子串的算法，也是求最大回文子串最高效的算法。这种算法在进行遍历的时候，充分利用了回文串的特性，减少了许多不必要的计算，使得时间复杂度降低到了线性水平。该算法的难度在于理解，一旦理解后，代码是非常简单的。</p><p>manacher算法有如下几个要点：</p><ul><li>如何计算回文串长度$O(N)$</li><li>如何将奇回文串与偶回文串统一判断</li><li>如何优化$O(N^2)$时间复杂度的中心拓展算法</li></ul><p><strong>如何计算回文串长度</strong><br>如果没有时间上的限制，我们可以使用暴力的做法：中心拓展法</p><p>我们知道，如果一个字符串是回文串，那么该字符串必是中心对称的。故我们可以选择一个中心，从它开始，向两边逐一判断字符是否相同，拓展回文串长度。由于回文串可以是奇回文串也可以是偶回文串，我们需要选择一个字符或者选择两个字符中间作为中心进行逐一判断，故一共有 N + N - 1个中心。</p><p><strong>如何将奇回文串与偶回文串统一判断</strong><br>回文串既可以有aba的形式，也可以有abba的形式，在实际写代码的时候如果不进行处理，会使得代码变得比较复杂。<br>因此我们可以在每两个字符间及字符串头、尾加上一个不曾在字符串中出现过的字符，如#、$等字符，使得在进行遍历的时候可以不用分情况讨论</p><p>例如：<br><img src="https://img-blog.csdnimg.cn/2020081413144140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J3YnlibGFrZQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>则我们可以对所有字符做中心拓展，得回文半径Pi，则原字符串的子回文串长度为Pi - 1</p><p><strong>中心拓展算法的优化：manacher算法</strong><br>目前我们已经有了时间复杂度为$O(N^2)$的算法，如何优化呢。<br><img src="https://img-blog.csdnimg.cn/20200814132545241.png#pic_center" alt=""></p><p>不难发现，回文串的特点为中心对称，也就是说在回文串当中，围绕对称中心，左半边与右半边是完全相同的。故一个在左半边回文串内的子回文串，也必定存在于右半边，如该字符串<br>以b为对称中心，左边aba的子回文串在右边也出现了，那么我们可以思考一下，如果以从左到右的顺序进行中心拓展遍历，是不是可以通过已经计算过的回文半径来给当前还未计算的回文半径进行赋值？答案是显然的，但我们还需要考虑几种不同的情况。</p><p>我们知道上述理论成立的基础，是建立在回文串左右对称的前提下的，也就是说，我们如果想把过去计算过的回文半径拿来用，必然需要判断一下子回文串是否包含在大回文串之内，也就是如下三种情况：</p><p>1、当前中心在回文串的对称位置下的子回文串在回文串内<br>这是最简单的情况也是我们最希望看到的情况，因为我们可以直接使用已经计算过的回文半径来进行赋值<br><img src="https://img-blog.csdnimg.cn/20200814133823543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J3YnlibGFrZQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>如我们遍历到当前位置时（绿色箭头），可以通过已经计算过的对称位置子回文串对称中心（橙色箭头）得到当前回文半径，也就是1.</p><p>2、当前中心在回文串的对称位置下的子回文串超出了回文串的范围<br>如果对称位置下的子回文串并不完全被包含在回文串内，这种情况下不能直接将对称位置的回文半径赋值。但由于回文串的性质，我们可以保证包含在回文串内部的子串一定是回文串，则该种情况下当前位置的回文半径就是当前位置到回文串边缘的距离。<br><img src="https://img-blog.csdnimg.cn/20200814135620118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J3YnlibGFrZQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>当前我们计算到绿色箭头时，对称位置的Pi = 2，但当前位置距离最大回文串的边界只有1，则只能将其赋值为1。</p><p>3、当前中心已经不在回文串范围之内了<br>这种情况下，一切都是未知的，只能用中心拓展算法来进行计算，也就是将该中心初始化为1，并进行中心拓展算法</p><h3 id="代码-33">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e7</span> + <span class="hljs-number">6</span>;<br><br><span class="hljs-type">int</span> p[N],len;<br><span class="hljs-type">char</span> s[N],t[N];<span class="hljs-comment">//开两倍空间</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    len = <span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<br>    t[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;*&#x27;</span>;    <span class="hljs-comment">//特殊字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= len;i++)<br>    &#123;<br>        t[(i&lt;&lt;<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        t[(i&lt;&lt;<span class="hljs-number">1</span>)] = s[i];<br>    &#125;<br>    t[<span class="hljs-number">2</span>*len + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;t[<span class="hljs-number">2</span>*len+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;&amp;&#x27;</span>;<br>    len &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>,mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= len;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; mx) p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span>*id-i],mx-i);<br>        <span class="hljs-keyword">else</span>  p[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(t[i - p[i]] == t[i + p[i]]) p[i]++;<br>        <span class="hljs-keyword">if</span>(i + p[i] &gt; mx) &#123;<br>            mx = i + p[i];<br>            id = i;<br>        &#125;<br>    &#125;<br>    len &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tt;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">manacher</span>();<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = len + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>, ll, rr;<br>    <span class="hljs-keyword">while</span>(l &lt; len / <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span>(s[l + <span class="hljs-number">1</span>] == s[r - <span class="hljs-number">1</span>]) l ++ , r -- ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    len &lt;&lt;= <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> pl = (i - p[i] + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>,pr = (i + p[i] - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(pl &gt; l + <span class="hljs-number">1</span> &amp;&amp;  pr &lt; r - <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(l + <span class="hljs-number">1</span> - pl &gt;= pr - (r - <span class="hljs-number">1</span>)) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(mx &lt; <span class="hljs-number">2</span> * l + (i - l * <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>) mx = <span class="hljs-number">2</span> * l + (i - l * <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>,ll = l + <span class="hljs-number">1</span>,rr = ll + (i - l * <span class="hljs-number">2</span>) - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mx &lt; <span class="hljs-number">2</span> * l + (r * <span class="hljs-number">2</span> - i) - <span class="hljs-number">1</span>) mx = <span class="hljs-number">2</span> * l + (r * <span class="hljs-number">2</span> - i) - <span class="hljs-number">1</span>,rr = r - <span class="hljs-number">1</span>,ll = rr - (r * <span class="hljs-number">2</span> - i) + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>    len &gt;&gt;= <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-type">int</span> ans = (l + rr - ll  + len - r + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第356-367题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC356-367%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC356-367%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目356">题目356</h2><p>$已知 (\lim\limits_{x\to0}\dfrac{e^xf(x)+\sin x}{x^2} = 1)，求 (\lim\limits_{x\to 0} \dfrac{f(x) + \sin x}{x^2})$</p><h3 id="解答-114">解答</h3><p>像这种已知极限，反求抽象函数，最好的方法是 等式脱帽法，其次是 泰勒展开 配凑</p><p>$由 (\lim\limits_{x\to0}\dfrac{e^xf(x)+\sin x}{x^2} = 1 \quad\Rightarrow\quad \dfrac{e^xf(x)+\sin x}{x^2} = 1 + \alpha \quad) 其中 (\lim\limits_{x\to0} \alpha = 0)$</p><p>$[ e^xf(x)+\sin x = x^2 + o(x^2) \quad \Rightarrow \quad f(x) = \dfrac{x^2 - \sin x + o(x^2)}{e^x} ]$</p><p>代入所求极限：</p><p>$[ \lim\limits_{x\to 0} \dfrac{f(x) + \sin x}{x^2} = \lim\limits_{x\to 0} \dfrac{x^2 - \sin x + e^x\sin x}{e^xx^2} ]$</p><p>对于没有 抽象函数 在的极限，我们的手段就很多了，这里既可以 拆项 做，也可以 洛必达</p><p>$[ \lim\limits_{x\to 0} \dfrac{x^2 - \sin x + e^x\sin x}{x^2} = \lim\limits_{x\to 0} \dfrac{x^2}{x^2} + \lim\limits_{x\to 0} \dfrac{\sin x(e^x - 1)}{x^2} = 2 ]$</p><h2 id="题目357">题目357</h2><p>$[ \lim_{x\to0^+} \bigg( \dfrac{x}{(e^x-1)\cos\sqrt{x}} \bigg)^{\dfrac{1}{(1+\sin x^2)^{\frac{1}{x}}-1}} ]$</p><h3 id="解答-115">解答</h3><p>幂指函数求极限，先取指对数，然后单独处理指数部分</p><p>$[ \begin{aligned} &amp; \lim_{x\to0^+} \dfrac{\ln(\dfrac{x}{(e^x-1)\cos\sqrt{x}})}{(1+\sin x^2)^{\frac{1}{x}}-1} \\ =&amp; \lim_{x\to0^+} \dfrac{x - (e^x-1)\cos\sqrt{x}}{[(e^x-1)\cos\sqrt{x}](1+\sin x^2)^{\frac{1}{x}}-1} \\ =&amp; \lim_{x\to0^+} \dfrac{x - (e^x-1)\cos\sqrt{x}}{x^2} \end{aligned} ]$</p><p>分子是加减法，且在加号处直接拆开精度不够，可以考虑 加减交叉项，或考虑 泰勒展开</p><p>$[ (e^x - 1) \cdot \cos\sqrt{x} = [x + \dfrac{1}{2}x^2 + o(x^2)][1 - \dfrac{1}{2}x + \dfrac{1}{24}x^2 + o(x^2)] = x - \dfrac{1}{2}x^2+ \dfrac{1}{2}x^2 + o(x^2) ]$</p><p>故极限 $ = _{x0^+} = 0$</p><p>原极限 $ = e^0 = 1$</p><h2 id="题目358">题目358</h2><p>$设 (f(x)) 连续，且 (f(0) \ne 0)，则 (\lim\limits_{x\to 0} [1 + \displaystyle\int_0^x(x - t)f(t) dt]^{\dfrac{1}{x\int_0^xf(x - t)dt}})$</p><h3 id="解答-116">解答</h3><p>幂指函数先取指对数，然后单独处理指数部分</p><p>变上限积分函数求极限，考虑求导去积分符号</p><p>而被积函数中如果含有积分上限变量，优先考虑分离</p><p>$(\displaystyle\int_0^x(x - t)f(t) dt = x\displaystyle\int_0^xf(t) dt - \displaystyle\int_0^xtf(t) dt)$</p><p>$(\displaystyle x\int_0^xf(x - t)dt \xlongequal{\text{令}x-t=u}\displaystyle x\int_0^x f(u)du)$</p><p>$[ \begin{aligned} &amp; \lim\limits_{x\to 0} \dfrac{x\displaystyle\int_0^xf(t) dt - \displaystyle\int_0^xtf(t) dt}{x\displaystyle\int_0^xf(u)du} \\ \xlongequal{L’} &amp; \lim_{x\to 0} \dfrac{\displaystyle\int_0^xf(t) dt + xf(x) - xf(x)} {\displaystyle\int_0^xf(u)du + xf(x)} \\ = &amp; \lim_{x\to 0} \dfrac{\displaystyle\int_0^xf(t) dt} {\displaystyle\int_0^xf(t)dt + xf(x)} \\ = &amp; \lim_{x\to 0} \dfrac{xf(\xi)} {xf(\xi) + xf(x)} \\ = &amp; \lim_{x\to 0} \dfrac{f(\xi)} {f(\xi) + f(x)} \\ = &amp; \lim_{x\to 0} \dfrac{f(0)} {f(0) + f(0)} \\ =&amp; \dfrac{1}{2} \end{aligned} ]$</p><p>$倒数第四步用了 积分中值定理，然后又由于 (f(x)) 连续，且 (f(0) \ne 0) 故直接带入$</p><p>$故原极限 = (e^{\frac{1}{2}})$</p><h2 id="题目359">题目359</h2><p>$[ \lim_{x\to0}\dfrac{\displaystyle\int_0^{2x}|t - x|\sin t dt}{|x|^3} ]$</p><h3 id="解答-117">解答</h3><p>遇到绝对值，先考虑去绝对值，这里直接分类讨论即可</p><p>$[ \begin{aligned} \lim_{x\to0^+}\dfrac{\displaystyle\int_0^{2x}|t - x|\sin t dt}{|x|^3} &amp;= \lim_{x\to0^+}\dfrac{\displaystyle\int_0^{2x}|t - x|t dt}{|x|^3} \\ &amp;= \lim_{x\to0^+}\dfrac{\displaystyle\int_0^{x}(xt - t^2) dt + \int_x^{2x}(t^2 - xt) dt}{x^3} \end{aligned} ]$</p><p>写到这一步，就不用考虑用洛必达去积分符号了，可以考虑直接把积分解出来</p><p>$[ \lim_{x\to0^+}\dfrac {(\dfrac{1}{2}xt^2 - \dfrac{1}{3}t^3)\bigg|_0^x + (\dfrac{1}{3}t^3 - \dfrac{1}{2}xt)\bigg|_x^{2x}}{x^3} = 1 ]$</p><p>然后不难发现，分母从头到尾都没动过，故其实是不用分类讨论的，可以直接得出：</p><p>$[ \lim_{x\to0}\dfrac{\displaystyle\int_0^{2x}|t - x|\sin t dt}{|x|^3} = 1 ]$</p><h2 id="题目360">题目360</h2><p>$[ \lim_{x\to0}\dfrac{e^{(1+x)^{\frac{1}{x}}} - (1 + x)^{\frac{e}{x}}}{x^2} ]$</p><h3 id="解答-118">解答</h3><p>$[ \begin{aligned} &amp; \lim_{x\to0}\dfrac{e^{(1+x)^{\frac{1}{x}}} - (1 + x)^{\frac{e}{x}}}{x^2} \\ =&amp; \lim_{x\to0}\dfrac{e^{(1+x)^{\frac{1}{x}}} - e^{\frac{e\ln(1 + x)}{x}}}{x^2} \\ =&amp; e^e \cdot \lim_{x\to0}\dfrac{e^{e^{\frac{\ln(1 + x)}{x}} - \frac{e\ln(1 + x)}{x}} - 1}{x^2} \\ =&amp; e^{e + 1} \cdot \lim_{x\to0}\dfrac{e^{\frac{\ln(1 + x) - x}{x}} - \frac{\ln(1 + x)}{x}}{x^2} \\ =&amp; e^{e + 1} \cdot \lim_{x\to0}\dfrac{e^{\frac{\ln(1 + x) - x}{x}} - 1 - \frac{\ln(1 + x) - x}{x}}{x^2} \\ \end{aligned} ]$</p><p>$[ e^{\frac{\ln(1 + x) - x}{x}} - 1 \sim \frac{\ln(1 + x) - x}{x} \sim -\dfrac{1}{2}x ]$</p><p>$[ e^x - 1 - x \sim \frac{1}{2} x^2 ]$</p><p>$[ e^{\frac{\ln(1 + x) - x}{x}} - 1 - \frac{\ln(1 + x) - x}{x} \sim \frac{1}{2} \cdot \frac{1}{4} \cdot x^2 = \dfrac{1}{8}x^2 ]$</p><p>故原式 $ = e^{e + 1} _{x0} = e^{e + 1}$</p><h2 id="题目361">题目361</h2><p>$[ \lim_{n\to\infty}\sum_{k=1}^n(1-\dfrac{k}{n})\ln(1+\dfrac{k}{n^2}) ]$</p><h3 id="解答-119">解答</h3><p>无限项的合式极限，考研范围内只需要掌握的两种方法：</p><p>放缩夹逼<br>定积分定义<br>本题形式很像是 定积分定义，但是怎么都凑不出想要的形式</p><p>$这时又看见了 (\ln(1 + x)) 的因式，故想到一个常见不等式 (\dfrac{x}{x+1}&lt;\ln(1 + x) &lt; x)$</p><p>$[ \begin{aligned} \frac{\dfrac{k}{n^2}}{\dfrac{k}{n^2} + 1} \lt &amp;\ln(1+\dfrac{k}{n^2}) \lt \dfrac{k}{n^2} \\ \frac{k}{n^2 + k} \lt &amp;\ln(1+\dfrac{k}{n^2}) \lt \dfrac{k}{n^2} \\ (1 - \dfrac{k}{n}) \cdot \frac{k}{n^2 + k} &lt; &amp;(1-\dfrac{k}{n})\ln(1+\dfrac{k}{n^2}) &lt; (1 - \dfrac{k}{n}) \cdot \dfrac{k}{n^2} \\ \dfrac{k}{n^2 + k} - \dfrac{k^2}{n^3 + nk} &lt; &amp;(1-\dfrac{k}{n})\ln(1+\dfrac{k}{n^2}) &lt; \dfrac{k}{n^2} - \dfrac{k^2}{n^3} \end{aligned} ]$</p><p>右侧可以用定积分定义，左边放缩分母继续夹逼</p><p>右侧：</p><p>$[ \lim_{n\to\infty}\sum_{k=1}^n(\dfrac{k}{n^2} - \dfrac{k^2}{n^3}) = \lim_{n\to\infty}\frac{1}{n}\sum_{k=1}^n (\dfrac{k}{n} - \dfrac{k^2}{n^2}) = \int_0^1 (x - x^2)dx = \dfrac{1}{6} ]$</p><p>左侧：</p><p>$[ \begin{aligned} \frac{k}{n^2 + n} &lt; &amp;\frac{k}{n^2 + k} &lt; \frac{k}{n^2} \\ \sum_{k=1}^n\frac{k}{n^2 + n} &lt; &amp;\sum_{k=1}^n\frac{k}{n^2 + k} &lt; \sum_{k=1}^n\frac{k}{n^2} \\ \frac{\dfrac{n(n+1)}{2}}{n^2 + n} &lt; &amp;\sum_{k=1}^n\frac{k}{n^2 + k} &lt; \frac{\dfrac{n(n+1)}{2}}{n^2} \\ \dfrac{1}{2} &lt; &amp;\lim_{n\to\infty}\sum_{k=1}^n\frac{k}{n^2 + k} &lt; \dfrac{1}{2} \\ \end{aligned} ]$</p><p>同理：</p><p>$[ \begin{aligned} \dfrac{k^2}{n^3 + n^2} &lt; &amp;\dfrac{k^2}{n^3 + nk} &lt; \dfrac{k^2}{n^3} \\ \sum_{k=1}^n\dfrac{k^2}{n^3 + n^2} &lt; &amp;\sum_{k=1}^n\dfrac{k^2}{n^3 + nk} &lt; \sum_{k=1}^n\dfrac{k^2}{n^3} \\ \dfrac{\dfrac{n(n+1)(2n+1)}{6}}{n^3 + n^2} &lt; &amp;\sum_{k=1}^n\dfrac{k^2}{n^3 + nk} &lt; \dfrac{\dfrac{n(n+1)(2n+1)}{6}}{n^3} \\ \dfrac{1}{3} &lt; &amp;\lim_{n\to\infty}\sum_{k=1}^n\dfrac{k^2}{n^3 + nk} &lt; \dfrac{1}{3} \\ \end{aligned} ]$</p><p>$故：(\lim\limits_{n\to\infty}(\dfrac{k}{n^2 + k} - \dfrac{k^2}{n^3 + nk}) = \dfrac{1}{6})$</p><p>于是有：</p><p>$[ \dfrac{1}{6} &lt; \lim\limits_{n\to\infty}(1-\dfrac{k}{n})\ln(1+\dfrac{k}{n^2}) &lt; \dfrac{1}{6} ]$</p><p>$由夹逼准则可得：(\lim\limits_{n\to\infty}(1-\dfrac{k}{n})\ln(1+\dfrac{k}{n^2}) = \dfrac{1}{6})$</p><h2 id="题目362">题目362</h2><p>$[ \lim_{n\to\infty}[\dfrac{n}{n^2 + n + \ln 1} + \dfrac{n}{n^2 + n + \ln 2} + \cdots + \dfrac{n}{n^2 + n + \ln n}]^n ]<br>$</p><h3 id="解答-120">解答</h3><p>幂指函数化成指对数，单独处理指数部分：</p><p>$[ A = \lim_{n\to\infty} n\ln [\dfrac{n}{n^2 + n + \ln 1} + \dfrac{n}{n^2 + n + \ln 2} + \cdots + \dfrac{n}{n^2 + n + \ln n}] ]$</p><p>无穷项合式极限，考虑放缩：</p><p>$[ \begin{aligned} \sum_{k=1}^n \dfrac{n}{n^2 + n + \ln n} \le &amp; \sum_{k=1}^n \dfrac{n}{n^2 + n + \ln k} \le \sum_{k=1}^n \dfrac{n}{n^2 + n} \\ \dfrac{n^2}{n^2 + n + \ln n} \le &amp; \sum_{k=1}^n \dfrac{n}{n^2 + n + \ln k} \le \dfrac{n^2}{n^2 + n} \\ \end{aligned} ]$</p><p>求出左侧极限：</p><p>$[ \lim_{n\to\infty} n\ln \dfrac{n^2}{n^2 + n + \ln n} = \lim_{n\to\infty} \dfrac{- n^2 - n\ln n}{n^2 + n + \ln n} = -1 ]$</p><p>求出右侧极限：</p><p>$[ \lim_{n\to\infty} n\ln \dfrac{n^2}{n^2 + n} = \lim_{n\to\infty} \dfrac{- n^2}{n^2 + n} = -1 ]$</p><p>由夹逼准则可得：</p><p>$[ \lim_{n\to\infty} \sum_{k=1}^n \dfrac{n}{n^2 + n + \ln k} = -1 ]$</p><p>故原极限：</p><p>$[ \lim_{n\to\infty}[\dfrac{n}{n^2 + n + \ln 1} + \dfrac{n}{n^2 + n + \ln 2} + \cdots + \dfrac{n}{n^2 + n + \ln n}]^n = e^{-1} ]$</p><h2 id="题目363">题目363</h2><p>$[ \lim_{n\to\infty} [\sum_{k=1}^n \dfrac{1}{\sqrt{n^2 + k^2}}]^n ]$</p><h3 id="解答-121">解答</h3><p>幂指函数化成指对数，单独处理指数部分：</p><p>$[ A = \lim_{n\to\infty} n \ln \sum_{k=1}^n \dfrac{1}{\sqrt{n^2 + k^2}} ]$</p><p>$单独观察对数部分，由于 (k) 与 (n) 是同一个数量级的 (o(n^2))，故考虑定积分定义$</p><p>$[ \lim_{n\to\infty}\sum_{k=1}^n \dfrac{1}{\sqrt{n^2 + k^2}} = \lim_{n\to\infty} \dfrac{1}{n} \sum_{k=1}^n \dfrac{1}{\sqrt{1 + \dfrac{k^2}{n^2}}} = \int_0^1 \dfrac{1}{\sqrt{x^2 + 1}}dx = \ln(1+\sqrt{2}) ]$</p><p>由于该结果是非零因式，直接代入指数的极限中：</p><p>$[ A = \lim_{n\to\infty} n \ln \sum_{k=1}^n \dfrac{1}{\sqrt{n^2 + k^2}} = \ln\ln(1+\sqrt{2}) \cdot \lim_{n\to\infty} n ]$</p><p>$由于 (1 &lt; 1 + \sqrt{2} &lt; e)，故 (\ln(1 + \sqrt{2}) &lt; 1)，因此 (\ln\ln(1+\sqrt{2}) &lt; 0)$</p><p>$由此可知：(A = - \infty)$</p><p>$故原极限为：(e^A = 0)$</p><h2 id="题目364">题目364</h2><p>下列结论中正确的是</p><p>$（A）若 (\lim\limits_{n\to\infty}x_n = 0)，且 (\lim\limits_{n\to\infty} f(x_n) = A)，则 (\lim\limits_{x\to0}f(x) = A)$</p><p>$（B）若 (\lim\limits_{n\to\infty}x_n = 0)，且 (\lim\limits_{x\to0} f(x) = A)，则 (\lim\limits_{n\to\infty} f(x_n) = A)$</p><p>$（C）若 (\lim\limits_{n\to\infty}f(n) = A)，则 (\lim\limits_{x\to+\infty}f(x) = A)$</p><p>$（D）若 (\lim\limits_{x\to+\infty}f(x) = A)，则 (\lim\limits_{n\to\infty}f(n) = A)$</p><h3 id="解答-122">解答</h3><p>（A）选项</p><p>$显然不对，我们直接构造分段函数 (f(x) = \begin{cases} A &amp; x\in x_n \\ 1 &amp; x\not\in x_n \end{cases})$</p><p>$则 (\lim\limits_{n\to\infty} = f(x_n) = A)，且 (\lim\limits_{x\to0}f(x) \not \exists)$</p><p>（B）选项</p><p>$错误，(\lim\limits_{x\to0} f(x) = A) 说的是去心邻域情况，故我们可以挖空 (f(x)) 在 (x = 0) 处的定义$</p><p>$然后令 (x_n \equiv 0)，则 (f(x_n) = f(0)) 显然无意义$</p><p>$如果这题限制 (f(x)) 必须在 (x=0) 邻域内有定义，则可以让 (x=0) 为可去间断点$</p><p>（C）选项</p><p>$显然不对，构造分段函数 (f(x) = \begin{cases} A &amp; x \in \mathbf{N} \\ x &amp; x\not\in \mathbf{N} \end{cases})$</p><p>（D）选项</p><p>$显然正确，海涅准则：收敛函数 (\Leftrightarrow) 任意子列都收敛$</p><h2 id="题目365">题目365</h2><p>$设数列 {(x_n)}，已知 (\lim\limits_{n\to\infty}(x_{n+1} - x_n) = 0)，则下列结论正确的是（ ）</p><p>（A）{(x_n)} 必收敛；</p><p>（B）若 {(x_n)} 单调，则 {(x_n)} 必收敛；</p><p>（C）若 {(x_n)} 有界，则 {(x_n)} 必收敛；</p><p>（D）若 {(x_{3n})} 收敛，则 {(x_n)} 必收敛；<br>$</p><h3 id="解答-123">解答</h3><p>（A）选项</p><p>$显然错，(\lim\limits_{n\to\infty}(x_{n+1} - x_n) = 0)，可能是 “(\infty - \infty)” 型$</p><p>$例如：(x_n = \sqrt{n})，(\lim\limits_{n\to\infty}(x_{n+1} - x_n) = \lim\limits_{n\to\infty} \sqrt{n + 1} - \sqrt{n} = \lim\limits_{n\to\infty} \dfrac{1}{\sqrt{n + 1} + \sqrt{n}} = 0)$</p><p>（B）选项</p><p>$显然错，反例：(x_n = \sqrt{n})$</p><p>（C）选项</p><p>$错误，反例：(\sin\sqrt{n})$</p><p>$(\lim\limits_{n\to\infty}(x_{n+1} - x_n) \rightarrow \lim\limits_{x\to+\infty}(\sin\sqrt{x + 1} - \sin\sqrt{x}) = -\lim\limits_{x\to+\infty}\cos\sqrt{\xi} \cdot \dfrac{1}{2\sqrt{\xi}} = 0)$</p><p>（D）选项</p><p>$正确，(\lim\limits_{n\to\infty}x_{3n} \xlongequal[\text{令}]{\text{存在}} A)，则 (\lim\limits_{n\to\infty}(x_{3n+1} - x_{3n}) = \lim\limits_{n\to\infty}x_{3n+1} - \lim\limits_{n\to\infty}x_{3n} = 0) (\Rightarrow) (\lim\limits_{n\to\infty}x_{3n+1} = A)$</p><p>$同理 (\lim\limits_{n\to\infty}x_{3n+2} = A)，则所有子列都收敛到同一个值 (\Rightarrow) 原数列也收敛该值$</p><h2 id="题目366">题目366</h2><p>$设 (f(x)) 有连续一阶导数，且 (0 &lt; f’(x) \le \dfrac{\ln(2 + x^2)}{2(1+x^2)})$</p><p>$数列 (x_0 = a, x_n = f(x_{n-1}), n = 1, 2, \cdots).$</p><p>$证明：极限 (\lim\limits_{n\to\infty} x_n) 存在且是方程 (f(x) = x) 的唯一实根.$</p><h3 id="解答-124">解答</h3><p>（逆用牛顿莱布尼茨公式）<br>$由于 (f’(x) &gt; 0)，则数列 {(x_n)} 单调，又$</p><p>$[ \begin{aligned} |x_n| &amp;= |f(x_{n-1})| = |f(x_0) + f(x_{n-1}) - f(x_0)| = |f(x_0) + \displaystyle\int_{x_0}^{x_{n-1}}f’(x)dx| \\ &amp; \le |f(x_0)| + |\displaystyle\int_{x_0}^{x_{n-1}}f’(x)dx| \le |f(x_0)| + |\displaystyle\int_{x_0}^{x_{n-1}}\dfrac{\ln(2 + x^2)}{2(1+x^2)}dx| \\ &amp; \le |f(x_0)| + |\displaystyle\int_{-\infty}^{+\infty}\dfrac{\ln(2 + x^2)}{2(1+x^2)}dx| \end{aligned} ]$</p><p>$易知 (\displaystyle\int_{-\infty}^{+\infty}\dfrac{\ln(2 + x^2)}{2(1+x^2)}dx) 收敛（比较在广义瑕点的阶）$</p><p>$由单调有界准则：{(x_n)} 收敛，故 (\lim\limits_{n\to\infty} x_n) 存在$</p><p>$令 (\lim\limits_{n\to\infty} x_n = A)，则有 (A = f(A))，故 (x = A) 是 (f(x) = x) 的一个解$</p><p>$于是 (f(x) = x) 至少有一个解，现证明至多有一个解$</p><p>$令 (F(x) = f(x) - x)，则 (0 &lt; F’(x) = f’(x) - 1 \le \dfrac{\ln(2 + x^2)}{2(1+x^2)} &lt; 1)，故 (F(x)) 单调递增$</p><p>$所以 (F(x)) 至多有一解，综上 (x = A) 为 (f(x) = x) 的唯一解$</p><h2 id="题目367">题目367</h2><p>$设 (p(x) = a + bx + cx^2 + dx^3)，且当 (x\to 0) 时，$</p><p>$(p(x) - \ln(x + \sqrt{1 + x^2})) 是比 (x^3) 高阶的无穷小，则（ ）$</p><p>$（A）(a = 1) （B）(b = 2)$<br>$（C）(c = 3) （D）(d = -\frac{1}{6})$</p><h3 id="解答-125">解答</h3><p>$常用展开：(\ln(x+\sqrt{1+x^2}) = x - \dfrac{1}{6}x^3 + o(x^3))$</p><p>正常做，直接用抽象泰勒展开即可</p><p>但是这题是选择题，应该用选择题的技巧</p><p>$首先 (\ln(x + \sqrt{1 + x^2})) 是奇函数，故 (c = 0)$</p><p>$又 (\ln(x + \sqrt{1 + x^2}) \sim x) ，故 (a = 0, b = 1)$</p><p>A、B、C 全部划掉，这题选 （D）</p><h2 id="加餐题目367">加餐题目367</h2><p>$设 (f(x) = x + a\ln(a + x) + \dfrac{bx\sin x}{1+x^2}, g(x) = kx^3)$</p><p>$若 (f(x)) 与 (f(x)) 在 (x\to 0) 时是等价无穷小，求参数.$</p><h3 id="解答-126">解答</h3><p>泰勒展开：</p><p>$[ a\ln(1 + x) = ax - \dfrac{a}{2}x^2 + \dfrac{a}{3}x^3 + o(x^3) ]$</p><p>$[ \dfrac{1}{1 + x^2} = 1 - x^2 + x^4 + o(x^4) ]$</p><p>$[ x\sin x = x^2 - \dfrac{1}{6}x^4 + o(x^4) ]$</p><p>$[ \dfrac{bx\sin x}{1+x^2} = bx^2 + o(x^3) ]$</p><p>$[ f(x) = x + ax - \dfrac{a}{2}x^2 + \dfrac{a}{3}x^3+ bx^2 + o(x^3) = (1 + a)x + (b - \dfrac{a}{2})x^2 + \dfrac{a}{3}x^3 + o(x^3) ]$</p><p>$故 (a = -1, b = -\dfrac{1}{2}, k = -\dfrac{1}{3})$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第336-338题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC336-338%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC336-338%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目336">题目336</h2><p>$设函数 (f(x)) 二阶可导，且 (f’(x) = f(1-x),f(0) = 1)，求 (f(x))$</p><h3 id="解答-111">解答</h3><p>$换元：(f’(1-x) = f(x) \quad \Rightarrow \quad f’(1) = f(0) = 1)$</p><p>$再求导：(f’‘(x) = -f’(1 - x))$</p><p>$联立两式：(f’'(x) + f(x) = 0) 为 二阶常系数齐次微分方程$</p><p>$特征根：(\lambda^2 + 1 = 0 \quad\Rightarrow\quad \lambda = 0 \pm i)$</p><p>$齐次通解：(y = C_1\cos x + C_2 \sin x \quad \Rightarrow \quad y’ = C_2\cos x - C_1\sin x)$</p><p>$代入初值：(y(0) = C_1 = 1), (y’(1) = C_2\cos 1 - \sin 1 = 1 \quad \Rightarrow \quad C_2 = \dfrac{1 + \sin 1}{\cos 1})$</p><p>$综上所述：(f(x) = \cos x + \dfrac{1 + \sin 1}{\cos 1} \cdot \sin x)$</p><h2 id="题目337">题目337</h2><p>$设函数 (f(x)) 可导，且对任意实数 (x,h) 满足 (f(x+h) = \int_x^{x+h}t[f(t+h)+t^2]dt + f(x))$</p><p>$(\lim\limits_{x\to0}[1+f(x)]^{\frac{1}{x^4}} = a) ，求 (f(x)) 的表达式及常数 (a)$</p><h3 id="解答-112">解答</h3><p>$求 (f(x)) 的表达式，考虑微分方程；题目又给了 (f(x+h)) 的表达式，考虑导数定义来构造方程$</p><p>$[ f’(x) = \lim_{h\to0}\frac{f(x + h) - f(x)}{h} = \lim_{h\to0}\frac{\int_x^{x+h} t[f(t+h)+t^2]dt }{h} = xf(x)+x^3 ]$</p><p>$得到微分方程：(y’ - xy = x^3) 为 一阶线性微分方程$</p><p>$[ y = e^{\int xdx} \cdot \Big[ \int x^3 e^{\int-xdx} dx + C_1 \Big] = -e^{\frac{1}{2}x^2} \cdot (x^2 e^{-\frac{1}{2}x^2} + 2e^{-\frac{1}{2}x^2} + C_2) = -x^2 - 2 + Ce^{\frac{1}{2}x^2} ]$</p><p>$下面这一步是错的，事实上 (f(x) = -0.5 \Rightarrow a = 0.5^{+\infty} = 0) 极限也是存在的 这题就是错题，需要额外添加条件 (a &gt; 0) 且 (a \ne 1)$</p><p>$又 (\lim\limits_{x\to0}[1+f(x)]^{\frac{1}{x^4}} = a) 存在，故 (f(0) = 0 \quad\Rightarrow\quad C = 2 \quad\Rightarrow\quad y = -x^2 - 2 + 2e^{\frac{1}{2}x^2})$</p><p>$[ \begin{aligned} &amp; \lim_{x\to0}[1+f(x)]^{\frac{1}{x^4}} \\ = &amp; \lim_{x\to0} (-x^2 - 1 + 2e^{\frac{1}{2}x^2})^{\frac{1}{x^4}} \\ = &amp; \exp[ \lim_{x\to0}\frac{-x^2-2+2e^{\frac{1}{2}x^2}}{x^4} ] \\\ = &amp; \exp[ \lim_{x\to0}\frac{\dfrac{1}{4}x^4 + o(x^4)}{x^4} ] \\\ = &amp; \exp[ \frac{1}{4} ] \\\ \end{aligned} ]$</p><p>$故 (a = e^\frac{1}{4})$</p><h2 id="题目338">题目338</h2><p>$设 (f(x)) 为 ([0,+\infty)) 上的正值连续函数，已知曲线 (y=\int_0^x f(u)du) 和 (x) 轴$</p><p>$及直线 (x=t(t&gt;0)) 所围区域绕 (y) 轴旋转所得体积与曲线 (y=f(x)) 和两坐$</p><p>$标轴及直线 (x=t(t&gt;0)) 所围区域的面积之和为 (t^2)，求曲线 (y = f(x)) 方程$</p><h3 id="解答-113">解答</h3><p>微分方程的几何应用，按照题目要求，列出式子，最后建立方程求解即可</p><p>$[ V = 2\pi\iint\limits_{D_1}xd\sigma = 2\pi\int_0^tdx\int_0^{\int_0^xf(u)du} xdy = 2\pi\int_0^tx\int_0^xf(u)dudx ]$</p><p>$[ S = \int_0^t f(u)du ]$</p><p>$[ t^2 = V + S \quad\Rightarrow\quad 2\pi\int_0^tx\int_0^xf(u)dudx + \int_0^t f(u)du = t^2 ]$</p><p>$该式对两侧求导，然后令变上限积分函数 (g(x) = \int_0^x f(u)du)，则 (g(0) = 0)$</p><p>$[ 2\pi t\int_0^t f(u)du + f(t) = 2t \quad\Rightarrow\quad y’ + 2\pi xy = 2x ]$</p><p>此为 变量可分离型 微分方程：</p><p>$[ \frac{dy}{\pi y - 1} = -2xdx \quad\Rightarrow\quad \ln(\pi y - 1) = - \pi x^2 + C_1 \quad\Rightarrow\quad y = \frac{1}{\pi} (Ce^{-\pi x^2} + 1) ]$</p><p>代入初值：$y(0) = (C + 1) = 0 C = -1 y = (1 - e{-x2}) $</p><p>$两侧对 (x) 求导，便可得出最终答案：$</p><p>$   [ f(x) = 2xe^{-\pi x^2} ]$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第320-335题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC320-335%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC320-335%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目320">题目320</h2><p>$[ 设 f(x) 有连续一阶偏导数，(xy-yf(x))dx + (f(x) + y^2)dy = du(x,y) ]$</p><p>$[ 且 f(0) = -1，求 u(x,y) ]$</p><h3 id="解答-79">解答</h3><p>本题考查的是 多元函数的全微分 ：</p><p>$[ dz = \frac{\partial z}{\partial x} dx + \frac{\partial z}{\partial y} dy ]$</p><p>故：</p><p>$[ \frac{\partial u}{\partial x} = xy-yf(x)\qquad \frac{\partial u}{\partial y} = f(x) + y^2 ]$</p><p>求二阶偏导：</p><p>$[ \frac{\partial^2 u}{\partial x\partial y} = x - f(x) \qquad \frac{\partial^2 u}{\partial y\partial x} = f’(x) ]$</p><p>$由于一阶偏导数 连续，所以 (\dfrac{\partial^2 u}{\partial x\partial y} = \dfrac{\partial^2 u}{\partial y\partial x})$</p><p>$故建立 微分方程：(x - f(x) = f’(x) \Rightarrow f’ + f = x) 是 常系数一阶齐次线性微分方程$</p><p>由公式可知：</p><p>$[ f(x) = e^{-\int 1 dx} \cdot [\int x e ^{\int 1 dx} + C] = x - 1 + Ce^{-x} ]$</p><p>代入 初值：$ -1 = f(0) = -1 + C C = 0 f(x) = x - 1$</p><p>$则：(\dfrac{\partial u}{\partial x} = y \Rightarrow u = xy + \varphi(y))，(u_y = x + \varphi’(y)= x + y^2 - 1 \Rightarrow \varphi(y) = \dfrac{1}{3} y^3 - y + C)$</p><p>$故 (u(x,y) = xy + \dfrac{1}{3}y^3 - y + C)，其中 (C) 为任意常数$</p><p>解答<br>已知 全微分具体形式，求原函数：</p><p>偏积分（见法一）<br>凑微分（见本篇）<br>$又上题求出 (f(x) = x - 1) 继续：$</p><p>$[ \begin{aligned} du&amp;= ydx + (x + y ^2 - 1)dy \\ du&amp;= ydx + (x-1)dy + d\frac{1}{3}y^3 \\ du&amp;= yd(x - 1) + (x - 1)dy + d\frac{1}{3}y^3 \quad(这一步凑乘积的求导公式，我只能说妙！)\\ du&amp;= d(y(x - 1)) + d\frac{1}{3}y^3 \\ du&amp;= d(xy - y + \frac{1}{3}y^3) \\ u(x,y)&amp;= xy - y + \frac{1}{3}y^3 + C \end{aligned} ]$</p><h2 id="题目321">题目321</h2><p>$[ 设 f_x(x,y) 和 f_y(x,y) 都在点 (x_0,y_0) 处连续，证明 f(x,y) 在点 (x_0,y_0) 可微 ]$</p><h3 id="解答-80">解答</h3><p>$书本定理证明： [ 一阶偏导数连续 \Rightarrow 可微 ]$</p><p>先写出微分定义式，即我们要证明的目标</p><p>$(微分的定义式：\Delta z = f_x(x_0,y_0)\Delta x + f_y(x_0,y_0)\Delta y + o(\rho))$</p><p>在写出微分的增量式</p><p>$(\begin{aligned} 微分的全增量： \Delta z &amp;= f(x_0+\Delta x,y_0+\Delta y) - f(x_0,y_0) \\ &amp;= f(x_0+\Delta x,y_0+\Delta y) - f(x_0,y_0 + \Delta y) + f(x_0,y_0 + \Delta y) - f(x_0,y_0) \end{aligned})$</p><p>$由 拉格朗日中值定理 的 增量式：(\exist \theta \in (0,1),s.t.) [ f(x_0 + \Delta x, y_0 + \Delta y) - f(x_0,y_0 + \Delta y) = f_x(x_0 + \theta\Delta x,y_0 + \Delta y)\Delta x ]$</p><p>$又 (f_x(x,y)) 在 ((x_0,y_0)) 连续，故 (\lim\limits_{(\Delta x,\Delta y) \to (0,0)} f_x(x_0 + \theta\Delta x,y_0 + \Delta y) = f_x(x_0,y_0))$</p><p>回代可得： $ f(x_0 + x, y_0 + y) - f(x_0,y_0 + y) = f_x(x_0,y_0)x + _1x$</p><p>同理可证： $ f(x_0, y_0 + y) - f(x_0,y_0) = f_y(x_0,y_0)y + _2y$</p><p>合并两式： $ z = f_x(x_0,y_0)x + f_y(x_0,y_0)y + _1x + _2y $</p><p>$比较 定义式 和 化简后的增量式，发现唯一的区别是 (o(\rho)) 和 (\alpha_1\Delta x + \alpha_2\Delta y)$</p><p>要想证明他们 等价，考虑 不等式放缩夹逼：</p><p>$[ 0 \le \frac{|\alpha_1\Delta x + \alpha_2\Delta y|}{\sqrt{(\Delta x)^2 + (\Delta y)^2}} \le \frac{|\alpha_1||\Delta x| + |\alpha_2||\Delta y|}{\sqrt{(\Delta x)^2 + (\Delta y)^2}} \le |\alpha_1| + |\alpha_2| ]$</p><p>$故 (\frac{|\alpha_1\Delta x + \alpha_2\Delta y|}{\sqrt{(\Delta x)^2 + (\Delta y)^2}} \to 0 \Rightarrow \alpha_1\Delta x + \alpha_2\Delta y = o(\rho))$</p><p>$故增量式 (\Delta z = f_x(x_0,y_0)\Delta x + f_y(x_0,y_0)\Delta y + o(\rho))$</p><p>满足微分定义式，故可微</p><h2 id="题目322">题目322</h2><p>$设函数 (z = z(x,y)) 由方程 (e^{x+2y+3z} + \dfrac{xyz}{\sqrt{1+x^2+y^2+z^2}} = 1) 确定，求 (dz\bigg|_{(0,0)})$</p><h3 id="解答-81">解答</h3><p>解法一<br>$隐函数求全微分，有两种常用做法：隐函数直接求导套公式 (\dfrac{\partial z}{\partial x} = - \dfrac{F_x}{F_z})、求偏导凑$</p><p>由于题目直接要求出，故隐函数一般都是存在的，不用根据隐函数存在定理推一遍存在性</p><p>$(x=0,y=0) 时，(e^{3z} = 1 \Rightarrow z = 0)$</p><p>$令：(F(x,y,z) = e^{x+2y+3z} + \dfrac{xyz}{\sqrt{1+x^2+y^2+z^2}} - 1)$</p><p>$[ F_x = e^{x+2y+3z} + yz \cdot (1+x^2+y^2+z^2)^{\frac{1}{2}} + x^2yz \cdot (1+x^2+y^2+z^2)^{-\frac{3}{2}} ]$</p><p>$[ F_y = 2e^{x+2y+3z} + xz \cdot (1+x^2+y^2+z^2)^{\frac{1}{2}} + xy^2z \cdot (1+x^2+y^2+z^2)^{-\frac{3}{2}} ]$</p><p>$[ F_z = 3e^{x+2y+3z} + xy \cdot (1+x^2+y^2+z^2)^{\frac{1}{2}} + xyz^2 \cdot (1+x^2+y^2+z^2)^{-\frac{3}{2}} ]$</p><p>$则 (\dfrac{\partial z}{\partial x}\bigg|<em>{(0,0)} = - \dfrac{1}{3})，(\dfrac{\partial z}{\partial y}\bigg|</em>{(0,0)} = - \dfrac{2}{3})，故 全微分 (dz\bigg|_{(0,0)} = -\dfrac{1}{3}dx - \dfrac{2}{3} dy)$</p><p>解法二<br>求偏导数，直接求过于复杂，多元函数考虑 先代后求再代：</p><p>$考虑对 (x) 求偏导，则不妨令 (y = 0)：(e^{x + 3z} \cdot (1 + 3 \cdot \dfrac{\partial z}{\partial x})\bigg|<em>{(0,0)} = 0 \Rightarrow \dfrac{\partial z}{\partial x}\bigg|</em>{(0,0)} = -\dfrac{1}{3})$</p><p>$考虑对 (y) 求偏导，则不妨令 (x = 0)：(e^{2y + 3z} \cdot (2 + 3 \cdot \dfrac{\partial z}{\partial y})\bigg|<em>{(0,0)} = 0 \Rightarrow \dfrac{\partial z}{\partial y}\bigg|</em>{(0,0)} = -\dfrac{2}{3})$</p><p>$故 全微分 (dz\bigg|_{(0,0)} = -\dfrac{1}{3}dx - \dfrac{2}{3} dy)$</p><h2 id="题目323">题目323</h2><p>$设 (f(t)) 在 ([1,+\infty)) 上有 连续二阶导数，且 (f(1) = 0, f’(1) = 1, z = (x^2 + y^2)f(x^2 + y^2))$</p><p>$满足 (\dfrac{\partial^2z}{\partial x^2} + \dfrac{\partial^2z}{\partial y^2} = 0). 求 (f(x)) 在 ([1,+\infty) 的最大值)$</p><h3 id="解答-82">解答</h3><p>$这题分为两个步骤：1.解出 (f(x)) 表达式 2.求出极值$</p><p>$第一步毫无疑问，那就是微分方程了，考虑如何对 (z) 求导：$</p><p>$直接做不好做，观察发现方程右侧是关于 (x^2+y^2) 得函数，故不妨令 (x^2+y^2 = u)，则 (\dfrac{\partial u}{\partial x} = 2x, \dfrac{\partial u}{\partial y} = 2y, z(u) = uf(u))$</p><p>$方程两侧对 (x) 求偏导：$</p><p>$[ \dfrac{\partial z}{\partial x} = \dfrac{\partial z}{\partial u} \cdot \dfrac{\partial u}{\partial x} = z’(u) \cdot 2x \qquad \dfrac{\partial^2 z}{\partial x^2} = z’‘(u) \cdot 4x^2 + 2 z’(u) ]$</p><p>$由于 (x) 与 (y) 在多项式中具有轮换对称性，故：(\dfrac{\partial^2 z}{\partial y^2} = z’‘(u) \cdot 4y^2 + 2 z’(u))$</p><p>代入偏微分方程中：</p><p>$[ z’‘(u) \cdot 4y^2 + 2 z’(u) + z’‘(u) \cdot 4x^2 + 2 z’(u) = 0 \Rightarrow uz’’ + z’ = 0 ]$</p><p>$[ \Rightarrow 令 z’ = p: u p’ = -p \Rightarrow u \cdot \frac{dp}{du} = -p \Rightarrow \frac{dp}{p} = -\frac{du}{u} ]$</p><p>$[ \Rightarrow \ln p = -\ln u + C_1 \Rightarrow p = C_2\frac{1}{u} \Rightarrow \dfrac{dz}{du} = C_2 \frac{1}{u} ]$</p><p>[ \Rightarrow z = C_2 \cdot (\ln u + C_3) ]</p><p>$接下来就是代入初值，解出任意常数 (C) 即可$</p><p>$(z’ = f(u) + uf’(u) 且 f’(1) = 1 \Rightarrow z’(1) = 1 \Rightarrow p(1) = C_2 = 1)$</p><p>$(z(1)=f(1)=0) 代入：(z = C_3 = 0)$</p><p>$故 (z = \ln u)，可以推得：(f(u) = \dfrac{\ln u}{u} \Rightarrow f’(u) = \dfrac{1 - \ln u}{u^2})$</p><p>$故 (f(u)) 在 ([1, e]) 单调增，在 ([e,+\infty)) 单调减，由 极值判别的充要条件 可知：(x=e) 为 极大值点$</p><p>$比较区间的端点后，发现该 极值点 为 最值点，故 (\max{f(x)} = f(e) = \dfrac{1}{e})$</p><h2 id="题目324">题目324</h2><p>$设 (u = f(x,y,z), z = z(x,y)) 是由方程 (\varphi(x+y,z) = 1) 所确定的隐函数$</p><p>$求 (\dfrac{\partial u}{\partial x}, du, \dfrac{\partial^2 u}{\partial x \partial y}). 其中 (f) 和 (\varphi) 有二阶连续偏导数且 (\varphi_2 \ne 0)$</p><h3 id="解答-83">解答</h3><p>$根据题意，易得 (z) 是关于 (x,y) 的函数，本题考察的就是链式求导法则$</p><p>$[ \dfrac{\partial u}{\partial x} = f_1 \cdot 1 + f_3 \cdot \dfrac{\partial z}{\partial x} , \qquad \dfrac{\partial \varphi}{\partial x} = \varphi_1 + \varphi_2 \cdot \dfrac{\partial z}{\partial x} = 0 \Rightarrow \dfrac{\partial z}{\partial x} = -\frac{\varphi_1}{\varphi_2} ]$</p><p>$联立二式：(\dfrac{\partial u}{\partial x} = f_1 - \dfrac{\varphi_1}{\varphi_2} \cdot f_3)，由于 (x,y) 在方程中具有轮换对称性，故同理可得：(\dfrac{\partial u}{\partial y} = f_2 - \dfrac{\varphi_1}{\varphi_2} \cdot f_3)$</p><p>故可以写出 全微分：</p><p>$[ du = \dfrac{\partial u}{\partial x} dx + \dfrac{\partial u}{\partial y}dy = \bigg({f_1 - \dfrac{\varphi_1}{\varphi_2} \cdot f_3}\bigg) dx + \bigg({f_2 - \dfrac{\varphi_1}{\varphi_2} \cdot f_3}\bigg) dy ]$</p><p>再求一阶偏导：</p><p>$[ \dfrac{\partial^2 u}{\partial x \partial y} = f_{12} - \dfrac{\varphi_1}{\varphi_2} \cdot f_{13} - \dfrac{\varphi_1}{\varphi_2} \cdot f_{32} + (\dfrac{\varphi_1}{\varphi_2})^2 \cdot f_{33} ]$</p><h2 id="题目325">题目325</h2><p>$设函数 (z = z(x,y)) 的微分 (dz = (2x + 12y) dx + (12x + 4y)dy) 且 (z(0,0) = 0)$</p><p>$求函数 (z = z(x,y)) 在 (4x^2 + y^2 \le 25) 上的最大值$</p><h3 id="解答-84">解答</h3><p>这里没有使用 偏积分，而是用的 凑微分 法：</p><p>$[ dz = 2xdx + 12ydx + 12xdy + 4ydy = d(x^2) + d(12xy) + d(2y^2) = d(x^2 + 12xy + 2y^2) ]$</p><p>$[ z = x^2 + 12xy + 2y^2 + C ]$</p><p>$代入 ((0,0)) 可得：(z(0,0) = C = 0)，求得 (z = x^2 + 12xy + 2y^2)$</p><p>武佬用的 拉格朗日乘数法：</p><p>$令 (F(x,y,\lambda) = x^2 + 12xy + 2y^2 + \lambda(4x^2 + y^2 - 25))$</p><p>$[ \text{令} \begin{cases} F_x = 2x + 12y + 8\lambda x = 0 \\ F_y = 12x + 4y + 2\lambda y = 0 \\ F_\lambda = 4x^2 + y^2 -25 = 0 \end{cases} ]$</p><p>$我们想要解出的是 椭圆上边界的点，故 (x\ne 0, y\ne 0)$</p><p>$根据 线性代数 方程组的知识可知，我们想要求的是 齐次方程组 (\begin{cases} (1 + 4\lambda)x + 6y = 0 \\ 6x + (2y + \lambda) y = 0 \end{cases}) 的非零解$</p><p>$故该方程组的 系数矩阵行列式为零 (\begin{vmatrix} 1 + 4\lambda &amp; 6 \\ 6 &amp; 2y + \lambda \end{vmatrix} = 0 \Rightarrow \lambda = 2 \text{ 或 } -\dfrac{17}{4})$</p><p>$解得： (\lambda=2) 时，(x = 2, y = -3 \quad or \quad x = -2, y = 3)，此时 (z = -50)$</p><p>$(\lambda=-\dfrac{17}{4}) 时，(x = \dfrac{3}{2}, y = 4 \quad or \quad x = -\dfrac{3}{2}, y = -4)，此时 (z = \dfrac{425}{4})$</p><p>解答一（不等式放缩找上界最小值）<br>$全微分： (dz = \dfrac{\partial z}{\partial x} dx + \dfrac{\partial z}{\partial y} dy)，由 一阶微分形式不变性：$ [\begin{cases} \dfrac{\partial z}{\partial x} = 2x + 12y \\ \dfrac{\partial z}{\partial y} = 12x + 4y \end{cases}]<br>$</p><p>$利用求 偏积分 来解出函数表达式：(\dfrac{\partial z}{\partial x} = 2x + 12y ~ \Rightarrow ~ z = x^2 + 12xy + \varphi(y))$</p><p>$再求 偏导 然后 联立 方程二：(\dfrac{\partial z}{\partial y} = 12x + \varphi’(y) = 12x + 4y \Rightarrow \varphi’(y) = 4y \Rightarrow \varphi(y) = 2y^2 + C)$</p><p>$由于 (z(0,0) = 0)，故 (C = 0 \Rightarrow z = x^2 + 12xy + 2y^2)$</p><p>$求 目标函数：(z = x^2 + 12xy + 2y^2) 在 限制条件：(4x^2 + y^2 \le 25) 上的 最大值$</p><p>普遍性方法 是 拉格朗日数乘法，但这题很显然，可以用 不等式放缩 来做，避免求 拉格朗日乘子 的 复杂计算</p><p>加减法放缩乘除法 -&gt; 基本不等式、加减法放缩加减法 -&gt; 柯西不等式，本题显然是用 基本不等式 来求解</p><p>我们要求的是 目标函数的最大值，等价于求 上界约束的最小值</p><p>$由 基本不等式 变形：(xy \le \dfrac{64x^2 + 9y^2}{48})，可以推得：$</p><p>$[ 12xy \le \dfrac{64x^2 + 9y^2}{4} \Rightarrow z = x^2 + 12xy + 2y^2 \le \dfrac{17}{4} \cdot (4x^2 + y^2) \le \frac{425}{4} ]$</p><p>$故 最大值 为：(\dfrac{425}{4})$</p><p>$解答二（三角换元找函数的最大值）<br>求 目标函数：(z = x^2 + 12xy + 2y^2) 在 限制条件：(4x^2 + y^2 \le 25) 上的 最大值$</p><p>$看见 平方项相加，想到我们熟悉的 三角换元法：令 (\begin{cases} 2x &amp;= r \cos \theta \\ y &amp;= r \sin \theta \end{cases} \quad r\in[0,5], \theta\in[0,2\pi])，原题化为：$</p><p>$问题变为：求 目标函数：$z = r22 + 3r^2 2 + 2r^2 ^2 $ 在 限制条件：(r\in[0,5], \theta\in[0,2\pi]) 上的 最大值$</p><p>$[ \begin{aligned} z &amp;= r^2 \cdot \bigg({\frac{\cos^2\theta + 12\sin2\theta + 8\sin^2\theta}{4}}\bigg) = r^2 \cdot \bigg({\frac{1 + 12\sin2\theta + 7\sin^2\theta}{4}}\bigg) \\ &amp;= r^2 \cdot \bigg({\frac{1 + 12\sin2\theta + \dfrac{7}{2} \cdot (1 - \cos2\theta)}{4}}\bigg) \\ &amp;= r^2 \cdot \bigg({\frac{9 + 24\sin2\theta - 7\cos2\theta)}{8}}\bigg) \\ &amp;= r^2 \cdot \bigg({\frac{9 + 25 \sin (2\theta + \varphi)}{8}}\bigg) \\ &amp;= \frac{9}{8}r^2 + \frac{25}{8} r^2 \sin(2\theta + \varphi) \end{aligned} ]$</p><p>$故 (z \in [-50, \dfrac{425}{4}] \Rightarrow \max\bigg({z(r,\theta)}\bigg) = \dfrac{425}{4})$</p><h2 id="题目326">题目326</h2><p>$[ 累次积分 \int_0^{\frac{\pi}{4}}d\theta \int_0^{2\cos\theta} f(r\cos\theta,r\sin\theta)r dr 等于 ]</p><p>[ \begin{aligned} &amp;(A) \int_0^1dy\int_y^{1-\sqrt{1-y^2}} f(x,y)dx \quad (B) \int_0^2dx\int_0^{\sqrt{2x-x^2}} f(x,y)dy \\ &amp;© \int_0^2dr\int_0^{\frac{\pi}{4}} f(r\cos\theta,r\sin\theta)d\theta \\ &amp;(D) \int_0^{\sqrt{2}}dr\int_0^{\frac{\pi}{4}} f(r\cos\theta,r\sin\theta)r d\theta + \int_{\sqrt{2}}^2dr\int_0^{\arccos \frac{r}{2}} f(r\cos\theta,r\sin\theta)r d\theta\\ \end{aligned} ]$</p><h3 id="解答-85">解答</h3><p>(A）（B） 选项是 直角坐标，（C）（D） 选项都是 极坐标</p><p>故考虑对该积分区域进行 坐标变化 和 交换积分次序 来比较 4 个选项</p><p>$由 (r) 的积分上限计算可得：(r = 2\cos \theta \Rightarrow r\cos\theta = 2\cos^2\theta \Rightarrow x = 2\cos^2\theta = 1+\cos 2\theta)$</p><p>$，同理 (y = \sin 2\theta)，故积分区域是部分圆：((x-1)^2 + y^2 = 1)$</p><p>换元成 直角坐标：（后积先定限，限内画条线，先交写下限，后交写上限）</p><p>$[ \begin{aligned} &amp; \int_0^1 dx \int_0^{y} f(x,y) dy + \int_1^2 dx \int_0^{\sqrt{2x - x^2}} f(x,y) dy \\ &amp; \int_0^1 dy \int_y^{1+\sqrt{1-y^2}} f(x,y) dx \end{aligned} ]$</p><p>$极坐标交换积分次序：（直接把 (\theta) 当作 (x)，(r) 当作 (y) 会变得很简单）$</p><p>$画出 (\theta, r) 得 积分区域 后，发现是一个 曲边梯形，故 分开积分$</p><p>$[ \int_0^{\sqrt{2}} dr \int_0^{\frac{\pi}{4}} f(r\cos\theta,r\sin\theta)r d\theta + \int_{\sqrt{2}}^2 dr \int_0^{\arccos\frac{r}{2}} f(r\cos\theta,r\sin\theta)r d\theta ]$</p><p>$故正确答案为 (D)$</p><h2 id="题目327">题目327</h2><p>求二重积分：</p><p>$[ \int_0^{\frac{\pi}{4}}d\theta\int_0^{\frac{1}{\cos \theta}} \rho^2d\rho + \int_1^{\sqrt{2}}dx\int_0^{\sqrt{2-x^2}}\sqrt{x^2 + y^2}dy ]$</p><h3 id="解答-86">解答</h3><p>一般来说，求一个 二重积分 的 和，是 出题人 有意的 拆分了积分区域</p><p>拆开后，通过 极直互化 或 交换积分次序 变成两个完全不一样的 积分</p><p>出题人不会让你一道二重积分题，算两个二重积分然后再加起来的 （如果是的话，明天我就去命题组）</p><p>本题是 极坐标二重积分 + 直角坐标二重积分，经过初步观察，考虑 直角坐标 转 极坐标</p><p>通过简单的 积分区域绘制 （电脑不太好画就不画了），是一个 四分之一圆，如我们先前 预判 的一样</p><p>$[ \begin{aligned} \text{原式} &amp;= \int_0^{\frac{\pi}{4}}d\theta\int_0^{\frac{1}{\cos \theta}} \rho^2d\rho + \int_1^{\sqrt{2}}dx\int_0^{\sqrt{2-x^2}}\sqrt{x^2 + y^2}dy \\ &amp;= \int_0^{\frac{\pi}{4}}d\theta\int_0^{\frac{1}{\cos \theta}} \rho^2d\rho + \int_0^{\frac{\pi}{4}}d\theta\int_{\frac{1}{\cos \theta}}^{\sqrt{2}} \rho^2d\rho \\ &amp;= \int_0^{\frac{\pi}{4}}d\theta\int_0^{\sqrt{2}} \rho^2d\rho \\ &amp;= \frac{\pi}{4} \cdot \frac{2^{\frac{3}{2}}}{3} \\ &amp;= \frac{\sqrt{2}}{6} \pi \end{aligned} ]$</p><h2 id="题目328">题目328</h2><p>$[ \text{求二重积分：} \int_0^1dy\int_y^1 x\sqrt{2xy-y^2} dx ]$</p><h3 id="解答-87">解答</h3><p>对于 $(x\sqrt{x-1})$ 这个函数 直接积分 是不太好积的，考虑 极直互化 或 交换积分次序</p><p>本题的 积分区域 是一个 角型区域，考虑化 极坐标</p><p>$[ \begin{aligned} &amp;\int_0^\frac{\pi}{4} d\theta \int_0^\frac{1}{\cos\theta} r\cos\theta\sqrt{2r^2\cos\theta\sin\theta - r^2\sin^2\theta} rdr \\ =&amp; \int_0^{\frac{\pi}{4}} d\theta \int_0^\frac{1}{\cos\theta} r^3\cos\theta \sqrt{2\sin\theta\cos\theta - \sin^2\theta} dr \\ =&amp; \frac{1}{4}\int_0^\frac{\pi}{4} \cos\theta \sqrt{2\sin\theta\cos\theta - \sin^2\theta} \cdot \frac{1}{\cos^4\theta} d\theta \\ =&amp; \frac{1}{4}\int_0^\frac{\pi}{4} \sqrt{2\tan\theta - \tan^2\theta} \cdot \frac{1}{\cos^2\theta} d\theta \\ =&amp; \frac{1}{4}\int_0^\frac{\pi}{4} \sqrt{2\tan\theta - \tan^2\theta}d\tan\theta \\ =&amp; \frac{1}{4}\int_0^1 \sqrt{2u - u^2} du = \frac{1}{4}\int_{-\frac{\pi}{2}}^0 \cos^2t dt = \frac{1}{4}\int_0^{\frac{\pi}{2}} \cos^2t dt \\ =&amp; \frac{1}{4} \cdot \frac{1}{2} \cdot \frac{\pi}{2} \quad (\text{点火公式})\\ =&amp; \frac{\pi}{16} \end{aligned} ]$</p><h2 id="题目329">题目329</h2><p>$[ \lim_{n\to\infty} \frac{\sqrt[n]{2}-1}{\sqrt[n]{2n+1}} \cdot \sum_{i=1}^n\int_1^{\frac{2i-1}{2n}}e^{-y^2}dy ]$</p><h3 id="解答-88">解答</h3><p>定积分定义<br>夹逼准则<br>本题的 和式 过于复杂，放缩 不好掌握尺度，故考虑 凑定积分定义</p><p>$本题是把 区间 ([0,1]) 拆分成 (n) 个 子区间，每个 子区间 范围为 ([\dfrac{i-1}{n}, \dfrac{i}{n}]\quad i = 1,2,…,n)$</p><p>$一般的 定积分定义 我们在每个 子区间 进行 估计 的时候，都是用的 右端点 (\dfrac{i}{n})$</p><p>$但实际上， 定积分定义 中的 估计点 可以是该 子区间 中的 任意一点，比如本题用的 中点 (\dfrac{2i-1}{2n})$</p><p>这就是 本题 的 唯一考点 了，考察学生对于 定积分定义 的了解，如果只是 背模板 取 右端点 就会 死的很惨</p><p>$[ \begin{aligned} &amp;\quad \lim_{n\to\infty} \frac{\sqrt[n]{2}-1}{\sqrt[n]{2n+1}} \cdot \sum_{i=1}^n\int_1^{\frac{2i-1}{2n}}e^{-y^2}dy \\ =&amp;\quad \lim_{n\to\infty} \frac{e^{\frac{\ln 2}{n}}-1}{(1+2n)^{\frac{1}{n}}} \cdot \sum_{i=1}^n\int_1^{\frac{2i-1}{2n}}e^{-y^2}dy \\ =&amp;\quad \ln 2 \cdot \lim_{n\to\infty} \frac{1}{n} \cdot \sum_{i=1}^n\int_1^{\frac{2i-1}{2n}}e^{-y^2}dy \\ =&amp; \quad \ln 2 \cdot \lim_{n\to\infty} \frac{1}{n} \cdot f(\frac{2i-1}{2n}) \\ =&amp;\quad - \ln 2 \cdot \int_0^1dx\int_x^1e^{-y^2} dx \\ =&amp; \quad - \ln 2 \cdot \int_0^1dy\int_0^ye^{-y^2} dx \\ =&amp;\quad \frac{\ln 2}{2} \cdot \int_0^1e^{-y^2} d(-y^2) \\ =&amp; \quad \frac{\ln 2}{2}\cdot e^{-y^2}\bigg|_0^1 \\ =&amp; \quad \frac{\ln 2(1-e)}{2e} \end{aligned} ]$</p><h2 id="题目330">题目330</h2><p>$设 (D) 是由 (0\le x \le 1, 0 \le y \le 1) 所确定的平面区域，求 (\iint\limits_D\sqrt{x^2+y^2}dxdy)$</p><h3 id="解答-89">解答</h3><p>被积函数 里有 (x^2+y^2)，考虑转换成 极坐标</p><p>$[ \begin{aligned} \text{原式} \quad = \quad &amp; \int_0^{\frac{\pi}{4}}d\theta\int_0^{\frac{1}{\cos\theta}} r^2dr + \int_{\frac{\pi}{4}}^\frac{\pi}{2}d\theta\int_0^{\frac{1}{\sin\theta}} r^2dr \\ = \quad &amp; \frac{1}{3}\bigg(\int_0^{\frac{\pi}{4}} \sec^3\theta d\theta + \int_{\frac{\pi}{4}}^\frac{\pi}{2} \csc^3\theta d\theta\bigg) \\ = \quad &amp; \frac{2}{3}\bigg(\int_0^{\frac{\pi}{4}} \sec^3\theta d\theta\bigg) \\ \end{aligned} ]$</p><p>$[ \begin{aligned} \int \sec^3x dx = \tan x\sec x - \int \tan^2 x \sec x dx = \tan x\sec x - \int (\sec^3 - \sec x) dx \\ =\tan x\sec x - I + \int\sec xdx \Rightarrow I = \frac{1}{2}\tan x \sec x + \frac{1}{2} \ln (\tan x + \sec x) + C \end{aligned} ]$</p><p>$[ \text{原式} = \frac{1}{3}\tan x \sec x + \frac{1}{3} \ln (\tan x + \sec x) \bigg|_0^{\frac{\pi}{4}} = \frac{\sqrt{2}}{3}+\frac{1}{3}\ln (1+\sqrt{2}) ]$</p><h2 id="题目331">题目331</h2><p>$[ \text{计算积分：} \int_{\frac{\pi}{4}}^{\frac{3\pi}{4}}d\theta\int_0^{2\sin\theta} [\sin\theta + \cos\theta\sqrt{1+r^2\sin^2\theta}]r^2dr ]$</p><h3 id="解答-90">解答</h3><p>直接积不好积，考虑 极直互化</p><p>二重积分 一般考只考两个知识点： 1. 极直互化 2. 交换积分次序</p><p>不会让你上来直接做两次积分就能求出来的，这也是 命题人 的 套路</p><p>$求出积分域，(r = 2\sin\theta \Rightarrow r^2 = 2r\sin\theta \Rightarrow x^2 + y^2 = 2y \Rightarrow x^2 + (y-1)^2 = 1)$</p><p>$是 一个圆，在 (y=x, y = -x) 的 上方区域，因此具有天然 对称性：关于 (y) 轴对称$</p><p>$所以，被积函数 有一部分可以直接等于 (0)$</p><p>$[ \begin{aligned} \text{原式} \quad = &amp;\quad \iint\limits_D(y + x\sqrt{1+y^2}) d\sigma \\ = &amp;\quad \iint\limits_Dy d\sigma \\ = &amp;\quad 2\int_0^1dx\int_x^{1 + \sqrt{1-x^2}} ydy \\ = &amp;\quad 2\int_0^1 (1-x^2+2\sqrt{1-x^2}) dx \\ = &amp;\quad 2 \cdot (1 - \frac{1}{3} + \frac{\pi}{4}) \\ = &amp;\quad \frac{4}{3} + \frac{\pi}{2} \\ \end{aligned} ]$</p><h2 id="题目332">题目332</h2><p>$(D = \{(x,y)||x| + |y| \le \dfrac{\pi}{2}\})，比较积分大小： [ I_1=\iint\limits_D\sqrt{x^2+y^2}d\sigma,I_2=\iint\limits_D\sin\sqrt{x^2+y^2}d\sigma,I_3=\iint\limits_D(1-\cos\sqrt{x^2+y^2})d\sigma ]$</p><h3 id="解答-91">解答</h3><p>由于积分区域相同，故只需比较被积函数大小</p><p>$令 (x^2+y^2 = u^2)$</p><p>$[ I_1 = \iint\limits_D u d\sigma,I_2 = \iint\limits_D \sin u d\sigma, I_3 = \iint\limits_D (1-\cos u) d\sigma, ]$</p><p>$令 (f(x) = x -1+ \cos x)，则 (f(0) = 0, f’(x) = 1 - \sin x &gt; 0)$</p><p>$故 (x &gt; 1-\cos x)$</p><p>$令 (f(x) = \sin x -1+ \cos x)，则 (f(0) = 0, f’(x) = \cos x - \sin x)$</p><p>$易得：(f(x)) 在 ([0, \dfrac{\pi}{4}]) 单增，在 ([\dfrac{\pi}{4}, \dfrac{\pi}{2}]) 单减，且 (f(0) = 0, f(\dfrac{\pi}{2}) = 0)$</p><p>$故 (f(x) &gt; 0 \Rightarrow \sin x &gt; 1-\cos x)$</p><p>$综上：(x &gt; \sin x &gt; 1- \cos x)$</p><p>$故：(I_1 &gt; I_2 &gt; I_3)$</p><h2 id="题目333">题目333</h2><p>$(D = \{(x,y)||x| + |y| \le \dfrac{\pi}{2}\})，比较积分大小：$</p><p>$[ I_1=\iint\limits_D(2x^2+\tan(xy^2))d\sigma,I_2=\iint\limits_D(x^2y+2\tan y^2)d\sigma,I_3=\iint\limits_D(|xy|+y^2)d\sigma ]$</p><h3 id="解答-92">解答</h3><p>相同积分域 的 积分比大小，只需比较 被积函数 大小即可</p><p>本题积分域同上题，是由 四条直线 围成的 正方形区域</p><p>$由于 被积函数 过于复杂，考虑利用 对称性 和 奇偶性 进行 化简，显然图像关于 (x,y) 轴对称$</p><p>$而剩余部分都是关于 (x,y) 的偶函数，直接对称到第一象限，从而去掉绝对值$</p><p>$[ I_1 = 4\iint\limits_{D_1} 2x^2 d\sigma，I_2 = 4\iint\limits_{D_1} 2\tan y^2 d\sigma，I_3 = 4\iint\limits_{D_1} (xy+y^2) d\sigma ]$</p><p>$观察积分域 (D)，具有明显的 轮换对称性，又根据 (I = \dfrac{1}{2}\iint\limits_D[f(x,y)+f(y,x)]dxdy) 得:$</p><p>$(\tan x &gt; x \Rightarrow I_2 &gt; I_1)$</p><p>$[ I_1 = 2\iint\limits_{D_1} (2x^2+2y^2) d\sigma, I_3 = 2\iint\limits_{D_1} (x^2+y^2+2xy) d\sigma \lt 2\iint\limits_{D_1} (x^2+y^2+x^2+y^2) d\sigma ]$</p><p>$故 (I_3 \lt I_1 &lt; I_2)$</p><h2 id="题目334">题目334</h2><p>$[ \text{可微函数} f(x) \text{满足} f’(x) = f(x) + \int_0^1f(x)dx\text{，且} f(0) = 1\text{，求} f(x) ]$</p><h3 id="解答-93">解答</h3><p>$看见求原函数 (f(x)) 那只有一条途径：微分方程$</p><p>$所给的 方程 中含有 定积分，做法一般都是先把 定积分 令为 常数 (A) 从而化简运算$</p><p>$令 (\int_0^1f(x)dx = A)，则有微分方程：(y’ - y = A)，变量可分离型：(\dfrac{dy}{dx} = A + y)$</p><p>$[ \frac{dy}{A+y} = dx \quad\Rightarrow\quad \ln(A+y) = x + C \quad\Rightarrow\quad y = Ce^x - A ]$</p><p>$对 (y) 在 ((0,1)) 上进行积分：$</p><p>$[ A = C\int_0^1e^xdx - A \quad\Rightarrow\quad A = \frac{C(e - 1)}{2} ]$</p><p>$代入初值 (y(0) = 1)：$</p><p>$[ 1 = C - \frac{C(e - 1)}{2} \quad\Rightarrow\quad 2 = C \cdot (2 - e + 1) \quad\Rightarrow\quad C = \frac{2}{3-e} ]$</p><p>$[ \text{综上所述：} f(x) = \frac{2e^x - e + 1}{3-e} ]$</p><h2 id="题目335">题目335</h2><p>$设 (f(x)) 是可导函数，且 (f(0) = 0, g(x) = \int_0^1xf(tx)dt)，并满足方程 (f’(x)+g’(x)=x)，$</p><p>$求由曲线 (y=f(x), y = e^{-x}) 及直线 (x=0,x=2) 围成的平面图形的面积$</p><h3 id="解答-94">解答</h3><p>$先对 (g(x)) 的 自变量 和 积分变量 进行分离，令 (tx = u)，则 (xdt = du, g(x) = \int_0^x f(u)du)$</p><p>$故 (g’(x) = f(x)) 代入方程得：(f’(x) + f(x) = x) 为 一阶线性微分方程，写出通解：$</p><p>$[ f(x) = e^{-\int 1 dx} \cdot \big[\int x \cdot e^{\int 1dx}dx + C\big] = e^{-x} \cdot\big[ xe^x - e^x + C \big] = x - 1 + Ce^{-x} ]$</p><p>$代入初值：(f(0) = C - 1 = 0 \quad \Rightarrow \quad C = 1)$</p><p>$剩余问题为，求解：由曲线 (y=x-1+e^{-x}, y = e^{-x}) 及直线 (x=0,x=2) 围成的平面图形的面积$</p><p>$该图像不是很好绘制，但是可以明显观察到，(y_1 &lt; y_2 (x &lt; 1), y_1 &gt; y_2(x &gt; 1))$</p><p>故我们可以意象出他的一个曲边梯形模样，直接套对应区间的定积分公式即可：</p><p>$[ \begin{aligned} &amp; \quad \int_0^2 |y_1 - y_2|dx \\ =&amp;\quad \int_0^1(y_2-y_1)dx + \int_1^2(y_1-y_2)dx \\ =&amp;\quad \int_0^1 (1-x) dx + \int_1^2 (x - 1) dx \\ =&amp;\quad (x - \frac{1}{2}x^2) \bigg|_0^1 + (\frac{1}{2}x^2 - x) \bigg|_1^2 \\ =&amp;\quad \frac{1}{2} + \frac{1}{2} \\ =&amp;\quad 1 \\ \end{aligned} ]$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第304-319题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC304-319%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC304-319%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目304">题目304</h2><p>$[ \begin{aligned} 设 f(x) = \lim_{n\to\infty} \frac{x^{n+1}-x^2}{x^n+1}, &amp;F(x) = \int_0^xf(t)dt,则() \\ (A)f(x)有1个间断点，F(x)有1个不可导点 \quad&amp;(B)f(x)有1个间断点，F(x)有2个不可导点 \\ ©f(x)有2个间断点，F(x)有1个不可导点 \quad&amp;(D)f(x)有2个间断点，F(x)有2个不可导点 \end{aligned} ]$</p><h3 id="解答-95">解答</h3><p>$首先先解出 (f(x)) 的分段表达式：$</p><p>$|x| &lt; 1 时： (f(x) = \lim\limits_{n\to\infty} \dfrac{x^{n+1}-x^2}{x^n+1} = \dfrac{0-x^2}{0 + 1} = -x^2)$</p><p>$x = +1 时： (f(x) = \lim\limits_{n\to\infty} \dfrac{x^{n+1}-x^2}{x^n+1} = \dfrac{1-1}{1+1} = 0)$</p><p>$x = -1 时： (f(x) = \lim\limits_{n\to\infty} \dfrac{x^{n+1}-x^2}{x^n+1} = \dfrac{(-1)^{n+1}-1}{(-1)^n+1} = 不存在)$</p><p>$|x| &gt; 1 时： (f(x) = \lim\limits_{n\to\infty} \dfrac{x^{n+1}-x^2}{x^n+1} = \dfrac{x - \frac{1}{x^{n-2}}}{1 + \frac{1}{x^n}} = x)$</p><p>$故 (f(x) = \begin{cases} -x^2 &amp; |x| &lt; 1 \\ 0 &amp; x = 1\\ x &amp; |x| &gt; 1 \end{cases})$</p><p>$因此可以轻易观察出 (f(x)) 的间断点：可去间断点 (x = - 1)，跳跃间断点 (x = 1)$</p><p>$研究可导性，可以用 导数定义：$</p><p>$F’(-1^-) = \lim\limits_{x\to-1^-} \dfrac{\int\limits_0^xf(t)dt - \dfrac{1}{3}}{x + 1} = \lim\limits_{x\to-1^-}f(x) = -1$</p><p>$F’(-1^+) = \lim\limits_{x\to-1^+}\dfrac{\int\limits_0^xf(t)dt - \dfrac{1}{3}}{x + 1} = \lim\limits_{x\to-1^+}f(x) = -1)$</p><p>$由 导数极限定理： (F’(-1) = F’(-1^-) = F’(-1^+) = -1)$</p><p>$(F’(1^-) = \lim\limits_{x\to1^-}\dfrac{\int\limits_0^xf(t)dt + \dfrac{1}{3}}{x + 1} = \lim\limits_{x\to1^-}f(x) = -1)$</p><p>$(F’(1^+) = \lim\limits_{x\to1^+}\dfrac{\int\limits_0^xf(t)dt + \dfrac{1}{3}}{x + 1} = \lim\limits_{x\to1^+}f(x) = 1)$</p><p>$由 极限的唯一性： (F(x)) 在 (x=1) 处，不可导$</p><h2 id="题目305">题目305</h2><p>$[ 设 f(x) 在 [1,+\infty)上有连续一阶导数，f’(x)=\dfrac{1}{1+f^2(x)}\bigg[{\sqrt{\frac{1}{x}} - \sqrt{\ln(1+\frac{1}{x})}}\bigg]\ \quad\ 证明：\lim_{x\to+\infty}f(x)存在 ]$</p><h3 id="解答-96">解答</h3><p>证明极限的存在性： 1. 单调有界准则（抽象型函数） 2. 夹逼准则（具体型函数）</p><p>本题对于抽象型函数，应考虑使用 单调有界准则</p><p>由 常见不等式：(\dfrac{1}{x+1} \lt \ln(1+\dfrac{1}{x}) \lt \dfrac{1}{x})，可知：({\sqrt{\dfrac{1}{x}} - \sqrt{\ln(1+\dfrac{1}{x})}} &gt; 0)</p><p>故 $f’(x) &gt; 0 $ 函数 单调增</p><p>现还需证明函数 上有界，但是题干中只给了 一阶导数 信息</p><p>联系一阶导数与函数的桥梁有：拉格朗日中值定理、逆用牛顿莱布尼兹公式</p><p>$本题我们是希望把函数还原到区间 ([1,+\infty)) 上的，用 中值定理 来区间估计误差会很大（带个正无穷）$</p><p>因此考虑 逆用牛顿莱布尼茨公式，对方程两次进行积分：</p><p>$[ \begin{aligned} \int_1^xf’(t)dt &amp;= \int_1^x\dfrac{1}{1+f^2(t)}\bigg[{\sqrt{\frac{1}{t}} - \sqrt{\ln(1+\frac{1}{t})}}\bigg]dt \\ f(x) - f(1) &amp;= \int_1^x\dfrac{1}{1+f^2(t)}\bigg[{\sqrt{\frac{1}{t}} - \sqrt{\ln(1+\frac{1}{t})}}\bigg]dt \\ &amp;\le \int_1^x\bigg[{\sqrt{\frac{1}{t}} - \sqrt{\ln(1+\frac{1}{t})}}\bigg]dt （系数放缩）\ &amp;\le \int_1^x\bigg[{\sqrt{\frac{1}{t}} - \sqrt{\frac{1}{t+1}}}\bigg]dt \quad(不等式放缩)\\ &amp;\le \int_1^x\bigg[{\frac{1}{2}\xi^{-\frac{3}{2}}}\bigg]dt \quad(其中\xi\in(t,t+1)，拉格朗日中值定理)\\ &amp;\le \frac{1}{2}\int_1^x{t^{-\frac{3}{2}}}dt （放缩\xi）\\ f(x) &amp;\le f(1) + \frac{1}{2}\int_1^x{t^{-\frac{3}{2}}}dt \end{aligned}\\quad\\ 则 \lim_{x\to+\infty}f(x) = f(1) + \frac{1}{2}\int_1^{+\infty}{t^{-\frac{3}{2}}}dt ]$</p><p>$由 反常积分的常用结论—p积分 可知：(f(x)收敛 \Rightarrow f(x) 有上界)$</p><p>$由 单调有界准则： (\lim\limits_{x\to+\infty}f(x)存在)$</p><h2 id="题目306">题目306</h2><p>$[ 设 f(x) = \int_{-1}^x(1-|t|)dt (x\ge-1),求曲线y=f(x)与x轴所围图形的面积 ]$</p><h3 id="解答-97">解答</h3><p>看见绝对值，想办法去掉就好了，分段讨论即可</p><p>$-1 &lt; x &lt; 0 时:$</p><p>$[ f(x) = \int_{-1}^x(1+t)dt = t + \frac{1}{2}t^2 \bigg|_{-1}^x = \frac{1}{2}x^2 + x + \frac{1}{2} ]$</p><p>$0 &lt; x 时：$</p><p>$[ f(x) = \frac{1}{2} + \int_{0}^x(1-t)dt = \frac{1}{2} + t - \frac{1}{2}t^2 \bigg|_{0}^x = -\frac{1}{2}x^2 + x + \frac{1}{2} ]$</p><p>综上所述：</p><p>$[ f(x) = \begin{cases} \dfrac{1}{2}x^2 + x + \dfrac{1}{2} &amp; -1 &lt; x \le 0\\ -\dfrac{1}{2}x^2 + x + \dfrac{1}{2} &amp; 0 &lt; x \end{cases} ]$</p><p>通过简单的绘图（此处省略）可以简单通过定积分计算出图像面积：</p><p>$[ S = \int_{-1}^0 (\dfrac{1}{2}x^2 + x + \dfrac{1}{2}) dx + \int_0^{1 + \sqrt{2}} (-\dfrac{1}{2}x^2 + x + \dfrac{1}{2}) dx = 1 + \frac{2}{3}\sqrt{2} ]$</p><h2 id="题目307">题目307</h2><p>$求曲线 (y = \dfrac{x^2}{1+x^2}) 与其渐近线所围区域绕该渐近线旋转所得旋转体体积$</p><h3 id="解答-98">解答</h3><p>看到绕 渐近线旋转 的题，不要害怕，考研范围内只学过绕垂直于 x y 轴 的直线旋转，不会考超纲</p><p>求渐近线</p><p>$(y’=\dfrac{2x}{(1+x^2)^2}) 未找到无定义点，所以没有 铅锤渐近线$</p><p>$ _{x} = 1 $ 故存在 水平渐近线 $(y = 1)$</p><p>观察 $(f(x)) $是一个偶函数，故可以化简区间（我只能说，没看出来也能做）</p><p>体积微元法<br>$[ \begin{aligned} V &amp;= \pi \int_{-\infty}^{+\infty} (\frac{x^2}{1+x^2} - 1)^2 dx \\ &amp;=2\pi \int_{0}^{+\infty} \frac{1}{(1+x^2)^2} dx \\ &amp;=2\pi \int_{0}^{\frac{\pi}{2}} \frac{1}{\sec^2 t} dt \quad(三角换元)\\ &amp;=2\pi \int_{0}^{\frac{\pi}{2}} \cos^2t dt = \pi \int_{0}^{\frac{\pi}{2}} (1+\cos 2t) dt\\ &amp;= \pi \bigg({ t + \frac{1}{2}\sin 2t }\bigg)\bigg|_0^{\frac{\pi}{2}}\\ &amp;= \frac{\pi^2}{2} \end{aligned} ]$</p><p>面积微元法<br>$[ \begin{aligned} V &amp;= 2\pi\iint\limits_D (1-y)d\sigma\\ &amp;= 4\pi\int_0^{+\infty}dx\int_{\frac{x^2}{1+x^2}}^1 (1-y)dy\\ &amp;= 2\pi\int_0^{+\infty}\frac{1}{(1+x^2)^2}dx\\ &amp;= 2\pi\int_0^{\frac{\pi}{2}} \cos^2t dt \\ &amp;= \frac{\pi^2}{2} \end{aligned} ]$</p><h2 id="题目308">题目308</h2><p>$求曲线 (y=x^2) 与直线 (y=mx(m&gt;0)) 在第一象限内所围成的图形绕该直线旋转所形成的旋转体的体积 (V)$</p><h3 id="解答-99">解答</h3><p>本题可以用体积微元，也可以用面积微元，我仅展示面积微元的做法</p><p>$设区域内任意一点的坐标为 ((x,y))，则该点到转动轴的距离为 (r(x,y)=\dfrac{|y-mx|}{\sqrt{1+m^2}} = \dfrac{mx - y}{\sqrt{1+m^2}})$</p><p>然后直接套公式计算 二重积分 即可：</p><p>$[ \begin{aligned} V &amp;= 2 \pi \iint\limits_D \dfrac{mx - y}{\sqrt{1+m^2}} d\sigma \\ &amp;= 2 \pi \int_0^m dx \int_{x^2}^{mx} \dfrac{mx - y}{\sqrt{1+m^2}} dy \\ &amp;= \frac{2 \pi}{\sqrt{1+m^2}} \int_0^m dx \int_{x^2}^{mx} (mx - y) dy \\ &amp;= \frac{2 \pi}{\sqrt{1+m^2}} (\frac{1}{6} - \frac{1}{4} + \frac{1}{10})m^5 \\ &amp;= \frac{\pi m^5}{30\sqrt{1+m^2}}\\ \end{aligned} ]$</p><h2 id="题目309">题目309</h2><p>$设函数 (f(x)) 在 ([0,1]) 上 (2) 阶可导，且 (\int_0^1f(x)dx=0)，则（ ）$</p><p>$（A）当 (f’(x)&lt;0) 时，(f(\frac{1}{2}) &lt; 0) （B）当 (f’'(x)&lt;0) 时，(f(\frac{1}{2}) &lt; 0)$</p><p>$（C）当 (f’(x)&gt;0) 时，(f(\frac{1}{2}) &lt; 0) （D）当 (f’'(x)&gt;0) 时，(f(\frac{1}{2}) &lt; 0)$</p><h3 id="解答-100">解答</h3><p>要用到 一阶导数 和 二阶导数，考虑使用 泰勒中值</p><p>然后就是展开点的问题，选项中有暗示在 中点处展开，因此我们选择 中点</p><p>$[ f(x) = f(\frac{1}{2}) + f’(\frac{1}{2})(x-\frac{1}{2}) + \frac{f’'(\frac{1}{2})}{2!}(x-\frac{1}{2})^2 + R ]$</p><p>两侧同时积分，凑出题干里的积分：</p><p>$[ \int_0^1f(x)dx = f(\frac{1}{2}) + f’(\frac{1}{2})\int_0^1(x-\frac{1}{2})dx + \frac{f’‘(\dfrac{1}{2})}{2}\int_0^1(x-\frac{1}{2})^2 + R \\ 0 = f(\frac{1}{2}) + \frac{1}{2}f’'(\frac{1}{2})\int_0^1(x-\frac{1}{2})^2dx+R ]$</p><p>$由于 ((x-\dfrac{1}{2})^2 &gt; 0)，故 (\int_0^1(x-\frac{1}{2})^2 &gt; 0)$</p><p>$又 (f(\frac{1}{2}) &lt; 0)，故要使等号左端为 (0)，必须满足：(f’'(\dfrac{1}{2}) &lt; 0)，故 D选项 正确$</p><h2 id="题目310">题目310</h2><p>已知正值连续函数 (f(x)) 在 ([0,1]) 上单调减少，则对任意的 (a,b(0&lt;a&lt;b&lt;1))，下列结论不正确的是（ ）</p><p>$（A）(a\int_0^bf(x)dx &gt; b\int_0^af(x)dx) （B）(b\int_0^af(x)dx &gt; a\int_0^bf(x)dx)$</p><p>$（C）(a\int_0^b\sqrt{f(x)}dx &lt; b\int_0^a\sqrt{f(x)}dx) （B）(b\int_0^a\sqrt{f(x)}dx &lt; b\int_0^b\sqrt{f(x)}dx)$</p><h3 id="解答-101">解答</h3><p>解答一（中值定理）<br>核心思想就是用 积分中值定理 配合上题干给的 单调性 进行不等号判断</p><p>但是由于 ([0,a]) 和 ([0,b]) 区间有交集，故考虑 拆分区间</p><p>[ \begin{aligned} &amp;~~ a\int_0^bf(x)dx - b\int_0^af(x)dx \\ =&amp;~~ a\int_0^af(x)dx + a\int_a^bf(x)dx - b\int_0^af(x)dx \\ =&amp;~~ a^2 f(\xi) + a(b-a)f(\eta) - abf(\xi) \qquad \xi\in(0,a), \eta\in(a,b) \\ =&amp;~~ a^2\bigg({f(\xi) - f(\eta)}\bigg) + ab\bigg({f(\eta) - f(\xi)}\bigg) \\ =&amp;~~ a \cdot [f(\xi) - f(\eta)] \cdot (a-b) &lt; 0 \\ \end{aligned} ]</p><p>故 A选项错误</p><p>解答二（换元法还原积分上限）<br>不等式中的 定积分，他们的 被积函数一样，积分上限 不同</p><p>能不能把 积分上限 变成一样的，然后直接去比较 被积函数 呢？答：换元法</p><p>换元要三换：一换被积函数，二换积分变量，三换积分上下限</p><p>$我们想把积分限 ([0,b] \rightarrow [0, a])，故令 (x = \dfrac{b}{a} t)$</p><p>$[ a\int_0^bf(x)dx - b\int_0^af(x)dx = a\int_0^a f(\frac{b}{a}t) d\frac{b}{a}t - b\int_0^af(x)dx = b\bigg({ \int_0^a f(\frac{b}{a}x) - f(x) }\bigg)dx ]$</p><p>$由于 (b &gt; a)，故 (\dfrac{b}{a} &gt; 1 \Rightarrow f(\dfrac{b}{a}x) &lt; f(x))，$</p><p>$[ 则~~ a\int_0^bf(x)dx - b\int_0^af(x)dx = b\bigg({ \int_0^a f(\frac{b}{a}x) - f(x) }\bigg)dx &lt; 0 ]$</p><p>故 A 选项错误</p><p>$解答三（积分不等式常规解法—变上限积分法）<br>统一替换上限参数（或者下限参数，有的题目替换下限计算量小）$</p><p>$令 (F(x) = a\int_0^xf(t)dt - x\int_0^af(t)dt) （x &gt; a）$</p><p>$验证初值 (F(a) = 0)$</p><p>$求导：(F’(x) = af(x) - \int_0^af(t)dt = a(f(x) - f(\xi)))$</p><p>$由于 (\xi &lt; a &lt; x)，故 (f(x) - f(\xi) &lt; 0 \Rightarrow F’(x) &lt; 0)$</p><p>$又 (F(a) = 0)，故 (F(x) &lt; 0 \Rightarrow F(b) &lt; 0)$</p><p>$[ 即：a\int_0^bf(x)dx &lt; b\int_0^af(x)dx ]$</p><p>$故 A 选项错误</p><p>解答四（统一参数进行比较）<br>感觉有点像 OI 里常用的二元组排序法？$</p><p>对 A 选项进行变形：</p><p>$[ a\int_0^bf(x)dx &gt; b\int_0^af(x)dx \Rightarrow \frac{\int_0^bf(x)dx}{b} &gt; \frac{\int_0^af(x)dx}{a} ]$</p><p>$[ 于是我们可以令 F(x) = \dfrac{\int_0^xf(t)dt}{x} ]$</p><p>$[ 则~~ F’(x) = \frac{xf(x) - \int_0^xf(t)dt}{x^2} = \frac{x(f(x) - f(\xi))}{x^2} &lt; 0 ]$</p><p>$故 (F(b) &lt; F(a)) A选项错误$</p><h2 id="题目311">题目311</h2><p>$[ 设 I_1 = \int_0^\pi \frac{x\sin^2x}{1+e^{\cos^2x}}dx, I_2=\int_0^\pi\frac{\sin^2x}{1+e^{\cos^2x}}dx,I_3=\int_0^{\frac{\pi}{2}}\frac{\cos^2x}{1+e^{\sin^2x}}dx，比较三者的大小 ]$</p><h3 id="解答-102">解答</h3><p>看形式，其实就是考几个公式的变换，直接搞就完事了</p><p>$[ I_1 = \int_0^\pi \frac{x\sin^2x}{1+e^{\cos^2x}}dx = \pi\int_0^{\frac{\pi}{2}}\frac{\sin^2x}{1+e^{\cos^2x}}dx \qquad \bigg(套公式\int_0^\pi xf(\sin x)dx = \pi\int_0^{\frac{\pi}{2}}f(\sin x)dx\bigg) ]$</p><p>$[ I_2 = \int_0^\pi\frac{\sin^2x}{1+e^{\cos^2x}}dx = 2 \int_0^\frac{\pi}{2}\frac{\sin^2x}{1+e^{\cos^2x}}dx \qquad \bigg(利用被积函数关于 x = \frac{\pi}{2} 的对称性\bigg) ]$</p><p>$[ I_3=\int_0^{\frac{\pi}{2}}\frac{\cos^2x}{1+e^{\sin^2x}}dx = \int_0^{\frac{\pi}{2}}\frac{\sin^2x}{1+e^{\cos^2x}}dx \qquad \bigg(区间再现：\int_a^bf(x)dx = \int_a^bf(a + b - x)dx\bigg) ]$</p><p>$综上:(\begin{cases} I_1 = \pi I_3\\ I_2 = 2 I_3 \\ I_3 = I_3 \end{cases} \qquad\Rightarrow\qquad I_1 &gt; I_2 &gt; I_3)$</p><h2 id="题目312">题目312</h2><p>$[ 设 f(x) 在 [0,1] 上有连续导数，且f(0)=f(1)=0,证明：\int_0^1f^2(x)dx \le \frac{1}{8}\int_0^1f’^2(x)dx ]$</p><h3 id="解答-103">解答</h3><p>$积分不等式证明中，常用的六种手段：变量代换、积分中值定理、变上限积分、柯西不等式、逆用牛顿莱布尼茨公式、分布积分法$<br>$本题中，需要建立起 (f) 与 (f’) 之间的关系，故想到的方法有：(Lagrange中值定理) 和 (N-L公式)$</p><p>$当这两种方法都能使用的时候，我推荐后者，因为 (N-L公式) 是 还原原函数，不会损失精度$</p><p>$而 中值定理 是一种 区间估计，在 估计 的过程中，会 丢失精度，导致最终不等式不成立$</p><p>$逆用牛顿莱布尼茨公式： (f(x) = f(x) - f(0) = f(x)\bigg|_0^x = \int_0^xf’(t)dt)，接着用 柯西不等式 放缩$</p><p>$[ f^2(x) = \bigg(\int_0^xf’(t)dt \bigg)^2 \le \int_0^x 1^2 dt \cdot\int_0^x f’^2(t)dt = x\int_0^xf’^2(t)dt ]$</p><p>$此处直接两侧积分去做，证明的 精度 是(\dfrac{1}{2}) 不满足题目中的 (\dfrac{1}{8})，精度不够$</p><p>$题目中还给了 (f(1) = 0) 的条件，故考虑再搞一次：$</p><p>$逆用牛顿莱布尼茨公式： (f(x) = f(x) - f(1) = f(x)\bigg|_1^x = \int_1^xf’(t)dt)，接着用 柯西不等式 放缩$</p><p>$[ f^2(x) = \bigg(\int_x^1f’(t)dt \bigg)^2 \le \int_x^1 1^2 dt \cdot\int_x^1 f’^2(t)dt = (1 - x)\int_x^1f’^2(t)dt ]$</p><p>$这里我们想要 精度尽可能高 等价于求 上界的最小值 （有点类似差分约束的意思）$</p><p>$因此我们希望 拆分区间，使得两个 估计方式 在每段区间上 值较小 ：(x \le 1-x \Rightarrow x \le \dfrac{1}{2})$</p><p>$在 (\dfrac{1}{2}) 处切开，分别进行估计$</p><p>$[ \begin{cases} f^2(x) &amp;\le x\int_0^xf’^2(t)dt &amp;\le x\int_0^{\frac{1}{2}}f’^2(t)dt &amp;(0\le x \le \frac{1}{2})\\ f^2(x) &amp;\le (1-x)\int_x^1f’^2(t)dt &amp;\le (1-x)\int_{\frac{1}{2}}^1 f’^2(t)dt &amp;(\frac{1}{2}\lt x \le 1) \end{cases} ]<br>$<br>$[ \begin{aligned} \int_0^1 f^2(t)dt = \int_0^{\frac{1}{2}} f^2(t)dt + \int_{\frac{1}{2}}^1 f^2(t)dt &amp;\le \int_0^{\frac{1}{2}} x\int_0^{\frac{1}{2}}f’^2(t)dt dx + \int_{\frac{1}{2}}^1 (1-x)\int_{\frac{1}{2}}^1 f’^2(t)dt dx \\ &amp;= \frac{1}{8}\int_0^{\frac{1}{2}}f’^2(t)dt + \frac{1}{8}\int_{\frac{1}{2}}^1 f’^2(t)dt = \frac{1}{8}\int_0^1 f’^2(t)dt \end{aligned} ]$</p><p>得证</p><h2 id="题目313">题目313</h2><p>$[ 设 f(x,y) = \begin{cases} \dfrac{y^2\sin x}{x^2 + y^2}, &amp; (x,y)\ne(0,0)\\ 0, &amp;(x,y)=(0,0) \end{cases}，则 f(x,y) 在 (0,0) 点处（ ） \~~\ \begin{matrix} (A) &amp;不连续 &amp; (B)&amp;连续但不可导 \\ © &amp;可导但不可微 &amp; (D) &amp;可微 \end{matrix} ]$</p><h3 id="解答-104">解答</h3><p>由我们熟知的 强弱 条件关系：一阶偏导数连续 &gt; 可微 &gt; 可导 &gt; 连续，从 弱到强 开始一个个验证</p><p>连续性：（连续性定义）</p><p>$[ \lim_{(x,y)\to(0,0)} \frac{y^2\sin x}{x^2 + y^2} = \lim_{(x,y)\to(0,0)} \frac{xy^2}{x^2 + y^2} ]$</p><p>这种情况直接考虑 常用不等式 进行 夹逼：</p><p>$[ x^2 + y^2 \ge 2xy \Rightarrow \frac{1}{x^2+y^2} \le \frac{1}{2xy} \Rightarrow 0 \le |\frac{xy^2}{x^2 + y^2}| \le 2|y| ]$</p><p>$故 (\lim\limits_{(x,y)\to(0,0)} \dfrac{y^2\sin x}{x^2 + y^2} = 0 = f(0,0) \quad \Rightarrow \quad f(x,y) 在 (0,0) 处连续)$</p><p>可导性：（偏导数定义）</p><p>$[ \frac{\partial f}{\partial x}\bigg|<em>{x=0} = \lim</em>{\Delta x\to 0} \frac{f(\Delta x,0) - f(0,0)}{\Delta x} = \lim_{\Delta x\to 0} \frac{0}{\Delta x} = 0 ]$</p><p>$[ \frac{\partial f}{\partial y}\bigg|<em>{y=0} = \lim</em>{\Delta y\to 0} \frac{f(0,\Delta y) - f(0,0)}{\Delta y} = \lim_{\Delta y\to 0} \frac{0}{\Delta y} = 0 ]$</p><p>故可偏导</p><p>可微性：（可微定义式）</p><p>$[ \lim\limits_{(\Delta x,\Delta y)\to(0,0)} \frac{f(\Delta x,\Delta y) - f(0,0) - 0 \cdot (\Delta x-0) - 0 \cdot (\Delta y - 0)}{\sqrt{\Delta x^2 + \Delta y^2}} = \lim\limits_{(\Delta x,\Delta y)\to(0,0)} \dfrac{\Delta y^2 \Delta x}{(\Delta x^2 + \Delta y^2)^{\frac{3}{2}}} ]$</p><p>$取 (\Delta y = k \Delta x) 的趋近方式：$</p><p>$[ \lim\limits_{\Delta x\to 0} \frac{k^2 \Delta x^3}{(1+k^2)^{\frac{3}{2}} \cdot \Delta x^3} = \frac{k^2}{(1+k^2)^{\frac{3}{2}}} ]$</p><p>$极限值 随 (k) 值变化而变化，不唯一$</p><p>于是由 极限 的 唯一性 可知，该 极限不存在，故该函数 不可微</p><p>$正确答案 为 C：可导但不可微$</p><h2 id="题目314">题目314</h2><p>$下列函数中，在 ((0,0)) 点可微的是（ ）$</p><p>$[ \begin{aligned} &amp;(A) f(x,y) = \sqrt{x^2+y^2} &amp;(B) g(x,y) = \begin{cases} \dfrac{xy}{x^2+y^2} &amp;(x,y)\ne(0,0) \ 0 &amp; (x,y) = (0,0) \end{cases} \\ &amp;© \varphi(x,y) = \begin{cases} \dfrac{xy}{\sqrt{x^2+y^2}} &amp; (x,y) \ne (0,0) \ 0 &amp; (x,y) = (0,0) \end{cases} &amp;(D) \psi(x,y) = \begin{cases} (x^2+y^2)\sin\dfrac{1}{x^2+y^2} &amp; (x,y) \ne (0,0) \ 0 &amp; (x,y) = (0,0) \end{cases} \end{aligned} ]$</p><h3 id="解答-105">解答</h3><p>首先读者必须知道 可微定义式，然后就是纯的 极限计算 了</p><p>可微定义式：</p><p>$[ \lim_{\begin{matrix} \Delta x \to 0\ \Delta y \to 0 \end{matrix}} \frac{f(x_0+\Delta x, y_0 + \Delta y) - f(x_0, y_0) - f_x’(x_0,y_0)(x-x_0) - f_y’(x_0,y_0)(y - y_0)}{\sqrt{(\Delta x)^2 + (\Delta y)^2}} ]$</p><p>$(A)<br>(f’<em>x(0,0) = \lim\limits</em>{x\to 0} \dfrac{|x|}{x}) 不存在，关于 (x) 不可导 (\Rightarrow) 不可微$</p><p>$(B)<br>在 ((0,0)) 点处 不连续，故 不可微$</p><p>$©<br>(f’_x(0,0) = f’_y(0,0) = 0)$</p><p>$[ \lim_{\begin{matrix} \Delta x \to 0\\ \Delta y \to 0 \end{matrix}} \frac{\Delta x \Delta y}{\Delta x^2 + \Delta y^2} ]$</p><p>$直接取 (\Delta y = k \Delta x) 即可证明该 极限不存在，故 不可微$</p><p>$(D)<br>(f’_x(0,0) = f’_y(0,0) = 0)$</p><p>$[ \lim_{\begin{matrix} \Delta x \to 0\\ \Delta y \to 0 \end{matrix}} \frac{(\Delta x^2 + \Delta y^2)\sin\dfrac{1}{\Delta x^2 + \Delta y^2}}{\sqrt{\Delta x^2 + \Delta y^2}} = 0 ]$</p><p>$故函数在 ((0,0)) 点处 可微$</p><p>正确答案（D）</p><h2 id="题目315">题目315</h2><p>$已知函数 (f(x,y)) 在 ((0,0)) 点的某邻域内有定义，则 (\lim\limits _{x\to0} f_x’(x,0) = f_x’(0,0))，(\lim\limits _{y\to0} f_y’(0,y) = f_y’(0,0)) 是 (f(x,y)) 在 ((0,0)) 点可微的（ ）条件$</p><h3 id="解答-106">解答</h3><p>首先我们要知道，可微的 充分条件 — 偏导数连续，他长这样：</p><p>$[ \begin{cases} \lim\limits_{(x,y)\to(x_0,y_0)} f_x’(x,y) = f_x’(0,0) \\ \lim\limits_{(x,y)\to(x_0,y_0)} f_y’(x,y) = f_y’(0,0) \end{cases} ]$</p><p>而题干里给的 一元函数极限 与 二元函数 可微 基本没有什么关系</p><p>充分性：</p><p>该条件显然推不出 偏导数连续，反例：</p><p>$[ f(x,y) = \begin{cases} a &amp; xy = 0,a \ne 0 \\ 0 &amp; xy \ne 0 \end{cases} ]$</p><p>$该函数在 (x/y) 轴上值为 (a)，其他位置为 (0)，显然在 ((0,0)) 点不连续，故不可微$</p><p>$但是，(\lim\limits _{x\to0} f_x’(x,0) = f_x’(0,0) = 0)，(\lim\limits _{y\to0} f_y’(0,y) = f_y’(0,0) = 0)$</p><p>故 不满足充分性</p><p>必要性：</p><p>可微只能给出一个可微定义式极限存在，和上面的极限没有任何关系</p><p>反例： 我们直接举一个 可微但偏导数不连续的例子</p><p>$[ f(x,y) = \begin{cases} (x^2+y^2)\sin\dfrac{1}{x^2 + y^2} &amp; (x,y) \ne (0,0)\\ 0 &amp; (x,y) = (0,0) \end{cases} ]$</p><p>$[ f’_x(x,0) = 2x\sin\frac{1}{x^2} -\frac{2}{x}\cos \frac{1}{x^2} \Rightarrow \lim\limits _{x\to0} f_x’(x,0) 不存在 ]$</p><p>故正确答案为：非充分非必要条件</p><h2 id="题目316">题目316</h2><p>$[ 设 z = \frac{x\cos(y - 1) - (y - 1)\cos x}{1 + \sin x + \sin(y - 1)}，求 \frac{\partial z}{\partial y} \bigg|_{(0,1)} ]$</p><h3 id="解答-107">解答</h3><p>计算题，直接套定义</p><p>$[ \begin{aligned} f’<em>y(0,1) &amp;= \lim</em>{\Delta y \to 0}\frac{\dfrac{- \Delta y}{1 + \sin(\Delta y)} - 0}{\Delta y} = \lim_{\Delta y \to 0}-\dfrac{1}{1 + \sin(\Delta y)} = -1 \end{aligned} ]$</p><h2 id="题目317">题目317</h2><p>$[ 已知f(x,y) = \begin{cases} xy\dfrac{x^2-y^2}{x^2+y^2} &amp;(x,y)\ne(0,0)\\ 0 &amp;(x,y) = (0,0) \end{cases} ，求f_{xy}‘’(0,0) \cdot f_{yx}‘’(0,0) ]$</p><h3 id="解答-108">解答</h3><p>$先写出 (f_{xy}(0,0)) 的 定义式，然后看 缺什么 就 求什么$</p><p>$[ f_{xy}(0,0) = \frac{f_x(0,y) - f_x(0,0)}{y} ]$</p><p>根据该定义式，求出其中的函数表达式：</p><p>$[ f_x(0,0) = \lim_{x\to 0} \frac{f(x,0) - f(0,0)}{x - 0} = 0 ]$</p><p>$[ f_x(0,y) = \lim_{x\to 0} \frac{f(x,y) - f(0,y)}{x - 0} = \lim_{x\to 0} y\dfrac{x^2-y^2}{x^2+y^2} = -\frac{y^3}{y^2} = -y ]$</p><p>$[ f_{xy}(0,0) = \frac{f_x(0,y) - f_x(0,0)}{y - 0} = \frac{-y}{y} = -1 ]$</p><p>$同理，镜像求出 (f_{yx}(0,0)):$</p><p>$[ f_y(0,0) = \lim_{x\to 0} \frac{f(0,y) - f(0,0)}{y - 0} = 0 ]$</p><p>$[ f_y(x,0) = \lim_{y\to 0} \frac{f(x,y) - f(x,0)}{y - 0} = \lim_{y\to 0} x\dfrac{x^2-y^2}{x^2+y^2} = x ]$</p><p>$[ f_{yx}(0,0) = \frac{f_y(x,0) - f_y(0,0)}{x - 0} = \frac{x}{x} = 1 ]$</p><p>综上：</p><p>$[ f_{xy}‘’(0,0) \cdot f_{yx}‘’(0,0) = -1 ]$</p><h2 id="题目318">题目318</h2><p>$[ 若 \frac{\partial^2z}{\partial x\partial y} = 1,且当 x = 0 时,z=\sin y;当y=0时,z=\sin x.求z(x,y) ]$</p><h3 id="解答-109">解答</h3><p>看到求一个 函数的表达式，那就是妥妥的 微分方程 了</p><p>$[ z_{xy} = 1 \Rightarrow \int z_{xy} dy = \int dy \Rightarrow z_x = y + \varphi(x) ]$</p><p>$[ \Rightarrow \int z_x dx = \int [y + \varphi(x)] dx \Rightarrow z = xy + \int \varphi(x) dx + \psi(y) ]$</p><p>然后代入特值，计算式子中的待定项即可：</p><p>$当 (x=0) 时：(z = \sin y = \psi(y))$</p><p>$当 (y=0) 时：(z = \sin x = \int \varphi(x)dx)$</p><p>$[ 故 z(x,y) = xy + \sin x + \sin y ]$</p><h2 id="题目319">题目319</h2><p>$[ 设可微函数 f(x,y) 满足 \frac{\partial f}{\partial x} = -f(x,y),f(0,\frac{\pi}{2}) = 1，\\ \quad \\ 且 \lim_{n\to\infty} \bigg[{ \frac{f(0,y+\dfrac{1}{n})}{f(0,y)} }\bigg]^n = e^{\cot y}，求 f(x,y) ]$</p><h3 id="解答-110">解答</h3><p>$要求函数 (f(x,y)) 的函数表达式，本题就是一个 微分方程 的问题$</p><p>$[ \frac{\partial f}{\partial x} = -f \Rightarrow \frac{\partial f}{f} = -1\partial x \Rightarrow \ln f = -x + C(y) \Rightarrow f = C_2(y)e^{-x} ]$</p><p>$现需要想办法把 (C_2(y)) 解出来，试试看处理其他条件$</p><p>$(f(0,\dfrac{\pi}{2}) = 1) 这样的初值条件，在微分方程里只能用于确定任意常数 (C)$</p><p>$[ \lim_{n\to\infty} \bigg[{ \frac{f(0,y+\dfrac{1}{n})}{f(0,y)} }\bigg]^n = e^{\lim\limits_{n\to \infty} n \cdot \frac{f(0,y+\frac{1}{n}) - f(0,y)}{f(0,y)}} = e^{\lim\limits_{n\to \infty} \frac{f(0,y+\frac{1}{n}) - f(0,y)}{\frac{1}{n}} \cdot \frac{1}{f(0,y)}} = e^{\frac{f_y(0,y)}{f(0,y)}} ]$</p><p>$故建立 微分方程：(\dfrac{f_y(0,y)}{f(0,y)} = \cot y \Rightarrow \dfrac{df}{f} = \cot ydy \Rightarrow \ln f = \ln(\sin y) + C_1)$</p><p>$这里由于 (x=0) 故直接当成 一元函数 一阶导 来处理$</p><p>$得：(f(0,y) = C_1 \cdot (\sin y))$</p><p>$代入初值 (f(0,\dfrac{\pi}{2}) = 1) 得：(1 = C_1 \cdot 1 \Rightarrow C_1 = 1 \Rightarrow f(0,y) = \sin y)$</p><p>$代入(f(0,y)=\sin y) 得：(\sin y = C_2(y))$</p><p>$故 (f(x,y) = \sin y \cdot e^{-x})$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第288-303题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC288-303%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC288-303%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目288">题目288</h2><p>$设函数 (f(x)) 在 ((-\infty,+\infty)) 上二阶可导，且 (f’‘(x)\ne0)，(\lim\limits_{x\to\infty}\dfrac{\sqrt{x^2-x+1}}{xf’(x)}=\alpha&gt;0)$，$且存在一点 (f(x_0)&lt;0). 证明方程 (f(x)=0) 在 ((-\infty,+\infty)) 上恰有两个实根$</p><h3 id="解答-64">解答</h3><p>$夹逼 ：(\text{最优解} \ge \text{贪心解}  \text{最优解} \le \text{贪心解} \Rightarrow \text{最优解} = \text{贪心解})$</p><p>$根据昨天证明的 罗尔原话，(f’'(x)\ne0 \Rightarrow f(x)\text{至多2个根})$</p><p>$然后我们分类讨论极限趋于 正无穷 和 负无穷 两种情况即可：$</p><p>$当 (x \to +\infty) 时：$</p><p>$(\lim\limits_{x\to+\infty}\dfrac{\sqrt{x^2-x+1}}{xf’(x)}= \lim\limits_{x\to+\infty}\dfrac{1}{f’(x)}=\alpha&gt;0)$</p><p>$故根据 极限的保号性：(\exists X_1 &gt; 0)，当 (x &gt; X_1) 时，恒有 (f’(x) &gt; \dfrac{1}{2\alpha} &gt; 0)$</p><p>$而我们要的是 (f(x)) 不是 (f’(x))，故想到 拉格朗日中值定理 建立 (f) 与 (f’) 的关系$</p><p>$(\exists \xi \in(X_1, x),~~s.t.\ f(x) = f(X_1) + f’(\xi)(x - X_1) &gt; f(X_1) + \dfrac{1}{2\alpha}(x-X_1) = \text{常数} + \text{常数} \times \text{(无穷大 - 常数)} \to \infty)$</p><p>$故 (\lim\limits_{x\to+\infty}f(x) = +\infty &gt; 0)$</p><p>$同理可证：当 (x \to -\infty) 时，(\lim\limits_{x\to-\infty}f(x) = +\infty &gt; 0)$</p><p>$因 (f(-\infty) &gt; 0, f(x_0) &lt; 0, f(+\infty) &gt; 0)$</p><p>$由 零点定理的推广定理 可知，至少存在两点 (\zeta_1\in (-\infty,x_0), \zeta_2\in(x_0,+\infty), s.t. f(\zeta_1) = f(\zeta_2) = 0)$</p><p>$由 (\text{零点个数} \ge 2 ~~ \text{零点个数} \le 2 \Rightarrow \text{零点个数} = 2)$</p><p>$得证$</p><h2 id="题目289">题目289</h2><p>$设函数 (f(x)) 在区间 ([-2,2]) 上可导，且 (f’(x)&gt;f(x)&gt;0)，则（ ）$</p><p>$（A）(\dfrac{f(-2)}{f(-1)}&gt;1) （B）(\dfrac{f(0)}{f(-1)}&gt;e)   $<br>$（C）(\dfrac{f(1)}{f(-1)}&lt;e^2) （D）(\dfrac{f(2)}{f(-1)}&lt;e^3)$</p><h3 id="解答-65">解答</h3><p>$题目给出了 (f) 与 (f’)的 大小关系，为了利用该 关系 建立 不等式，立刻就想到了 中值定理$</p><p>$插一句，这种给定 不等式关系 的题目，(80%) 最后都是利用 不等号方向 把某 余项 放缩掉，这个思想很重要$</p><p>$首先排除 罗尔定理，因为题目中没有明确给出相等的两点；而 泰勒中值 一般用于高阶，有些牛刀杀鸡的意思$</p><p>$那么还剩下 柯西中值 和 拉格朗日中值 了。A选项 可以用 拉格朗日中值 快速判断出答案：$</p><p>$(f(-1) - f(-2) = f’(\xi_1) &gt; 0) ，故 (f(-1) &gt; f(-2) &gt; 0 \Rightarrow \dfrac{f(-2)}{f(-1)} &lt; 1) 故A错误$</p><p>但是后三个不太行，通过观察发现右侧是一个同样在 随参数变化 的 指数函数，因此我们考虑构造 辅助函数</p><p>$B：(\dfrac{e^0 \cdot f(0)}{e^{-1} \cdot f(-1)}&gt;1) 。令 (F(x) = e^x \cdot f(x))，再对 (F(x)) 使用 拉格朗日中值定理 即可：$</p><p>$(F(0) = F(-1) + F’(\xi_2) &gt; F(-1) \Rightarrow \dfrac{F(0)}{F(-1)} &gt; 1 \Rightarrow \dfrac{e^0 \cdot f(0)}{e^{-1} \cdot f(-1)}&gt;1 \Rightarrow \dfrac{f(0)}{f(-1)} &gt; e) 故 B 正确$</p><p>$(F(1) = F(-1) + F’(\xi_3) &gt; F(-1) \Rightarrow \dfrac{F(1)}{F(-1)} &gt; 1 \Rightarrow \dfrac{e^1 \cdot f(1)}{e^{-1} \cdot f(-1)}&gt;1 \Rightarrow \dfrac{f(1)}{f(-1)} &gt; e^2) 故 C 错误$</p><p>$(F(2) = F(-1) + F’(\xi_4) &gt; F(-1) \Rightarrow \dfrac{F(2)}{F(-1)} &gt; 1 \Rightarrow \dfrac{e^2 \cdot f(2)}{e^{-1} \cdot f(-1)}&gt;1 \Rightarrow \dfrac{f(2)}{f(-1)} &gt; e^3) 故 D 错误$</p><p>$综上，正确的选项为 B$</p><h2 id="题目290">题目290</h2><p>$已知常数 (k\ge \ln2 - 1)，证明：((x-1)(x-\ln^2 x+2k\ln x-1)\ge0)$</p><h3 id="解答-66">解答</h3><p>$微分不等式 的题目都是套路，按照套路一步步做就好了$</p><p>$观察到不等式左边是两个因式积的形式，直接乘开不好做，故我们分类讨论即可：$</p><p>$1.(x\gt 1) 时：$</p><p>$令 (f(x) = x-\ln^2 x+2k\ln x-1)，$</p><p>$则 (f’(x)=1-\dfrac{2\ln x}{x} + \dfrac{2k}{x} = \dfrac{x-2\ln x + 2k}{x})$</p><p>$令 (g(x) = x - 2\ln x + 2k)，则 (g’(x) = \dfrac{x-2}{x} \xlongequal{令}0)，得：(g’(2) = 0)$</p><p>$故 (g(x)) 在 (x=2) 取极小值，(g(2) = 2\cdot \big[k-(\ln 2 - 1)\big] \ge 0)$</p><p>$(\Rightarrow f’(x) \ge 0 \Rightarrow f(x) \text{单调递增} \Rightarrow (x-1)f(x)\text{单调递增})$</p><p>$2.(0 \lt x\lt 1) 时：$</p><p>$同理可证得 ((x-1)f(x)\text{单调递减})$</p><p>$由 极值的定义 可知，((x-1)f(x)) 在 (x=1) 取极小值，且该 局部极小值 为 全局最小值$</p><p>$(\bigg[(x-1)f(x)\bigg]_{min} = \bigg[(1-1)f(1)\bigg] = 0 \Rightarrow (x-1)(x-\ln^2 x+2k\ln x-1)\ge0)$</p><h2 id="题目291">题目291</h2><p>$设函数 (f(x)) 二阶可导，(f(0)=1, f’(0)=0)，且对任意 (x\ge0) 有$</p><p>$(f’‘(x)-5f’(x)+6f(x)\ge0)，证明不等式 (f(x)\ge3e^{2x}-2e^{3x},(x\ge0))$</p><h3 id="解答-67">解答</h3><p>微分不等式，套路题</p><p>$构造辅助函数 (F(x)=f(x)-3e^{2x}+2e^{3x})，(F(0) = 0)$</p><p>$则：(F’(x) = f’(x)-6e^{2x}+6e^{3x})，(F’(0) = 0)$</p><p>$则：(F’‘(x)=f’'(x)-12e^{2x} + 18e^{3x})，利用题目中最后给的不等式，有：$</p><p>$[ F’‘(x)-5F’(x)+6F(x)=f’‘(x)-5f’(x)+6f(x)\ge0 ]$</p><p>$故 (F’(x) \ge 0 \quad\Rightarrow\quad F(x)\ge 0 \quad\Rightarrow\quad f(x) \ge 3e^{2x}-2e^{3x})$</p><h2 id="题目292">题目292</h2><p>$证明不等式：(\bigg|{ \dfrac{\sin x - \sin y}{x - y} - \cos y }\bigg| \le \dfrac{1}{2} |x - y|\quad(x \ne y))$</p><h3 id="解答-68">解答</h3><p>看到有碍眼的 绝对值 ，在不等式的证明中，常见的去绝对值的方法有 绝对值不等式</p><p>$但是本题 (x,y) 都是参数，且满足 (x\ne y)，因此我们不妨设 (x&gt;y)：$</p><p>$[ \begin{aligned} \bigg|\frac{\sin x - \sin y}{x - y} - \cos y\bigg| &amp;\le \frac{1}{2}(x-y) \\ \sin x - \sin y - \cos y(x - y) &amp;\le \frac{1}{2}(x-y)^2 \end{aligned} ]$</p><p>$常见的微分不等式处理两个参数时，可以把另一个给令成变量 (x) 然后求导找单调性$</p><p>$但是本体做不了，不过通过观察，我们发现化简后的不等式中出现了 泰勒展开 的形式$</p><p>$考虑把 (\sin x) 在 (x=y) 处展开：(\sin x = \sin y + \cos x(x-y)-\dfrac{\sin y}{2}(\xi-y)^2)$</p><p>$化简不等式左侧：(-\dfrac{\sin y}{2}(\xi-y)^2)$</p><p>$由于 (-1 \le \sin y \le 1)，故 (-\dfrac{1}{2}(\xi-y)^2\le -\dfrac{\sin y}{2}(\xi-y)^2\le\dfrac{1}{2}(\xi-y)^2)$</p><p>$又 (y &lt; \xi &lt; x)，故 (-\dfrac{\sin y}{2}(\xi-y)^2\le\dfrac{1}{2}(\xi-y)^2 \lt \dfrac{1}{2}(x-y)^2)$</p><p>得证</p><p>$做到这里一看，前面去绝对值的操作挺多余的，本题核心还是同乘 (x-y) 化简$</p><h2 id="题目293">题目293</h2><p>$设函数 (f(x)=\int_1^xe^{t^2}dt)$</p><p>$证明：存在 (\xi\in(1,2)，s.t. f(\xi)=(2-\xi)e^{\xi^2})$</p><p>$证明：存在 (\eta\in(1,2)，s.t. f(2)=\ln 2 \cdot \eta e^{\eta^2})$</p><h3 id="解答-69">解答</h3><p>$中值定理的题干中给出了 (f(x)) 的积分形式，那么这题一般是要用到 积分中值定理 的$</p><p>$构造 (F(x) = f(x) - (2-x)e^{x^2})，则 (F(1) = -e &lt; 0，F(2)=\int_1^2e^{t^2}dt &gt; 0)$</p><p>$由 零点定理 可知：(\exists \xi\in(1,2), s.t. F(\xi)=0)，即 (f(\xi)=(2-\xi)e^{\xi^2}) 得证$</p><p>$对 (f(2)) 使用 积分中值定理：(\exists \zeta \in(1,2),s.t.f(2)=e^{\zeta^2})$</p><p>$构造 (G(x) = e^{\zeta^2} - \ln 2 \cdot x \cdot e^{x^2})$</p><p>$则 (G(1) = e^{\zeta^2} - \ln 2 e^1 = e\cdot [e^{\zeta^2 - 1} - \ln 2] &gt; 0)$</p><p>$又 (G(2) = e^{\zeta^2} - 2\ln 2 e^2 = e^2\cdot [e^{\zeta^2 - 2} - \ln 4] &lt; 0)$</p><p>$故，由 零点定理 可知，(\exists \eta\in(1,2)，s.t.f(2)=\ln 2 \cdot \eta e^{\eta^2})$</p><p>看了一下武老师的方法，先把右侧除到左侧做一次恒等变形，如下：</p><p>$(\dfrac{f(2)}{\eta}=\ln 2 \cdot f’(\eta))，故可构造 (F(x) = f(2)\ln x - \ln 2 \cdot f(x))$</p><p>$则 (F(1) = F(2) = 0 \Rightarrow F’(\eta) = 0) （罗尔定理）$</p><p>武老师的 方法二 是把常数放一边，变量放另一边（这个思想很重要！！），如下：</p><p>$(\dfrac{f(2)}{\ln 2} = \dfrac{f’(\eta)}{\dfrac{1}{\eta}})，故可构造 (F(x) = \dfrac{f(x)}{\ln x})，则由 柯西中值定理： (\dfrac{f(2) - f(1)}{\ln 2 - \ln 1} = \dfrac{f’(\eta)}{\dfrac{1}{\eta}})$</p><p>中值定理的证明题，一题有多解，个人建议做题时每一中都要学会，思想很重要</p><h2 id="题目294">题目294</h2><p>$已知函数 (f(x)) 在 ([0,1]) 上具有二阶导数，且 (f(0)=0,f(1)=1),(\int_0^1 f(x)dx = 1)$</p><p>$证明： 1. 存在 (\xi \in(0, 1),s.t.f’(\xi)=0) 2. 存在 (\eta\in(0, 1),s.t.f’'(\eta)\le -2)$</p><h3 id="解答-70">解答</h3><p>$第一问还是比较裸的送分题，既然要 估计 出 一阶导数 为(0)的，那么必然想到了 罗尔定理$</p><p>$由于 (f(0)=0,f(1)=1,\int_0^1f(x)dx=1)，设(M)为(f(x))在((0,1))上的最大值$</p><p>$故 (\exists \xi\in(0,1),s.t.f(\xi)=M)（最值不在端点处取到，则一定在区间内部的极值处取到）$</p><p>$由 费马引理： (f’(\xi)=0) 得证$</p><p>$第二问牵扯到了高阶导数，一般用 泰勒中值 来做$</p><p>$考虑 展开点 的问题，这题 泰勒 要展开到 2阶，故 一阶导数 是要想办法 消掉 的$</p><p>$而第一问中求出的 (f’(\xi)=0) 就可以很好的接上了，因此选取 端点 在 (x=\xi) 展开$</p><p>$(f(x)=f(\xi) + f’(\xi)(x-\xi) + \dfrac{f’‘(\zeta)}{2}(x-\xi)^2 ~\Rightarrow~ f’'(\zeta) = 2\cdot \dfrac{f(x)-f(\xi)}{(x-\xi)^2})$</p><p>$令 (x=0) 可得：(f’'(\zeta) = \dfrac{-2M}{\xi^2}\le -2)$</p><p>$故 (\exists \eta\in(0,\xi)\subset(0,1),s.t.f’'(\eta)\le -2)$</p><p>第二问的辅助多项式解法<br>$令 (F(x) = f(x) - (ax^2+bx+c))，代入给个点的值：$</p><p>令$ \begin{cases} F(0)=-c = 0 \ F(1)=1-(a+b+c) = 0 \ _0^1F(x)dx = _0^1f(x)dx - - = 0 \end{cases} $</p><p>$以上不应该出现在答题纸上，这些是草稿纸上的步骤$</p><p>$解得：(F(x) = f(x)+3x^2-4x)$</p><p>$则 (F(0)=F(1)= F(x_0)=0 \quad(\text{其中}x_0\in(0, 1))) (积分中值定理)$</p><p>$连续使用 罗尔定理 可得：$</p><p>$(\exists \xi_1\in(0, x_0),s.t.F’(\xi_1)=0)$</p><p>$(\exists \xi_2\in(x_0, 1),s.t.F’(\xi_2)=0)$</p><p>$(\exists \xi\in(\xi_1, \xi_2),s.t.F’'(\xi)=0)$</p><p>$故：(f’'(x)=-6\le -2) 得证$</p><h2 id="题目295">题目295</h2><p>$设 (f(x)) 在 ([0,1]) 上二阶可导，且 (\lim\limits_{x\to0^+}\dfrac{f(x)}{x}=2,\int_0^1f(x)dx=1)$</p><p>$试证： 1. 存在 (\xi\in(0,1), s.t.f’(\xi)=f(\xi)-2\xi+2) 2. 存在 (\eta\in(0,1),s.t.f’'(\eta) = 0) 3. 存在 (\zeta\in(0,1),s.t.\int_0^\zeta f(t)dt+\zeta f(\zeta) = 2\zeta) 4. 存在 (\mu\in(0,1),s.t.\mu f(\mu)=2\int_0^\mu f(t)dt)$</p><h3 id="解答-71">解答</h3><p>这是一场 构造题专场，四个问完全不相干，每一题都要构造一个新的辅助函数，就当加深一下思维了</p><p>$由题干可以简单得出的几个条件：(f(0)=0,f’(0)=2,f(x_0)=0\quad(0&lt;x_0&lt;1))$</p><p>第一问<br>$证明的等式中出现了：(g’(x)-g(x)) 得形式，故构造辅助函数 (F(x) = \big(f(x)-2x\big) e^{-x})$</p><p>$则 (F’(x) = e^{-x}\cdot\Big({f’(x)-2-f(x)+2x}\Big))$</p><p>$又 (\int_0^1F(x)e^xdx = 0 \Rightarrow F(x_1) = 0) （积分中值定理，其中(x_1\in(0,1))）$</p><p>$故由 (F(0) = F(x_1)=0 \Rightarrow F’(\xi) = e^{-\xi}\cdot \Big(f’(\xi)-f(\xi)+2\xi-2\Big) = 0)$</p><p>$(罗尔定理) 其中 (\xi \in (0, x_1)\subset (0, 1)) 故得证$</p><p>第二问<br>$这一问可以直接借助上一问的辅助函数继续操作：(F’(0)=F’(\xi) = 0 \Rightarrow F’'(\eta) = 0)$</p><p>$（罗尔定理）其中 (\eta\in(0,\xi)\subset(0,1)) 故得证$</p><p>第三问<br>$看到等式左边出现了 (u’v+uv’) 的形式，故考虑用 乘积的求导公式 还原原函数$</p><p>$构造辅助函数：(G(x) = x\int_0^xf(t)dt - x^2)，则 (G’(x) = \int_0^xf(t)dt - xf(x) - 2x)$</p><p>$由 (G(0)=G(1)=0 \Rightarrow G’(\xi)=0)（罗尔定理）其中 (\xi\in(0, 1)) 故得证$</p><p>第四问<br>$看到有 (u’v - uv’) 的形式，故考虑用 商的求导公式 还原原函数$</p><p>$构造辅助函数：(H(x) = \dfrac{\int_0^2f(t)dt}{x^2})，则 (H’(x) = \dfrac{xf(x)-2\int_0^xf(t)dt}{x^3})$</p><p>$由于该函数在 (x = 0) 处没有定义，故我们需要进行补充定义：(H(x) = \begin{cases} 1 &amp; x = 0\ \dfrac{\int_0^2f(t)dt}{x^2} &amp; 0 &lt; x &lt; 1 \end{cases})$</p><p>$则 (H(0) = H(1) = 1 \Rightarrow H’(\mu) = 0) （罗尔定理）其中 (\mu\in(0,1)) 故得证$</p><h2 id="题目296">题目296</h2><p>$设 (f(x)) 在 ([0,1]) 上连续，在 ((0,1)) 内可导，且 (f(0)=1,f(1)=0)$</p><p>$证明： 1. 存在两个不同的点 (\xi_1,\xi_2\in(0,1),s.t.f’(\xi_1)+f’(\xi_2)=-2) 2. 存在两个不同的点 (\eta,\zeta\in(0,1),s.t.f’(\eta)f’(\zeta)=1)$</p><h3 id="解答-72">解答</h3><p>本题为中值定理中的一类经典模型：双中值问题</p><p>解决方法也很简单，那就是 拆分区间，然后分别在两个区间上进行 区间估计</p><p>要把区间拆分成什么样，一开始我们是不知道了，因此需要从答案入手开始尝试试出来</p><p>$先不妨令该拆分点为 (x(0&lt;x&lt;1))，则分别两左右两个区间上使用 拉格朗日中值定理 可得：$</p><p>$[ \begin{cases} f(x)-1=f’(\xi_1)\cdot x\\ -f(x)=f’(\xi_2)\cdot (1 - x) \end{cases} ]$</p><p>$将两者加起来可得：(f’(\xi_1)+f’(\xi_2)=\dfrac{f(x)-1}{x}+\dfrac{-f(x)}{1-x})$</p><p>$为了让 右式 与原题中的 (-2) 对应上，观察可得 分子 若 直接相加，和为 常数 (1)$</p><p>$假使 分母 能够 相等 且为 (\dfrac{1}{2}) ，那么这题将绝杀$</p><p>$经过观察发现是这样的，令 (x = 1-x \Rightarrow x = \dfrac{1}{2}) 这样第一问分析就结束了（以上步骤只出现在草稿纸上）$</p><p>答题纸上的步骤：</p><p>$在区间 ([0,\dfrac{1}{2}]) 上使用 (Lagrange) 中值定理：(\exists\xi_1\in(0,\dfrac{1}{2}),s.t. f’(\xi_1) = \dfrac{f(\frac{1}{2}) - 1}{\frac{1}{2}})$</p><p>$在区间 ([\dfrac{1}{2},1]) 上使用 (Lagrange) 中值定理：(\exists\xi_2\in(\dfrac{1}{2},1),s.t. f’(\xi_2) = \dfrac{-f(\frac{1}{2})}{\frac{1}{2}})$</p><p>$则 (f(\xi_1)+f(\xi_2)= -2) 得证$</p><p>第二问解答<br>$同样是 双中值问题，因此我们继续沿用上一问分析中的等式：$</p><p>$[ \begin{cases} f(x)-1=f’(\xi_1)\cdot x\\ -f(x)=f’(\xi_2)\cdot (1 - x) \end{cases} ]$</p><p>$则 (f’(\xi_1)\cdot f’(\xi_2) = \dfrac{f(x)-1}{x} \cdot \dfrac{f(x)}{x - 1})$</p><p>$为了让 右式 与原题中的 (1) 对应上，观察可得我们需要该 乘积 中的 分子分母 互相 抵消$</p><p>$该等式 非常不好看，我们试着 交换 他们的分子分母，把 同形式 的放在一起（常用手段，相同系数/形式放一起）$</p><p>$(f’(\xi_1)\cdot f’(\xi_2) = \dfrac{f(x)-1}{x - 1} \cdot \dfrac{f(x)}{x})$</p><p>$这样秒观察出来，我们需要找的点，就是满足 (f(x)=x) 的点 (以上为分析步骤，只出现在草稿纸上)$</p><p>答题纸上的步骤：</p><p>$构造辅助函数： (F(x) = f(x)-x)，则 (F(0)=1&gt;0, F(1)=-1 &lt; 0)$</p><p>$故由 零点定理 可知，(\exists x\in(0,1),s.t.F(x) = 0 \Rightarrow f(x) = x)$</p><p>$在区间 ([0,x]) 上使用 (Lagrange) 中值定理：(\exists\eta\in(0,x),s.t. f’(\eta) = \dfrac{x - 1}{x})$</p><p>$在区间 ([x,1]) 上使用 (Lagrange) 中值定理：(\exists\zeta\in(x,1),s.t. f’(\zeta) = \dfrac{-x}{1-x})$</p><p>$则 (f’(\eta)f’(\zeta)=1) 得证$</p><h2 id="题目297">题目297</h2><p>$设 (f(x)) 在 ([0,1]) 上连续，且 (\int_0^1 f(x)dx = I \ne 0)$</p><p>$证明：存在两个不同的点 (\xi,\eta\in(0,1), s.t. \dfrac{1}{f(\xi)}+\dfrac{1}{f(\eta)}=\dfrac{2}{I})$</p><h3 id="解答-73">解答</h3><p>$就是普通的 双中值问题 套皮套了个积分，我们构造 变上限积分 再把他看作 原函数 就是 裸题 了$</p><p>$令 (F(x) = \int_0^x f(t)dt)，则 (F(1)=I\ne0)$</p><p>分析步骤：</p><p>双中值问题，无外乎就是在原始区间上找到一个 分割点，然后在分割点 左右两侧 分别进行 中值估计</p><p>$但一开始我们并不知道 分割点 的具体数值，故把它设成参数 (x) 进行估计，然后在结论中找出关系$</p><p>$拉格朗日中值定理：(\dfrac{x}{F(x)} - \dfrac{1-x}{I-F(x)} = \dfrac{2}{I})$</p><p>经过简短观察，我们有两种方案：</p><p>$两个分式单独处理（分子分母相消）：(F(x)=x)，这样 左式 (=1 - 1 = 0) 等式不成立$<br>$两个分式一起处理（两个分母相等）：(F(x) = I - F(x))，这样 左式 $= = $ 右式 等式成立$<br>$故，我们要找的 分割点 满足：(F(x) = \dfrac{I}{2}) 即可$</p><p>分析完毕</p><p>$(F(0)=0 <s>&amp;</s> F(1)=I\ne 0 <s>&amp;</s> F(x)\text{连续可导} \Rightarrow \exists c\in(0,1), s.t. F© = \dfrac{I}{2}) （连续函数的介值定理）$</p><p>$由 (Lagrange) 中值定理：$</p><p>$(\exists \xi\in(0,c)\subset(0,1),s.t. f(\xi) = \dfrac{I}{2c})$</p><p>$(\exists \eta\in(c,1)\subset(0,1),s.t. f(\eta) = \dfrac{I}{2-2c})$</p><p>$则 (\dfrac{1}{f(\xi)}+\dfrac{1}{f(\eta)}= \dfrac{2c}{I} + \dfrac{2 - 2c}{I} = \dfrac{2}{I}) 得证$</p><h2 id="题目298">题目298</h2><p>求不定积分 $(\int x\arctan x \cdot \ln(1+x^2)dx)$</p><h3 id="解答-74">解答</h3><p>分部积分 + 凑微分法小技巧</p><p>$[ \begin{aligned} &amp;\int x\arctan x \cdot \ln(1+x^2)dx \\ =&amp; \frac{1}{2}\int \arctan x \cdot \ln(1+x^2)d(1+x^2) \\ =&amp; \frac{1}{2} \arctan x \cdot \ln(1+x^2) (1+x^2) - \frac{1}{2}\int (1+x^2) \cdot (\frac{\ln(1+x^2)}{1+x^2} + 2x \cdot \frac{\arctan x}{1+x^2})dx\\ =&amp; \frac{1}{2} \arctan x \cdot \ln(1+x^2) (1+x^2) - \frac{1}{2} \int (\ln(1+x^2) + 2x \arctan x)dx\\ &amp; \int x\arctan x dx = \frac{1}{2}\int \arctan x d(x^2+1) = \frac{1}{2}(x^2+1)\arctan x - \frac{1}{2}x + C_1\\ &amp; \int \ln(x^2+1)dx = x\ln(1+x^2) - 2\int \frac{x^2}{x^2+1}dx \\ &amp; \int \frac{x^2}{x^2+1}dx = x - \int\frac{1}{x^2+1}dx = x - \arctan x + C_2 \\ &amp; \int \ln(x^2+1)dx =x\ln(1+x^2) - 2x + 2\arctan x + C_3 \\ &amp; \int x\arctan x \cdot \ln(1+x^2)dx \\ =&amp; \frac{1}{2} \arctan x (1+x^2)\ln(1+x^2) - \frac{1}{2}x\ln(1+x^2)-\arctan x - \frac{1}{2}(x^2+1)\arctan x + \frac{3}{2}x + C \end{aligned} ]$</p><h2 id="题目299">题目299</h2><p>$[\text{求不定积分}\int\dfrac{\sqrt{x-1}\arctan\sqrt{x-1}}{x}dx]$</p><h3 id="解答-75">解答</h3><p>换元用于打开局面，首要目标是先去掉根号，因此直接对整个根号进行换元</p><p>$令 (\sqrt{x-1} = t)，则原式为化为：$</p><p>$[ \begin{aligned} &amp; \int\dfrac{\sqrt{x-1}\arctan\sqrt{x-1}}{x}dx\\ =&amp; \int\dfrac{t\arctan t}{t^2 - 1} 2tdt\\ =&amp; 2\int\dfrac{t^2 \arctan t}{t^2-1} dt\\ =&amp; 2\int\dfrac{(t^2+1-1)\arctan t}{t^2-1} dt\quad(\text{假分式化简})\\ =&amp; 2\int\arctan tdt - \int\frac{\arctan t}{t^2-1}dt\\ =&amp; 2\bigg({ t\arctan t - \frac{1}{2}\int\frac{1}{1+t^2}d(t^2+1) }\bigg) - 2\int\arctan t d(\arctan t) \\ =&amp; 2t\arctan t - \ln(t^2 + 1) - \arctan^2 t + C \\ =&amp; 2\sqrt{x-1}\arctan\sqrt{x-1} - \ln x - \arctan^2\sqrt{x - 1} + C \end{aligned} ]$</p><h2 id="题目300">题目300</h2><p>$[ \text{求不定积分} \int \frac{\cos^3 x - 2 \cos x}{ 1 + \sin^2 x +\sin^4 x} dx ]$</p><h3 id="解答-76">解答</h3><p>$(f(\sin x, -\cos x) = -f(\sin x, \cos x))，故我们可以把 (\cos x) 凑微分变成 (d\sin x)$</p><p>$[ \begin{aligned} &amp; \int \frac{\cos^3 x - 2 \cos x}{ 1 + \sin^2 x +\sin^4 x} dx \\ =&amp; -\int \frac{1 + \sin^2 x}{1 + \sin^2x + \sin^4 x} d\sin x \\ =&amp; -\int \frac{u^2 + 1}{u^4 + u^2 + 1} du \quad\text{(这是一个经典的有理式不定积分，需要背过做法)}\\ =&amp; -\int \frac{1 + \dfrac{1}{u^2}}{u^2 + 1 + \dfrac{1}{u^2}} du\\ =&amp; -\int \frac{1}{(u-\dfrac{1}{u})^2 + 3} d(u - \frac{1}{u})\\ =&amp; -\arctan \frac{u - \dfrac{1}{u}}{\sqrt{3}} + C\\ =&amp; -\frac{1}{\sqrt{3}}\arctan \frac{\sin x - \dfrac{1}{\sin x}}{\sqrt{3}} + C \end{aligned} ]$</p><h2 id="题目301">题目301</h2><p>$[ \text{求定积分} \int_0^{+\infty}\frac{1}{(1 + x^2)(1+x^4)}dx ]$</p><h3 id="解答-77">解答</h3><p>法一（三角换元、切割化弦、区间再现）<br>$[ \begin{aligned} &amp;\int_0^{+\infty}\frac{1}{(1 + x^2)(1+x^4)}dx \\ =&amp;\int_0^{\frac{\pi}{2}}\frac{1}{\sec^2 t (1+\tan^4 t)} \sec^2 t dt \\ =&amp;\int_0^{\frac{\pi}{2}}\frac{1}{1+\tan^4 t} dt \\ =&amp;\int_0^{\frac{\pi}{2}}\frac{\cos^4 t}{\cos^4 t + \sin^4 t} dt \\ =&amp;\frac{1}{2}\int_0^{\frac{\pi}{2}}\frac{\cos^4 t + \sin^4 t}{\cos^4 t + \sin^4 t} dt \quad(\text{区间再现})\\ =&amp;\frac{\pi}{4} \end{aligned} ]$</p><p>法二（倒代还、广义区间再现）<br>$[ \begin{aligned} &amp;\int_0^{+\infty}\frac{1}{(1 + x^2)(1+x^4)}dx \\ =&amp;\int_0^{+\infty}\frac{t^4}{(1 + t^2)(1+t^4)}dt \\ =&amp;\frac{1}{2}\int_0^{+\infty}\frac{t^4 + 1}{(1 + t^2)(1+t^4)}dt \\ =&amp;\frac{1}{2}\int_0^{+\infty}\frac{1}{1 + t^2}dt \\ =&amp;\frac{1}{2} \arctan t \bigg|_0^{+\infty} \\ =&amp;\frac{\pi}{4} \end{aligned} ]$</p><h2 id="题目302">题目302</h2><p>$[ \text{已知} \int_0^{+\infty}\dfrac{\ln(1+x)}{x^\alpha}dx \text{收敛，求} \alpha \text{的取值范围} ]$</p><h3 id="解答-78">解答</h3><p>$[ \text{已知} \int_0^{+\infty}\dfrac{\ln(1+x)}{x^\alpha}dx \text{收敛，求} \alpha \text{的取值范围} ]$</p><p>解答<br>判别 反常积分 的方法，就是找出他在 瑕点 处的 阶，然后与已知结论 p积分 作比较</p><p>经过简单观察发现，该反常积分的 瑕点 有两个：</p><p>$一个是被积函数的 无定义点 (x=0)$<br>$一个是广义瑕点 (x = +\infty)$<br>$我们可以任意选择一个 (x_0\in(0,+\infty)) 把该反常积分用 区间可拆性 拆开，然后分别讨论 瑕点$</p><p>$[ \int_0^{+\infty}\dfrac{\ln(1+x)}{x^\alpha}dx = \int_0^{x_0}\dfrac{\ln(1+x)}{x^\alpha}dx + \int_{x_0}^{+\infty}\dfrac{\ln(1+x)}{x^\alpha}dx ]$</p><p>$(x\to0) 时：$</p><p>$[ \frac{\ln(1+x)}{x^\alpha} \sim \frac{1}{x^{\alpha-1}} ]$</p><p>由 p积分 的结论可知，若该反常积分收敛，则 $(\alpha - 1 &lt; 1 \Rightarrow \alpha &lt; 2)$</p><p>$(x\to+\infty) 时：$</p><p>$[ \frac{\ln(1+x)}{x^\alpha} \rightarrow \frac{1}{x^{\alpha}} ]$</p><p>$由 p积分 的结论可知，若该反常积分收敛，则 (\alpha &gt; 1)$</p><p>$这里做题多了，直接看出来的，因为 (对数函数 &lt;&lt; 幂函数 &lt;&lt; 指数函数) 是一个数学常识$</p><p>$如果想要严格证明也很简单，直接取 (x^c(c&gt;1))，然后把被积函数拆成 (\dfrac{\ln(1+x)}{x^{c-(1+\epsilon)}} \cdot \dfrac{1}{x^{(1+\epsilon)}})$</p><p>$其中 (\epsilon \to 0^+)，这样左侧是一个熟悉的收敛的函数，右侧是一个更熟悉的常见 p积分，根据 p积分 结论判别即可$</p><p>综上所述，$(\alpha \in (1, 2))$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第272-287题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC272-287%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC272-287%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目272">题目272</h2><p>$设 (y=y(x)) 由 (e^y\sin t - y + 1 = 0) 和 (x = \begin{cases} \dfrac{e^t-1}{t} &amp; t \ne 0 \\ 1 &amp; t = 0 \end{cases}) 所确定，求 (\dfrac{d^2y}{dx^2}\bigg|_{t=0})$</p><h3 id="解答-48">解答</h3><p>$参数方程 + 隐函数 求 具体某一点的二阶导数值 考虑直接代公式$</p><p>$接下来的问题是求出 (y,x) 在 (x=0) 处的 一阶 和 二阶 导数值 即可$</p><p>$对于 (y) 我们直接用隐函数求导法则，方程两侧连续求导代入即可（过程就不写了，直接上答案）$</p><p>$对于 (x) 我是 跨阶凑导数定义 ，武老师 是用的 泰勒展开，我这里直接用 吴老师 的方法了$</p><p>$[ \begin{aligned} e^x - 1 &amp;= x + \frac{1}{2!}x^2 + \frac{1}{3!}x^3 \cdots \\ \dfrac{e^x-1}{x} &amp;= 1 + \dfrac{1}{2!}x + \dfrac{1}{3!}x^2 + \cdots \end{aligned} ]$</p><p>$可得 (\begin{cases} x’(0) = \dfrac{1}{2!} &amp; y’(0) = e \\ x’‘(0) = \dfrac{1}{3!} &amp; y’'(0) = 2e^2 \end{cases})$</p><p>$这个应该都会吧，就是求 (n) 阶导后： 1. 小于 (n) 的项求导没了 2. 大于 (n) 的项，代入 (x = 0) 后为 (0) 3. 因此只会保留等于 (n) 的项$</p><p>$最后代入公式即可：(\dfrac{d^2y}{dx^2}\bigg|_{t=0} = 8(e^2-\dfrac{1}{3}e))$</p><h2 id="题目273">题目273</h2><p>$已知函数 (f(x) = x^2\ln(1-x))，当 (n\ge3) 时，求 (f^{(n)}(0))$</p><h3 id="解答-49">解答</h3><p>$[ 高阶导数题型 \begin{cases} 求f^{(n)}(x) \begin{cases} 求几阶然后找规律\\ 莱布尼茨公式\ \end{cases}\\ 求f^{(n)}(x_0) \begin{cases} 泰勒展开 \\ 求极限 \end{cases} \end{cases} ]$</p><p>$我这里写成 无穷级数 的形式，方便观察 $</p><p>$[ \ln(1-x) = \sum_{n=1}^{\infty} -\frac{1}{n}x^n \ x^2\ln(1-x) = \sum_{n=1}^{\infty} -\frac{1}{n}x^{n+2} ]$</p><p>$我们都知道，幂函数的多项式，求 (n) 阶导后，代入 (x=0) 后，只会保留 (x^n) 的系数：$</p><p>$次数小于 (n) 的，求 (n) 阶导后为 (0)<br>次数大于 (n) 的，求 (n) 阶导后，保留有 (x)，代入 (x=0) 后，值为 (0)<br>因此找 (f^{(n)}(0)) 就等于找 (x^n) 的项：(-\dfrac{1}{n-2}x^n)$</p><p>$由 抽象泰勒展开式 建立方程：(\dfrac{f^{(n)}(0)}{n!}x^n = -\dfrac{1}{n-2}x^n)$</p><p>$综上所述： (f^{(n)}(0) = -\dfrac{n!}{n-2})$</p><h2 id="题目274">题目274</h2><p>$设 (f(x) = \dfrac{1}{1+2x+4x^2})，求 (f^{(100)}(0))$</p><h3 id="解答-50">解答</h3><p>$前置知识，幂差公式(3次)：(a^3-b^3 = (a-b)(a^2+ab+b^2))$</p><p>$根据 0x111（273） 题题解中的分析，我们有 泰勒展开 和 求极限 作为手段$</p><p>$求极限 用于 无穷小阶数 (\ge) 求导阶数 的题目，因此本题毫无疑问是 泰勒展开$</p><p>$那么用哪个常见的幂级数展开呢？我们考虑对函数进行恒等变形$</p><p>$[ f(x) = \dfrac{1}{1 + 2x + (2x)^2} = \dfrac{1-2x}{(1-2x)(1+2x+(2x)^2)} = \dfrac{1-2x}{1-8x^3} ]$</p><p>$那么我们的选择毫无疑问就是 等比级数 分别展开 (\dfrac{1}{1-8x^3}) 和 (\dfrac{-2x}{1-8x^3})$</p><p>$由 (\dfrac{1}{1-x} = \sum\limits_{n=0}^\infty x^n) 可知 (\dfrac{1}{1-8x^3} = \sum\limits_{n=0}^\infty (2x)^{3n})$</p><p>$由于我们只需找出 (x^{100}) 的项（在 0x111(273) 题中写过原因），再根据 抽象泰勒展开式 我们有如下方程：$</p><p>$[ \frac{f^{(100)}(0)}{100!} = -2\times 2^{99} \quad\Rightarrow\quad f^{(100)}(0) = -2^{100} 100! ]$</p><h2 id="题目275">题目275</h2><p>设 $(y = \dfrac{\arcsin x}{\sqrt{1-x^2}}):$</p><p>$（1）证明：((1-x^2)y^{(n+1)} - (2n+1)xy^{(n)} - n^2y^{(n-1)} = 0 (n\ge1))$</p><p>$（2）求 (y^{(n)}(0))$</p><h3 id="解答-51">解答</h3><p>$已知递推关系式的结论证明，可以考虑数学归纳法$</p><p>$数学归纳法：$</p><p>$验证初值 (n=1) 时：$</p><p>$对给定的方程连续两次求导：  (1-x^2)y^n - (2n+1)xy - n^2y = 0 $</p><p>$初值成立$</p><p>$假设 (n=k(k\ge1)) 成立：$</p><p>$对 (n=k) 的递推式两侧再次求导：$</p><p>$[ (1-x^2)y^{(k+2)} - \bigg[2(k+1)+1\bigg]xy^{(k+1)} - (k^2+2k+1)y^{(k)} = 0 ]$</p><p>$化简后可得：((1-x^2)y^{(k+2)} - \bigg[2(k+1)+1\bigg]xy^{(k+1)} - (k+1)^2y^{(k)} = 0) 得证$</p><p>$令 (x = 0) 可得：(y^{(n+1)} = n^2y^{(n-1)} (n\ge1))$</p><p>$获得 跨阶 的 递推式，因此我们需要分 奇偶 讨论不同 初值 下的情况即可 （经典 动态规划）$</p><p>$n为偶数时：$</p><p>$(\begin{cases} y^{(0)} = 0 \ y^{(2k+2)} = 4k^2 \cdot y^{(2k)} (k\ge0) \end{cases} \quad\Rightarrow\quad y^{(2k)} = 0)$</p><p>$n为奇数时：$</p><p>$(\begin{cases} y^{(1)} = 1 \ y^{(2k+1)} = 4k^2 \cdot y^{(2k-1)} (k\ge 1) \end{cases} \quad\Rightarrow\quad y^{(2k+1)} = \Big[(2k)!!\Big]^2)$</p><p>$综上可知 (y^{(n)}(0) = \begin{cases} 0 &amp;n = 2k\ \Big[(2k)!!\Big]^2 &amp; n = 2k + 1 \end{cases} \quad \text{其中k=0,1,}\cdots)$</p><h2 id="题目276">题目276</h2><p>$设函数 (f(x) = \begin{cases} x|x| &amp;x\le0\\ x\ln x &amp;x&gt;0 \end{cases}) ，$</p><p>$判断 (x = 0) 是否为 (f(x)) 的 极值点 或 不可导点$</p><h3 id="解答-52">解答</h3><p>$原式可化为：(\begin{cases} -x^2 &amp;x\le0\\ x\ln x &amp;x&gt;0 \end{cases})$</p><p>$研究可导性$</p><p>$用导数定义：$</p><p>$(f_{+}'(0) = \lim\limits_{x\to0^+} \dfrac{x\ln x}{x} = -\infty) 不存在，故不可导$</p><p>$研究极值点$</p><p>$由于该点一阶导数不存在，故三个判别极值的充分条件都用不了$</p><p>$我们考虑直接从极值的定义出发$</p><p>$(f(x - 0) = -x^2 &lt; 0)$</p><p>$(f(x + 0) = x\ln x &lt; 0)$</p><p>$故 (x=0) 处 (f(x)) 取极大值$</p><h2 id="题目277">题目277</h2><p>$设函数 (f(x) = \displaystyle\int_{-1}^xt\ln|t|dt)，求 (x=0) 处 (f(x)) 是否有 极值点 、可导性$</p><h3 id="解答-53">解答</h3><p>$被积函数在 (x=0) 处不连续，则变上限积分可能在这一点不可导，故只需研究在这一点的可导性即可$</p><p>$利用导数定义：(f’(0) = \lim\limits_{x\to0} \dfrac{\displaystyle\int_{-1}^xt\ln|t|dt - f(0)}{x} = \lim\limits_{x\to0} x\ln|x| = 0)$</p><p>$故在这一点 可导$</p><p>$然后研究极值点，找出一阶导数等于 0 的驻点，或不可导点$</p><p>$有可疑点：(x = 0)，显然在 (x=0) 不存在二阶导数，不妨用一阶导数左右正负来看$</p><p>$(x\to0^-) 时：(x\ln(-x) &gt; 0)$</p><p>$(x\to0^+) 时：(x\ln(-x) &lt; 0)$</p><p>$由极值点的第一充分条件可得：(x=0) 为极大值点$</p><h2 id="题目278">题目278</h2><p>$函数 (f(x)=(x+1)|x^2-1|) ，求 驻点 和 极值点 的个数$</p><h3 id="解答-54">解答</h3><p>$多项式函数求 驻点 极值点 个数问题$</p><p>$首先写出函数的分段：(\begin{cases} (x+1)^2(x-1) &amp;|x|\ge1\\ (x+1)^2(1-x) &amp;|x|&lt;1 \end{cases})$</p><p>$写出导函数的分段：(\begin{cases} (3x-1)(x+1) &amp;|x|\gt1\\ -(3x-1)(x+1) &amp;|x|&lt;1 \end{cases})$</p><p>$区间内的驻点有：(x = \dfrac{1}{3})$</p><p>$分段点的导数可以用定义去求，但有一个更快的结论：(f(x)|x-a|) 在 (x=a) 可导 (\Leftrightarrow) (f(a)=0)$</p><p>$故可知 分段点 处 导数不存在 的点有 (x=1)，导数存在的点 有 (x=-1)$</p><p>$综上，驻点为 (x=1,\dfrac{1}{3})$</p><p>$找 极值点，就是找 驻点 或 导数不存在 的点，即 (x=\pm1,\dfrac{1}{3})$</p><p>$这里我们可以直接从 极值的定义 出发来判断$</p><p>$(x\to1) 时，(f(x)&gt;0)，故 (x=1) 为极值点$</p><p>$(x\to-1^+) 时，(f(x)&gt;0)，(x\to-1^-) 时，(f(x)&lt;0) 故 (x=-1) 不是极值点$</p><p>$(x\to\dfrac{1}{3}^+) 时，(f’(x)&lt;0)，(x\to\dfrac{1}{3}^-) 时，(f’(x)&gt; 0)，故 (x=1) 为极值点$</p><p>$综上所述：2 个驻点，2 个极值点$</p><h2 id="题目279">题目279</h2><p>$设 (f(x)) 有二阶连续导数，且 (f’(0)=0,~\lim\limits_{x\to0}\dfrac{f’'(x)+f(x)-f(-x)}{|x|} = 1)，则$</p><p>$(f(0)) 是 (f(x)) 的极大值$</p><p>$(f’'(0)&gt;0, f(0)) 是 (f(x)) 的极小值$</p><p>$((0,f(0))) 是曲线 (y=f(x)) 的拐点$</p><p>$(f(0)) 是 (f(x)) 的极值，((0,f(0))) 不是曲线 (y=f(x)) 的拐点$</p><h3 id="解答-55">解答</h3><p>$条件一给的是 一阶导数值 为 (0)，但条件二里只有 二阶导数 和 零阶导数$</p><p>$那么要么是 降阶 要么是 升阶 两条路可以走$</p><p>$这里我采用 拉格朗日 来拉出 一阶$</p><p>${x0} = {x0} = _{x0} = 1 $</p><p>$整理一下该式子可以得出的结论：(f’‘(0) = 0, f’'(0\pm) &gt; 0, x=0\text{为极小值点})$</p><p>$故错误的有（A）、（B）、（C），排除法正确的为 (D)$</p><p>$关于（D）极值我们已经分析出了，他明显不是拐点：$</p><p>$根据 判别拐点的第一充分条件，(f’'(x)) 在 (x\to0) 的 左右邻域没变号，故不是拐点$</p><h2 id="题目280">题目280</h2><p>$已知 (f(x)=\dfrac{x|x|}{1+x})，求 (f(x)) 凹凸区间 及 渐近线$</p><h3 id="解答-56">解答</h3><p>$首先写出 函数 的分段 (f(x)=\begin{cases} \dfrac{x^2}{1+x} &amp; x \ge 0\\ \dfrac{-x^2}{1+x} &amp; x \lt 0 \end{cases})$</p><p>$写出 一阶导数 的分段 (f’(x)=\begin{cases} \dfrac{x^2+2x}{(1+x)^2} &amp; x \gt 0\\ \dfrac{-x^2-2x}{(1+x)^2} &amp; x \lt 0 \end{cases})$</p><p>$写出 二阶导数 的分段 (f’'(x)=\begin{cases} \dfrac{2}{(1+x)^3} &amp; x \gt 0\\ \dfrac{-2}{(1+x)^3} &amp; x \lt 0 \end{cases})$</p><p>$简单观察发现：(x &gt; 0) 时，(f’‘(x) &gt; 0)；(-1 &lt; x &lt; 0) 时，(f’‘(x) &lt; 0)；(x &lt; -1) 时，(f’'(x) &gt; 0)$</p><p>$故 凹区间 为 ((-\infty,-1)) 和 ((0,+\infty)) ；凸区间 为 ((-1, 0))$</p><p>$研究 渐近线 就是研究 无定义点、分段点、广义无定义点（无穷大） 处函数值的大小$</p><p>$无定义点 (x=-1)：(\lim\limits_{x\to-1}f(x) = \infty) 故 (x=-1) 为铅锤渐近线$</p><p>$分段点 (x=0)：(\lim\limits_{x\to0}f(x)=0) 故该点不是渐近线，而且还连续$</p><p>$无穷大 (x\to+\infty)：(\lim\limits_{x\to\infty}f(x) = \infty) 故没有水平渐近线$</p><p>$研究 斜渐近线 (\lim\limits_{x\to+\infty}\dfrac{f(x)}{x} = 1), (\lim\limits_{x\to+\infty}f(x) - x = -1) 故有 斜渐近线 (y=x-1)$</p><p>$(\lim\limits_{x\to-\infty}\dfrac{f(x)}{x} = -1), (\lim\limits_{x\to-\infty}f(x) + x = 1) 故有 斜渐近线 (y=-x+1)$</p><p>$综上所属，渐近线为 (y=x-1,y=-x+1,x=-1)$</p><h2 id="题目281">题目281</h2><p>$ 曲线 (y = x(1+\arcsin \dfrac{2}{x})) 的斜渐近线方程为$</p><h3 id="解答-57">解答</h3><p>$直接求即可，没有什么特殊的地方$</p><p>$[ \lim\limits_{x\to+\infty}\dfrac{x+x\arcsin\dfrac{2}{x}}{x} = \lim\limits_{x\to+\infty} 1+\arcsin\dfrac{2}{x} = 1 ]$</p><p>$[ \lim\limits_{x\to+\infty} x+x\arcsin\dfrac{2}{x} - x = \lim\limits_{x\to+\infty} x\arcsin\dfrac{2}{x} = \lim\limits_{x\to+\infty} x \cdot \dfrac{2}{x} = 2 ]$</p><p>$故渐近线方程 (y = x + 2)$</p><h2 id="题目282">题目282</h2><p>$求曲线 (y=e^{\frac{1}{x}}\sqrt{1+x^2}) 的渐近线所围区域的面积$</p><h3 id="解答-58">解答</h3><p>$(\lim\limits_{x\to0^+}e^{\frac{1}{x}}\sqrt{1+x^2} = +\infty) 故 (x=0) 为 铅锤渐近线$</p><p>$(\lim\limits_{x\to\infty}e^{\frac{1}{x}}\sqrt{1+x^2} = +\infty) 无水平渐近线$</p><p>$求斜渐近线，可以考虑把 (y) 在 (x\to\infty) 的一个 广义点处泰勒展开 了$</p><p>$[ y=e^{\frac{1}{x}}\sqrt{1+x^2}=|x|e^{\frac{1}{x}}\sqrt{1+\frac{1}{x^2}} = |x|(1+\frac{1}{2x^2}+o(\frac{1}{x^2}))(1+\frac{1}{x}+o(\frac{1}{x})) = |x|(1+\frac{1}{x}+o(\frac{1}{x})) ]$</p><p>$当 (x\to+\infty) 时：(y = x + 1 + o(1) \Rightarrow \text{渐近线：} y = x + 1)$</p><p>$当 (x\to-\infty) 时：(y = -x - 1 + o(1) \Rightarrow \text{渐近线：} y = -x - 1)$</p><p>$故有 斜渐近线 (y = \pm x \pm1)$</p><p>$将三条渐近线围起来，计算一个三角形的面积即可$</p><p>$(S = \dfrac{2 \times 1}{2} = 1)$</p><h2 id="题目283">题目283</h2><p>$(2020年2) 求曲线 (y = \dfrac{x^{1+x}}{(1+x)^x}(x&gt;0)) 的斜渐近线方程$</p><h3 id="解答-59">解答</h3><p>$[ k = \lim\limits_{x\to+\infty}\bigg(\dfrac{x}{1+x}\bigg)^{x} = e^{\lim\limits_{x\to+\infty} \frac{-x}{x+1}} = e^{-1} ]$</p><p>$[ b = \lim\limits_{x\to+\infty} \Bigg[x\bigg(\dfrac{x}{1+x}\bigg)^{x} - \dfrac{x}{e}\Bigg] = \lim\limits_{x\to+\infty} \dfrac{x}{e}\Bigg(e^{x\ln\frac{x}{1+x} + 1} - 1\Bigg) = \lim\limits_{x\to+\infty} \dfrac{x}{e}(x\ln\frac{x}{1+x} + 1) ]$</p><p>$“(\infty \cdot 0)” 型，直接倒代还即可$</p><p>$[ \frac{1}{e}\lim\limits_{x\to0^+} \frac{\dfrac{\ln\dfrac{1}{1+x}}{x} + 1}{x} = \frac{1}{e}\lim\limits_{x\to0^+} \dfrac{\ln 1 - \ln (1+x) + x}{x^2} = \frac{1}{e}\lim\limits_{x\to0^+} \dfrac{x - \ln (1+x)}{x^2} = \frac{1}{2e} ]$</p><p>$故该 斜渐近线 为 (y = e^{-1}x + (2e)^{-1})$</p><h2 id="题目284">题目284</h2><p>$（2019年3）已知方程 (x^5-5x+k=0) 有三个不同的实根，则 (k) 的取值范围是$</p><p>$（A）((-\infty,-4))$</p><p>$（B）((4,+\infty))$</p><p>$（C）([-4,4])$</p><p>$（D）((-4,4))$</p><h3 id="解答-60">解答</h3><p>$令 (F(x) = 5x - x^5)，这样原问题就变成求曲线 (F(x)) 与 直线 (y = k) 的交点个数问题$</p><p>$则 (F’(x) = 5 - 5x^4 \xlongequal{\text{令}} 0)，解出 单减区间 ((-\infty,-1)) 和 ((1,\infty)) ；单增区间 ((-1,1))$</p><p>$而 (F(-1) = -4)，(F(1) = 4)，(F(-\infty) = +\infty)，(F(+\infty) = -\infty)$</p><p>$故通过初步绘制图像观察可得结论：$</p><p>$函数 (F(x)) 与 (y=k) 有三个交点，当且仅当 (k\in(-4, 4)) 时$</p><p>$（如果取的是闭区间，则交点个数会变成两个，与题意不符）$</p><p>$综上选 D$</p><h2 id="题目285">题目285</h2><p>$设函数 (f(x) = ax - b\ln x (a &gt; 0)) 有两个零点，则 (\dfrac{b}{a}) 的取值范围是（ ）$</p><p>$（A）((e,+\infty))$</p><p>$（B）((0,e))$</p><p>$（C）((0,\dfrac{1}{e}))$</p><p>$（D）((\dfrac{1}{e},+\infty))$</p><h3 id="解答-61">解答</h3><p>$f’(x) = a - 0 x = $</p><p>$分类讨论:$</p><p>$1）(b \le 0)$</p><p>$则 (\dfrac{b}{a} &lt; 0) 不在 (x) 的定义域内，则 (f(x)) 在定义域内 单调 (\Rightarrow) 至多一个零点 （舍）$</p><p>$2）(b \gt 0)$</p><p>$(f(\dfrac{b}{a}) = b \bigg( \ln e - \ln \dfrac{b}{a}\bigg))$</p><p>$已知 (\lim\limits_{x\to0^+}f(x) = +\infty) 及 (\lim\limits_{x\to+\infty}f(x) = +\infty)$</p><p>$故 (f(\dfrac{b}{a}) &lt; 0) 才能满足 至少有两个零点（两次各用一次零点定理）$</p><p>$然后根据 单调性 可知在两侧区间 至多有两个零点，因此 恰有两个零点$</p><p>$故 (e &lt; \dfrac{b}{a}) 选 A$</p><h2 id="题目286">题目286</h2><p>$（2017年3）已知方程 (\dfrac{1}{\ln(1+x)} - \dfrac{1}{x} = k) 在区间 ((0,1)) 有实根，确定常数 (k) 的取值范围$</p><h3 id="解答-62">解答</h3><p>$方程的根的问题，还是直接套板题计算即可$</p><p>$令 (F(x) = \dfrac{1}{\ln(1+x)} - \dfrac{1}{x})，则 (F’(x) = \dfrac{(1+x)\ln^2(1+x) - x^2}{x^2(1+x)\ln^2(1+x)})$</p><p>$在给定 ((0,1)) 区间上，分母一定大于 (0)，故我们只需研究分子的正负即可$</p><p>$令 (g(x) = (1+x)\ln^2(1+x) - x^2)，则 (g(0) = 0)$</p><p>$求导得：(g’(x) = \ln^2(1+x) + 2\ln(1+x) - 2x)，(g’(0)=0)$</p><p>$再求导：(g’'(x) = \dfrac{2\ln(1+x) - 2x}{1 + x})$</p><p>$根据常用不等式结论：(\ln(1+x) &gt; x \quad (x &gt; 0)) ，得 (g’‘(x) &lt; 0 \quad\Rightarrow\quad g’(x)&lt;0 \quad\Rightarrow\quad g(x)&lt;0)$</p><p>$所以 (F’(x) &lt; 0 \quad\Rightarrow\quad F(x)\text{单调递减})$</p><p>$又 (\lim\limits_{x\to 0^+}F(x) = \lim\limits_{x\to 0^+}\dfrac{x - \ln(1+x)}{x\ln(1+x)} = \dfrac{1}{2})；(\lim\limits_{x\to 1^-}F(x) = F(1) = \dfrac{1}{\ln 2} - 1)$</p><p>$综上 k (\in (\dfrac{1}{\ln 2} - 1, \dfrac{1}{2}))$</p><h2 id="题目287">题目287</h2><p>$试证：若在区间 (I) 上 (f^{(n)}(x)\ne0)，则方程 (f(x) = 0) 在 (I) 上最多 (n) 个实根$</p><h3 id="解答-63">解答</h3><p>$这是著名的 罗尔原话$</p><p>$我们采用反证法来证明，假设 (f(x) = 0) 在 (I) 上至少有 (n + 1) 个实根$</p><p>$不妨设这 (n+1) 个根为 (x_1, x_2, \cdots, x_{n+1})，则我们在 相邻零点 处，使用 罗尔定理，有：$</p><p>$( \exists \xi_1\in (x_1, x_2), \xi_2\in (x_2, x_3), \cdots, \xi_{n}\in (x_{n}, x_{n+1})，s.t. f’(\xi_1) = f’(\xi_2) = \cdots = f’(\xi_{n}) = 0)$</p><p>$再用一次 罗尔定理，会发现一个规律，每用一次，函数的 求导阶数 上升 一阶，函数 零点个数 减少 一个$</p><p>$不妨使用 数学归纳法证明（这里我就不写了，很简单，在 k 次式的时候两两用 罗尔定理 即可得到 k+1 次式）$</p><p>$故 (f^{(n)}(x) = 0) 有一个实根，与条件矛盾，因此 至少有 n + 1 的实根 (\Rightarrow) 至多有 (n) 个实根（证毕）$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第256-271题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC256-271%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC256-271%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目256">题目256</h2><p>$设 (f(x) = \lim\limits_{n\to\infty}\dfrac{x^{n+2}-x^{-n}}{x^n+x^{-n}})，则函数(f(x))$</p><p>$（A）仅有(1)个间断点 （B）仅有(2)个间断点，其中(1)个可去，(1)个无穷$<br>$ （C）仅有(2)个间断点，(2)个都是跳跃 （D）有(2)跳跃间断点和(1)个可去间断点$</p><h3 id="解答-32">解答</h3><p>$常用极限结论：(\lim\limits_{n\to\infty} x^n = \begin{cases} 0 &amp; ,|x| &lt; 1 \\ \infty &amp; ,|x| &gt; 1 \\ 1 &amp; ,x = 1 \\ \not\exists &amp;,x=-1 \end{cases})$</p><p>$(f(x) = \lim\limits_{n\to\infty}\dfrac{x^{n+2}-x^{-n}}{x^n+x^{-n}} = \lim\limits_{n\to\infty}\dfrac{x^2 \cdot x^{2n}-1}{x^{2n}+1} \quad (x \ne 0))$</p><p>$(|x| &lt; 1) 时：(f(x) = \lim\limits_{n\to\infty}\dfrac{x^2 \cdot x^{2n}-1}{x^{2n}+1} = -1)$</p><p>$(x = 1) 时：(f(x) = \lim\limits_{n\to\infty}\dfrac{x^2 \cdot x^{2n}-1}{x^{2n}+1} = 0)$</p><p>$(x = -1) 时：(f(x) = \lim\limits_{n\to\infty}\dfrac{x^2 \cdot x^{2n}-1}{x^{2n}+1} = 0)$</p><p>$(|x| &gt; 1) 时：(f(x) = \lim\limits_{n\to\infty}\dfrac{x^2 - 0}{1 + 0} = x^2)$</p><p>$(\lim\limits_{x\to1^+} f(x) = 1)，(\lim\limits_{x\to -1^-} f(x) = 1)$</p><p>$故 (x = 0, x = -1) 为 跳跃间断点$</p><p>$(\lim\limits_{x\to0}f(x) = 0)，故 (0) 是 可去间断点$</p><p>$因此，两个跳跃，一个可去$</p><h2 id="题目257">题目257</h2><p>$设 (f(x)) 在 (x=1) 处连续，且 (\dfrac{f(x)-2x}{e^{x-1} - 1} - \dfrac{1}{\ln x}) 在 (x=1) 的某去心邻域有界，求 (f(1)) 的值$</p><h3 id="解答-33">解答</h3><p>$泰勒展开你就慢了，这题武老师的方法秒杀，妙啊$</p><p>$由 (\dfrac{f(x)-2x}{e^{x-1} - 1} - \dfrac{1}{\ln x}) 在 (x\to 1) 时有界$</p><p>$故 (\lim\limits_{x\to 1} (e^{x-1} - 1) \times \Bigg(\dfrac{f(x)-2x}{e^{x-1} - 1} - \dfrac{1}{\ln x} \Bigg) = 0)$</p><p>$[ \begin{aligned} \lim\limits_{x\to 1} (e^{x-1} - 1) \times \Bigg(\dfrac{f(x)-2x}{e^{x-1} - 1} - \dfrac{1}{\ln x} \Bigg) &amp;= \lim\limits_{x\to 1} f(x) - 2x - \lim\limits_{x\to 1}\dfrac{e^{x-1} - 1}{\ln x} \\ &amp;= f(1) - 2 - \lim\limits_{x\to 1}\dfrac{x-1}{x-1} \\ &amp;= f(1) - 3 \end{aligned} ]$</p><p>$故 (f(1) = 3)$</p><p>$当然本题也可以通分，泰勒展开算，就是有点慢了$</p><h2 id="题目258">题目258</h2><p>$已知函数 (f(x) = \dfrac{(x^2 + a^2)(x-1)}{e^{\frac{1}{x}} + b}) 在 ((-\infty,+\infty)) 上有一个可去间断点和一个跳跃间断点，求 (a,b) 的值$</p><h3 id="解答-34">解答</h3><p>$能且只能在分母为 (0) 处，出现题目的两个间断点：(x = 0) 处和 (x = \dfrac{1}{\ln(-b)})$</p><p>$(x \to 0^+) 时：(f(x) = 0) 显然$</p><p>$(x \to 0^-) 时：(f(x) = -\dfrac{a^2}{b})$</p><p>$由于不存在第二类间断点，故分母趋于零的间断点必定会被分子抵消$</p><p>$则可知 (\lim\limits_{x\to 1} e^{\frac{1}{x}} + b = 0)，得出 (b = -e)$</p><p>$此时: (x = 1) 为可去间断点，故 (x=0) 为跳跃间断点$</p><p>$故 (a \ne 0, b = -e)$</p><h2 id="题目259">题目259</h2><p>$函数 (f(x) = \begin{cases} \dfrac{e^x-1}{x} &amp;x\ne0\\ 1&amp;x=0 \end{cases})，在 (x=0) 处$</p><p>$（A）连续且取极大值 （B）连续且取极小值 （C）可导且导数为(0) （D）可导且导数不为(0)$</p><h3 id="解答-35">解答</h3><p>$(\lim\limits_{x\to0} f(x) = \lim\limits_{x\to0} \dfrac{e^x-1}{x} = \lim\limits_{x\to0} \dfrac{x}{x} = 1 = f(0))$</p><p>$故 (f(x)) 在 (x=0) 处连续$</p><p>$(f’(0) = \lim\limits_{x\to0}\dfrac{\dfrac{e^x-1}{x} - 1}{x} = \lim\limits_{x\to0} \dfrac{e^x - 1 - x}{x^2} = \dfrac{1}{2})$</p><p>$故 (f(x)) 在 (x = 0) 处导数为 (\dfrac{1}{2})$</p><h2 id="题目260">题目260</h2><p>$下列函数中在 (x=0) 处不可导的是（ ）$</p><p>$(\displaystyle\int_0^x(|t|+t)dt)$</p><p>$(|x|(x+\displaystyle\int_0^{|x|}e^{t^2}dt))$</p><p>$(|\tan x - \sin x|)$</p><p>$(\sin|x| + \cos|x|)$</p><h3 id="解答-36">解答</h3><p>$变上限积分在一点 可导性 取决于被积函数在该点的 连续性$</p><p>$显然 (A) 可导$</p><p>$选项：(f’(0) = \lim\limits_{x\to0}\dfrac{|x|}{x} \cdot (x + \displaystyle\int^{|x|}e^{t^2}dt) = 0)<br>故（B）在 (x = 0) 也可导$</p><p>$选项：(f_{+}‘(0) = \lim\limits_{x\to0^+}\dfrac{\tan x - \sin x}{x} = 0)，(f_{-}’(0) = \lim\limits_{x\to0^-}\dfrac{\sin x - \tan x}{x} = 0)$<br>$故（C）在 (x = 0) 也可导$</p><p>$选项：(f’(0) = \lim\limits_{x\to0} \dfrac{\sin|x| + \cos|x| - 1}{x} = \lim\limits_{x\to0} \dfrac{|x| - \dfrac{1}{2}|x|^2 + o(|x|^2)}{x} = \lim\limits_{x\to0} \dfrac{|x|}{x}) 不存在<br>故选 (\mathbf{D})$</p><h2 id="题目261">题目261</h2><p>$(\lim\limits_{x\to0}\dfrac{f[\varphi(x)] - f(0)}{\varphi(x)}) 看似很像导数定义，但实则存在许多问题$</p><h3 id="解答-37">解答</h3><p>$(\lim\limits_{x\to0}\dfrac{f[\varphi(x)] - f(0)}{\varphi(x)}) 看似很像导数定义，但实则存在许多问题$</p><p>$解答$<br>$例如 (\varphi(x) &gt; 0) 则该式子只能说明在 (x=0) 处的 右导数 存在，反例 (\varphi(x) = x^2)$</p><p>$反之 (\varphi(x) &lt; 0) 则该式子只能说明在 (x=0) 处的 右导数 存在，反例 (\varphi(x) = -x^2)$</p><p>$因此必须满足 (\varphi(x)) 不是 恒正或恒负 的才能满足在 (x = 0) 点的导数定义$</p><p>$故不能 正推$</p><p>$反过来也不成立，如果 (\varphi(x) \equiv 0) 则该式为 未定义式，故当然 极限不存在$</p><p>$因此 即非必要也非充分条件$</p><p>$看了一下武老师的讲解，他把 (\varphi(x)\xlongequal{令}x\sin \dfrac{1}{x}) 这个是更好说明的例子$</p><p>$因为他在趋于 (0) 的任意邻域内都有等于(0)的值，且满足了极限为0$</p><p>$该例子更值得记忆$</p><h2 id="题目262">题目262</h2><p>$已知 (f(x)) 为奇函数，则 (f’_+(0)) 存在是 (f(x)) 在 (x=0) 处可导的（ ）条件$</p><h3 id="解答-38">解答</h3><p>$“(\Leftarrow)”：显然$</p><p>$“(\Rightarrow)”：(f_{+}‘(0) = \lim\limits_{x\to0^+} \dfrac{f(x)}{x} = \lim\limits_{t\to0^-} \dfrac{f(-t)}{-t} = \lim\limits_{t\to0^-} \dfrac{-f(t)}{-t} = \lim\limits_{t\to0^-} \dfrac{f(t)}{t} = f_{-}’(0))$</p><p>$左导数 (=) 右导数 (\Rightarrow) (x = 0) 导数存在$</p><p>$故是 充要条件$</p><h2 id="题目263">题目263</h2><p>$已知函数 (f(x)) 在 (x = x_0) 的邻域内可导，则 (f’(x_0)&gt;0) 是 (f(x)) 在 (x=x_0) 的某邻域内单调增的 ( ) 条件$</p><h3 id="解答-39">解答</h3><p>$一点处导数大于零，只能说明左高右低 一点处二阶导数大于零，可以推单调性（相当于上面的升维，六套卷里考过了）$</p><p>$这是一个经典概念题，被换形式考了无数次了$</p><p>$那就是函数 在一点邻域内单调增 不能推出在 该点导数(&gt;0)$</p><p>$例如：(f(x)=x^3 \Rightarrow f’(0)=0)$</p><p>$以及函数在 一点导数(&gt;0) 不能推出在 该点邻域内单调增$</p><p>$例如：(f(x) = x + x^2\sin\dfrac{1}{x}) 在 (x=0) 任意邻域 内都不具有 单调性$</p><p>$同时他在 (x=0) 处 (f’(0) = 1 &gt; 0)$</p><p>$这种时候往往就是要请出我们的震荡间断点$</p><p>$综上所述，为 非充分非必要 条件$</p><h2 id="题目264">题目264</h2><p>$设函数 (f(x)) 在 (x = x_0) 的某个邻域有定义，则下列命题$</p><p>$若 (f’(x_0)) 存在，则 (f(x)) 在 (x=x_0) 处连续$</p><p>$若 (f_{-}‘(x_0),f_{+}’(x_0)) 都存在，则 (f(x)) 在 (x=x_0) 处连续$</p><p>$若 (\lim\limits_{x\to x_0^-}f’(x),\lim\limits_{x\to x_0^+}f’(x)) 都存在，则 (f(x)) 在 (x=x_0) 处连续$</p><p>$若 (\lim\limits_{x\to x_0}f’(x)) 存在，则 (f(x)) 在 (x=x_0) 处连续$</p><h3 id="解答-40">解答</h3><p>$命题一：可导必连续，故正确$</p><p>$命题二：左右导数存在，则可以写出如下定义：$</p><p>$(\lim\limits_{x\to x_0^+} \dfrac{f(x)-f(x_0)}{x-x_0}) 存在，(\lim\limits_{x\to x_0^-} \dfrac{f(x)-f(x_0)}{x-x_0}) 存在$</p><p>$故(\lim\limits_{x\to x_0^+} f(x) = f(x_0)) 且 (\lim\limits_{x\to x_0^-} f(x) = f(x_0))$</p><p>$由于 左连续 且 右连续 故在该点 连续$</p><p>$故正确$</p><p>$命题三：导数的极限 存在，必然不能推得在该点连续$</p><p>$读者可以随意写两个函数，然后分段后在一点上跳跃间断即可$</p><p>$例如 (\begin{cases} x^2 + 2 &amp;x&lt;0\ x^2 + 3 &amp;x\ge0 \end{cases}) 在 (x=0) 跳跃间断，但左右导数极限存在$</p><p>$故错误$</p><p>$命题四：同理上面，推不了，函数可以在这一点 可去间断$</p><p>$邻域内的导数极限，不受到该点的影响$</p><p>$故错误$</p><p>$看见 堡 的理解很棒：函数可导就一定连续，左可导左连续，右可导右连续$</p><h2 id="题目265">题目265</h2><p>$设曲线 (y=f(x)) 与 (y=\sqrt{\dfrac{(1+x^2)\sqrt{x}}{e^{x-1}}} + \arctan\dfrac{x^2-1}{\sqrt{1+x^2}}) 在点 ((1,\sqrt{2})) 处相切$</p><p>$，则 ${x1}(f(x)+1-)^{} = $ _____$</p><h3 id="解答-41">解答</h3><p>$两曲线在一点处 相切，说明在该点处：$</p><p>$坐标相同$<br>$切线斜率相同$<br>$利用这两点建立方程即可$</p><p>$坐标相同： [ f(1) = \sqrt{2} ]$</p><p>$切线斜率相同：令 (y = y_1 + y_2)$</p><p>$[ \begin{aligned} \ln y_{1}(x) &amp;= \dfrac{1}{2} [\ln(1+x^2) + \dfrac{1}{2}\ln x - x + 1] \\ \dfrac{y_{1}‘}{y_1} &amp;= \dfrac{1}{2} [\dfrac{2x}{1+x^2} + \dfrac{1}{2x} - 1] \\ \dfrac{y_{1}’(1)}{y_1(1)} &amp;= \dfrac{1}{4} \\ y_{1}'(1) &amp;= \dfrac{\sqrt{2}}{4} \\ \end{aligned} ]$</p><p>$[ y_{2}'(1) = \lim_{x\to1}\dfrac{\arctan\dfrac{x^2-1}{\sqrt{1+x^2}}}{x - 1} = \lim_{x\to1}\dfrac{(x-1)(x+1)}{(x - 1) \sqrt{1+x^2}} = \sqrt{2} ]$</p><p>$故：(f’(1) = \dfrac{\sqrt{2}}{4} + \sqrt{2} = \dfrac{5}{4}\sqrt{2})$</p><p>$[ A = \lim_{x\to1}\dfrac{\ln (f(x) + 1 - \sqrt{2})}{\ln x} = \lim_{x\to1}\dfrac{f(x)-\sqrt{2}}{x-1} = \lim_{x\to1}f’(x) = \dfrac{5}{4}\sqrt{2} ]$</p><p>$故：(\lim\limits_{x\to1}(f(x)+1-\sqrt{2})^{\frac{1}{\ln x}} = e^{\frac{5\sqrt{2}}{4}})$</p><h2 id="题目266">题目266</h2><p>$确定函数 (f(x) = |x^3-x-\sin x|) 不可导的点的个数$</p><h3 id="解答-42">解答</h3><p>$之前说过的一个知识点，不可导点个数，不外乎分析 分段点 即可$</p><p>$由分段函数的一个已知结论：$</p><p>$(x_0 \ne 0), (f(x_0) \text{可导}\Leftrightarrow |f(x_0)| \text{可导})$<br>$(x_0 = 0), (f’(x_0) = 0 \Leftrightarrow |f(x_0)| \text{可导})$<br>$令 (g(x) = x^3-x-\sin x)，由于 (g(x)) 是 奇函数，故只需研究大于等于0的部分$</p><p>$找出 (g(x)) 的零点: (g’(x) = 3x^2 - \cos x - 1), (g’(0) &lt; 0, \lim\limits_{x\to\infty}g’(x) &gt; 0)$</p><p>$故由 零点定理 可知至少存在一个零点满足 (g’(x) = 0)$</p><p>$又 (g’‘(x) = 6x + \sin x &gt; 0) 可知 (g’(x)) 在 ((0,+\infty)) 有且仅有一个零点$</p><p>$设该点为 (x_0)，因此 (x \in (0, x_0)) 时单调递减， (x \in (x_0,+\infty)) 时单调递增$</p><p>$又 (g(x_0) &lt; 0)，故存在一个零点 (x_1\in(x_0, +\infty))$</p><p>$综上所述，共 (3) 个零点 (-x_1, 0, x_1)$</p><h2 id="题目267">题目267</h2><p>$设 (f(x)=\begin{cases} x^2&amp;x\ge0,\\ x^4&amp;x&lt;0 \end{cases}\quad g(x)=\begin{cases} -\sqrt{x}&amp;x\gt0,\\ x^2&amp;x\le0 \end{cases})$</p><p>$若 (y=f[g(x)])，则：$</p><p>$(\dfrac{dy}{dx}\bigg|_{x=1} = 1)$</p><p>$(\dfrac{dy}{dx}\bigg|_{x=1}) 不存在$</p><p>$(\dfrac{dy}{dx}\bigg|_{x=0} = 0)$</p><p>$(\dfrac{dy}{dx}\bigg|_{x=0}) 不存在$</p><h3 id="解答-43">解答</h3><p>$这是 30讲 第一章的某习题，直接做就完事了，先把复合函数的分段形式写出来：$</p><p>$(y = \begin{cases} x^4 &amp; x \le 0\\ x^2 &amp; x &gt; 0 \end{cases})$</p><p>$则 (\lim\limits_{x\to1}\dfrac{x^2 - 1}{x-1} = 2) 故 A,B错误 （B上来就可以排错，初等函数在区间内都是连续的）$</p><p>$又 (\lim\limits_{x\to0^+}\dfrac{x^2}{x} = 0 = \lim\limits_{x\to0^-}\dfrac{x^4}{x} = 0) 故 C正确，D错误$</p><h2 id="题目268">题目268</h2><p>$设 (\varphi(x)=\begin{cases} x^3\sin\dfrac{1}{x} &amp;x\ne 0\\ 0 &amp;x = 0 \end{cases}) 函数 (f(x)) 可导，求(F(x) = f[\varphi(x)]) 的导数$</p><h3 id="解答-44">解答</h3><p>$(x \ne 0) 时：(F’(x) = f’[\varphi(x)] \cdot \varphi’(x) = f’(x^3\sin\dfrac{1}{x}) \cdot (3x^2\sin\dfrac{1}{x} - x\cos\dfrac{1}{x}))$</p><p>$本题一大 踩分点 时发现 (\varphi(x)) 在 (x) 趋于 (0) 时，会无限取到 (0)，因此不能直接使用 导数定义$</p><p>$(x = 0) 时：(导数定义分类讨论)$</p><p>$[ F’(0)=\lim_{x\to 0}\frac{F(x)-F(0)}{x -0} = \lim_{x\to 0}\frac{f[\varphi(x)]-f(0)}{x} ]$</p><p>$$x = $ 时:((k\to\infty,k\in \mathbf{Z}))$</p><p>$[ \lim_{x\to 0}\frac{F(x)-F(0)}{x} = \lim_{x\to 0}\frac{0}{x} = 0 ]$</p><p>$$x $ 时:((k\to\infty,k\in \mathbf{Z}))$</p><p>$[ \lim_{x\to 0}\frac{F(x)-F(0)}{x} = \lim_{x\to 0}\frac{f[\varphi(x)]-f(0)}{\varphi(x)} \cdot \frac{\varphi(x)}{x} = 0 ]$</p><p>$综上 (F’(0) = 0)$</p><p>本题 武老师 要的是 复合函数链导法：</p><p>$通过证明 (\varphi(x)) 在 (x=0) 处可导，即 (\varphi’(0)) 存在且(\varphi’(0) = 0)，又 (f’(0)) 存在，故 (f’(\varphi(0))) 存在$</p><h2 id="题目269">题目269</h2><p>$设函数 (f(x)) 在 ((\dfrac{1}{2}, +\infty)) 上可导，且 (\lim\limits_{h\to0}\dfrac{f[(x+h)^2] - f(x^2+h)}{h}=1,f(1)=1)，求(f(x))$</p><h3 id="解答-45">解答</h3><p>$[ \begin{aligned} &amp; \lim\limits_{h\to0}\dfrac{f[(x+h)^2] - f(x^2+h)}{h} \\ =&amp; \lim\limits_{h\to0}\dfrac{f[(x+h)^2] - f(x^2) + f(x^2) - f(x^2+h)}{h} \\ =&amp; \lim\limits_{h\to0}\dfrac{f[(x+h)^2] - f(x^2)}{h} - \lim\limits_{h\to0}\dfrac{f(x^2+h)-f(x^2)}{h} \\ =&amp; [f(x^2)]’ - f’(x^2) = f’(x^2) \cdot (2x - 1) \end{aligned} ]$</p><p>$令 (f’(x^2) \cdot (2x-1) = 1)，换元可得 (f’(x) = \dfrac{1}{2\sqrt{x}-1})，左右取积分：$</p><p>$[ \begin{aligned} \int f’(x) dx &amp;= \int \dfrac{1}{2\sqrt{x}-1} dx \\ f(x) &amp;= \int \dfrac{2u - 1 + 1}{2u-1} du = \int (1 + \dfrac{1}{2u-1}) du \\ f(x) &amp;= u + \dfrac{1}{2}\ln(2u - 1) + C \\ f(x) &amp;= \sqrt{x} + \dfrac{1}{2}\ln(2\sqrt{x} - 1) + C \\ \end{aligned} ]$</p><p>$代入初值：(f(1) = 1 + C = 1)，故 (C = 0)，于是有：$</p><p>$[ f(x) = \sqrt{x} + \dfrac{1}{2}\ln(2\sqrt{x} - 1) ]$</p><h2 id="题目270">题目270</h2><p>$设可导函数 (y=y(x)) 由方程 (\sin x - \displaystyle\int_x^y\varphi(u)du=0) 所确定的$</p><p>$其中可导函数 (\varphi(u)&gt;0)，且 (\varphi(0) = \varphi’(0)=1)，求 (y’'(0))$</p><h3 id="解答-46">解答</h3><p>$隐函数求导问题，显然 (x = 0) 时，(y = 0)，然后对方程两侧求导有：$</p><p>$[ \cos x - y’ \varphi(y) + \varphi(x) = 0 \quad\Rightarrow\quad y’ = \dfrac{\cos x + \varphi(x)}{\varphi(y)} ]$</p><p>$有：(y’(0) = \dfrac{1 + 1}{1} = 2)$</p><p>再求一次导：</p><p>$[ -\sin x - y’‘\varphi(y) - y’^2\varphi’(y) + \varphi’(x) = 0 \quad\Rightarrow\quad y’’ = \dfrac{-\sin x - y’^2\varphi’(y) + \varphi’(x)}{\varphi(y)} ]$</p><p>$有：(y’'(0) = -4 + 1 = -3)$</p><h2 id="题目271">题目271</h2><p>$设 (x=x(y)) 是函数 (y=\ln x + e^x) 的反函数，求 (\dfrac{d^2x}{dy^2})$</p><h3 id="解答-47">解答</h3><p>$关于 (y) 求导有：(1 = \dfrac{x’}{x} + x’e^x)，化简可得：(x’ = \dfrac{x}{1+xe^x})</p><p>再求一次导可得：(\dfrac{d^2x}{dy^2} = \dfrac{d^2x}{dx} \cdot \dfrac{dx}{dy} = \dfrac{x}{1+xe^x} \cdot \dfrac{(1+xe^x) + x(e^x + xe^x)}{(1+xe^x)^2} = \dfrac{x - x^3e^x}{(xe^x + 1)^3})$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第240-255题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC240-255%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC240-255%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目240">题目240</h2><p>$若 (\lim\limits_{x\to0}\bigg(\dfrac{\ln(x+\sqrt{x^2+1})+ax^2+bx^3}{x}\bigg)^{\dfrac{1}{x^2}}=e^2),求(a,b)的值$</p><h3 id="解答-16">解答</h3><p>$[ \begin{aligned} &amp; \lim\limits_{x\to0}\bigg(\dfrac{\ln(x+\sqrt{x^2+1})+ax^2+bx^3}{x}\bigg)^{\dfrac{1}{x^2}} \\ =&amp; \lim\limits_{x\to0}e^{\dfrac{\ln(x + \sqrt{x^2 + 1}) + ax^2 + bx^3 - x}{x^3}} \\ \end{aligned} ]$</p><p>已知：</p><p>$[ (1 + x^2)^{-\frac{1}{2}} \sim 1 - \dfrac{1}{2}x^2 + o(x^2) ]$</p><p>两侧取积分：</p><p>$[ \ln(x + \sqrt{x^2 + 1}) \sim x - \dfrac{1}{6}x^3 + o(x^3) ]$</p><p>故可对原式进行 泰勒展开：</p><p>$[ \lim\limits_{x\to0}e^{\dfrac{x - \frac{1}{6}x^3 + ax^2 + bx^3 - x}{x^3}} ]$</p><p>极限存在，故 $(a = 0, b = \dfrac{13}{6})$</p><h2 id="题目241">题目241</h2><p>$已知常数(a&gt;0)，(bc\ne0)，使得(\lim\limits_{x\to+\infty}[x^a\ln(1+\dfrac{b}{x}) - x]=c)，求(a,b,c).$</p><h3 id="解答-17">解答</h3><p>$不妨先 倒代换，令 (t = \dfrac{1}{x})，然后直接 泰勒展开$</p><p>$[ \lim_{t\to0^+} \dfrac{\ln(1 + bt) - t^{a - 1}}{t^a} = \lim_{t\to0^+} \dfrac{bt - \dfrac{b^2}{2}t^2 - t^{a - 1} + o(t^2)}{t^a} =c ]$</p><p>$(a \lt 2) 时：极限不存在$</p><p>$(a = 2) 时：要使极限存在，(b - 1 = 0)，此时(c = -\dfrac{1}{2})$</p><p>$(a &gt; 2)$ 时，极限不存在</p><p>综上所述 $(a = 2, b = 1, c = -\dfrac{1}{2})$</p><h2 id="题目242">题目242</h2><p>$当 (x\to0) 时，(\displaystyle\int_0^{x^2}(e^{t^3}-1)dt) 是 (x^7) 的几阶无穷小$</p><h3 id="解答-18">解答</h3><p>当 $(x\to0)$ 时，我们可以先用 变上限积分被积函数等价无穷小 的方法，化简 被积函数</p><p>$[ \displaystyle\int_0^{x^2}(e^{t^3}-1)dt \sim \int_0^{x^2} t^3 dt ]$</p><p>然后直接把这个积分解出来：$(\displaystyle\int_0^{x^2} t^3 dt = \dfrac{1}{4} x^8)$</p><p>故可知，该函数是 $(x^7)$ 的 高阶无穷小</p><h2 id="题目243">题目243</h2><p>$当 (x\to0^+) 时，求出下列无穷小量的最高阶：$</p><p>$[ \begin{matrix} \displaystyle\int_0^x(e^{t^2} - 1)dt &amp; &amp;\displaystyle\int_0^x\ln(1+\sqrt{t^3})dt\\ \displaystyle\int_0^{\sin x}\sin t^3dt &amp; &amp;\displaystyle\int_0^{1-\cos x}\sqrt{\sin^3t}dt\ \end{matrix} ]$</p><h3 id="解答-19">解答</h3><p>当 $(x\to0^+)$ 时：</p><p>$[ \displaystyle\int_0^x(e^{t^2} - 1)dt \sim \displaystyle\int_0^xt^2dt = \dfrac{1}{3}x^3 ]$</p><p>$[ \displaystyle\int_0^x\ln(1+\sqrt{t^3})dt \sim \displaystyle\int_0^x t^{\frac{3}{2}}dt = \dfrac{2}{5} x^{\frac{5}{2}} ]$</p><p>$[ \displaystyle\int_0^{\sin x}\sin t^3dt \sim \displaystyle\int_0^{x}t^3dt = \dfrac{1}{4} x^4 ]$</p><p>$[ \displaystyle\int_0^{1-\cos x}\sqrt{\sin^3t}dt \sim \displaystyle\int_0^{\frac{1}{2}x^2}x^{\frac{3}{2}}dt = \dfrac{\sqrt{2}}{20} x^5 ]$</p><p>故最高阶的为 $(\displaystyle\int_0^{1-\cos x}\sqrt{\sin^3t}dt)$</p><h2 id="题目244">题目244</h2><p>$已知 (a,b) 为常数，若 ((1+\dfrac{1}{n})^n-e) 与 (\dfrac{b}{n^a}) 在 (n\to\infty) 时是等价无穷小，求(a,b)$</p><h3 id="解答-20">解答</h3><p>数列问题，却要求等价无穷小，不妨先 连续化 转为 函数问题，再用 海涅定理 证明</p><p>$[ \begin{aligned} &amp; \lim_{n\to\infty} \dfrac{(1 + \dfrac{1}{n})^n - e}{\dfrac{b}{n^a}} \xlongequal{\text{连续化}} \lim_{x\to+\infty} \dfrac{(1 + \dfrac{1}{x})^x - e}{\dfrac{b}{x^a}} \\ \xlongequal{\text{倒代换}} &amp; \lim_{x\to0^+} \dfrac{(1 + x)^\frac{1}{x} - e}{bx^a} = \lim_{x\to0^+} \dfrac{e^{\frac{\ln(1 + x)}{x}} - e}{bx^a} \\ =&amp; e\lim_{x\to0^+} \dfrac{e^{\frac{\ln(1 + x) - x}{x}} - 1}{bx^a} = e\lim_{x\to0^+} \dfrac{\ln(1 + x)-x}{bx^{a + 1}} \\ =&amp; -\dfrac{e}{2b}\lim_{x\to0^+} \dfrac{x^2}{x^{a + 1}} \end{aligned} ]$</p><p>由 海涅定理 可知，原 数列极限 与 函数极限 收敛到同一个值</p><p>故该极限值为 $(1)$，得 $(a = 1, b = -\dfrac{2}{e})$</p><h2 id="题目245">题目245</h2><p>$当 (x\to0) 时，求下列无穷小量中最高阶$</p><p>$（A） ((1+x)^{x^2}-1) （B） (e^{x^4-2x}-1)$</p><p>$（C） (\displaystyle\int_0^{x^2}\sin t^2dt) （D） (\sqrt{1+2x} - \sqrt[3]{1+3x})$</p><h3 id="解答-21">解答</h3><p>这是一到纯口算题，没什么要点</p><p>$A选项 ((1+x)^{x^2}-1 \sim x^3) 为3阶$</p><p>$B选项 (e^{x^4-2x}-1 \sim e^{4} - 2x \sim -2x) 为1阶$</p><p>$C选项 (\displaystyle\int_0^{x^2}\sin t^2dt \sim \int_0^{x^2}t^2dt = \dfrac{1}{3} x^6) 为6阶$</p><p>$D选项 (\sqrt{1+2x} - \sqrt[3]{1+3x} = -\dfrac{1}{8}x^2 + \dfrac{1}{18}x^2) 为2阶$</p><p>故选 C</p><h2 id="题目246">题目246</h2><p>当 $(x\to0^+)$时，下列无穷小量中最高阶的是（ ）</p><p>$A. (\displaystyle\int_0^{1-\cos x}\frac{\sin t}{t}dt\quad\quad\quad\quad\quad) B. (\displaystyle\int_0^{x}t\tan\sqrt{x^2-t^2}dt)$</p><p>$C. (\displaystyle\int_{\sin x}^{1-\sqrt{\cos x}}e^{xt}\ln(1+t^3)dt\quad) D. (\displaystyle\int_{\sin x}^{x}\sqrt{\sin^3t}dt)$</p><h3 id="解答-22">解答</h3><p>A选项</p><p>$(\displaystyle\int_0^{1-\cos x}\frac{\sin t}{t}dt \sim \displaystyle\int_0^{\frac{1}{2}x^2}dt = \dfrac{1}{2}x^2)$</p><p>B选项</p><p>令$ (\sqrt{x^2 - t^2} = u)$，则</p><p>$(\displaystyle\int_0^{x}t\tan\sqrt{x^2-t^2}dt = -\displaystyle\int_0^{x}u\tan udu \sim -\int_0^x u^2 du = -\dfrac{1}{3}x^3)$</p><p>C选项</p><p>用第一积分中值定理，提出 $(e^{xt})$ 项</p><p>$(\displaystyle\int_{\sin x}^{1-\sqrt{\cos x}}e^{xt}\ln(1+t^3)dt = e^{x\xi}\displaystyle\int_{\sin x}^{1-\sqrt{\cos x}}\ln(1+t^3)dt \sim e^{x\xi}\displaystyle\int_{\sin x}^{1-\sqrt{\cos x}}t^3dt)$</p><p>$(e^{x\xi}\displaystyle\int_{\sin x}^{1-\sqrt{\cos x}}t^3dt \sim \dfrac{1}{4} e^{x^2} [(1-\sqrt{\cos x})^4 - \sin^4 x] \sim \dfrac{1}{4}x^4)$</p><p>D选项</p><p>$(\displaystyle\int_{\sin x}^{x}\sqrt{\sin^3t}dt = \int_{\sin x}^{x}t^{\frac{3}{2}}dt = \xi^{\frac{3}{2}} (x - \sin x))$</p><p>由于 $(\sin x &lt; \xi &lt; x \quad \Rightarrow \quad \dfrac{\sin x}{x} &lt; \dfrac{\xi}{x} &lt; \dfrac{x}{x})$</p><p>不等号两侧取极限，可知 $(\lim\limits_{x\to 0} \dfrac{\xi}{x} = 1 \Rightarrow \xi \sim x)$</p><p>$(\xi^{\frac{3}{2}} (x - \sin x) \sim x^{\frac{3}{2}} \cdot \dfrac{1}{6}x^3 = \frac{1}{6}x^{\frac{9}{2}})$</p><p>综上所述，选 D</p><h2 id="题目247">题目247</h2><p>设 $(x\to a) 时，(f(x)) 与 (g(x)) 分别是 (x-a) 的 (n) 阶与 (m) 阶无穷小，则下列命题$</p><ol><li><p>$(f(x)g(x)) 是 (x-a) 的 (n+m) 阶无穷小$</p></li><li><p>$若 (n &gt; m)，(\frac{f(x)}{g(x)}) 是 (x-a) 的 (n-m) 阶无穷小$</p></li><li><p>$若 (n \le m)，则 (f(x) + g(x)) 是 (x-a) 的 (n) 阶无穷小$</p></li><li><p>$若 (f(x)) 连续，则 (\int_a^x f(t)dt) 是 (x-a) 的 (n+1) 阶无穷小$</p></li></ol><p>中，正确的个数是（ ）</p><h3 id="解答-23">解答</h3><p>由题干可知：$(f\sim (x-a)^n, g \sim (x - a)^m)$</p><p>(A)选项</p><p>因式考虑直接使用等价无穷小：</p><p>$[ f \cdot g \sim (x - a)^{n + m} ]$</p><p>故正确</p><p>(B)选项</p><p>因式考虑直接使用等价无穷小：</p><p>$[ \dfrac{f}{g} \sim (x - a)^{n - m} ]$</p><p>故正确</p><p>©选项</p><p>错误，因为如果他们是同阶无穷小，可能是相反数，一加变成 $(0)$了</p><p>考虑构造反例：$(f(x) = (x-a)^n , g(x) = -(x - a)^n)$</p><p>则：(f + g = 0)</p><p>(D)选项</p><p>不妨用 洛必达 去验证</p><p>$[ \lim_{x\to a}\frac{\displaystyle\int_a^xf(t)dt}{(x - a)^{n+1}} = \lim_{x\to a}\frac{f(x)}{(n+1)(x - a)^{n}} = \dfrac{1}{n+1} ]$</p><p>故正确</p><p>因此正确的选项为 A,B,C</p><h2 id="题目248">题目248</h2><p>设 $(f(x)) 连续，且(\lim\limits_{x\to0^+}\dfrac{f(x)}{x}=1,\alpha(x)=\displaystyle\int_0^{\sqrt{x}}\dfrac{\ln(1+t^4)}{f(t)}dt)$</p><p>$(\beta(x)=\displaystyle\int_0^{\sin x}\frac{\sqrt{1+t^3}-1}{f(t)}dt)，则当 (x\to0^+)时，(\alpha(x)) 是 (\beta(x)) 的几阶无穷小$</p><h3 id="解答-24">解答</h3><p>$由 (f(x)) 连续，且(\lim\limits_{x\to0^+}\dfrac{f(x)}{x}=1)，可知：$</p><p>$(\lim\limits_{x\to0} f(x) = f(0) = 0, f’(0) = 1, f(x) \sim x)$</p><p>$[ \alpha \sim \int_0^{\sqrt{x}} t^3 dt = \dfrac{1}{4}x^2 ]$</p><p>$[ \beta \sim \int_0^x \dfrac{t^2}{2} dt = \dfrac{1}{6} x^3 ]$</p><p>$故 (\alpha) 是 (\beta) 的 低阶无穷小$</p><h2 id="题目249">题目249</h2><p>$当 (x\to0) 时，(2\arctan x - \ln\dfrac{1+x}{1-x}) 是 (x) 的 (n) 阶无穷小，求 (n) 的值$</p><h3 id="解答-25">解答</h3><p>$[ \arctan x = x - \dfrac{1}{3}x^3 + o(x^4) ]$</p><p>$[ \ln(1 + x) = x - \dfrac{1}{2}x^2 + \dfrac{1}{3}x^3 - \dfrac{1}{4}x^4 + o(x^4) ]$</p><p>$[ \ln(1 - x) = - x - \dfrac{1}{2}x^2 - \dfrac{1}{3}x^3 - \dfrac{1}{4}x^4 + o(x^4) ]$</p><p>$[ 2\arctan x - \ln\dfrac{1+x}{1-x} = (2 - 1 - 1)x + (\dfrac{1}{2} - \dfrac{1}{2})x^2 + (-\dfrac{2}{3} - \dfrac{1}{3} - \dfrac{1}{3})x^3 = -\dfrac{4}{3}x^3 ]$</p><p>$故 (n = 3)$</p><h2 id="题目250">题目250</h2><p>$当 (x\to 0^+) 时，((1+x)^{\frac{1}{x}} - (e+ax+bx^2)) 是比 (x^2) 高阶的无穷小，求 (a,b) 的值$</p><h3 id="解答-26">解答</h3><p>简单推导：</p><p>$[ \ln(1 + x) - x = -\dfrac{1}{2}x^2 + \dfrac{1}{3}x^3 - \dfrac{1}{4}x^4 + o(x^4) ]$</p><p>$[ \dfrac{\ln(1 + x) - x}{x} = -\dfrac{1}{2}x + \dfrac{1}{3}x^2 - \dfrac{1}{4}x^3 + o(x^3) ]$</p><p>$[ e^x - 1 = x + \dfrac{1}{2}x^2 + \dfrac{1}{6}x^3 + o(x^3) ]$</p><p>$[ e^{\dfrac{\ln(1 + x) - x}{x}} - 1 = (-\dfrac{1}{2})x + (\dfrac{1}{3} + \dfrac{1}{8})x^2 + o(x^2) = -\dfrac{1}{2}x + \dfrac{11}{24}x^2 + o(x^2) ]$</p><p>$由于 (e \cdot [e^{\dfrac{\ln(1 + x) - x}{x}} - 1] - ax - bx^2) 是 (o(x^2))$</p><p>$故 (a = -\dfrac{1}{2}e)，(b = \dfrac{11}{24}e)$</p><h2 id="题目251">题目251</h2><p>$设函数 (f(x)=\dfrac{\sin x}{1+x^2}) 在 (x=0) 处的 (3) 次泰勒多项式为 (ax+bx^2+cx^3)，求参数 (a,b,c)$</p><h3 id="解答-27">解答</h3><p>简单推导：</p><p>$[ \begin{aligned} \sin x &amp;= x - \dfrac{1}{6}x^3 + o(x^3) \\ \dfrac{1}{1 + x^2} &amp;= 1 - x^2 + x^4 + o(x^4) \\ \dfrac{\sin x}{1+x^2} &amp;= [x - \dfrac{1}{6}x^3 + o(x^3)] \cdot [1 - x^2 + x^4 + o(x^4)] = x - \dfrac{7}{6}x^3 + o(x^3) \end{aligned} ]$</p><p>$故 (a = 1, b = 0, c = -\dfrac{7}{6})$</p><h2 id="题目252">题目252</h2><p>$设函数 (f(x)=\sec x) 在 (x=0) 处的(2)次泰勒多项式为(1+ax+bx^2)，求参数 (a,b)$</p><h3 id="解答-28">解答</h3><p>直接具体展开不太容易，考虑使用抽象展开式，再利用 算两次 的思想，令 系数相等</p><p>$泰勒在 (x = 0) 的抽象展开式:$</p><p>$[ f(x) = f(0) + f’(0)x + \dfrac{f’'(0)}{2}x^2 + o(x^2) ]$</p><p>$[ \begin{aligned} f(0) &amp;= \sec 0 = 1 \\ f’(0) &amp;= \tan 0 \sec 0 = 0 \\ f’'(0) &amp;= \sec^3 0 + \tan^2 0 \sec 0 = 1 \\ \end{aligned} ]$</p><p>故 $(a = 0, b = \dfrac{1}{2})$</p><h2 id="题目253">题目253</h2><p>求函数 $(f(x) = \dfrac{(x+1)|x-1|}{e^{\frac{1}{x-2}}\ln|x|})$ 的可去间断点的个数</p><h3 id="解答-29">解答</h3><p>$无定义点：(x = 2, x = 1, x = -1, x = 0)，故只需研究这四点即可$</p><p>$x = 0:$</p><p>$(\lim\limits_{x \to 0} \dfrac{(x+1)|x-1|}{e^{\frac{1}{x-2}}\ln|x|} = \sqrt{e}\lim\limits_{x \to 0} \dfrac{1}{\ln|x|} = 0 \quad \Rightarrow \quad x=0) 是 可去间断点$</p><p>$x = 1:$</p><p>$(\lim\limits_{x \to 1} \dfrac{(x+1)|x-1|}{e^{\frac{1}{x-2}}\ln|x|} = 2e \cdot \lim\limits_{x \to 1} \dfrac{|x-1|}{x - 1} \quad \Rightarrow \quad x=1) 是 跳跃间断点$</p><p>$x = -1:$</p><p>$(\lim\limits_{x \to -1} \dfrac{(x+1)|x-1|}{e^{\frac{1}{x-2}}\ln|x|} = -2e \cdot \lim\limits_{x \to -1} \dfrac{(x + 1)}{x + 1} = -2e \quad \Rightarrow \quad x=1) 是 可去间断点$</p><p>$x = 2:$</p><p>$(\lim\limits_{x \to 2} \dfrac{(x+1)|x-1|}{e^{\frac{1}{x-2}}\ln|x|} = \dfrac{3}{\ln 2}\lim\limits_{x \to 2} e^{\frac{-1}{x-2}})$</p><p>$(\lim\limits_{x \to 2^+} e^{\frac{-1}{x-2}} = 0)，(\lim\limits_{x \to 2^-} e^{\frac{-1}{x-2}} = +\infty)，故 (x = 2) 是 第二类间断点$</p><p>$故 可去间断点 数量为 (2)$</p><h2 id="题目254">题目254</h2><p>$设 (f(x)) 和 (\varphi(x)) 在 ((-\infty, +\infty)) 内有定义，(f(x)) 为连续函数，(\varphi(x)) 有间断点，则下列命题:$<br>$(f(x)\Big[|\varphi(x)| + \varphi^2(x)\Big]) 必有间断点$</p><p>$若 (f(x)) 单调，则 (\dfrac{\varphi(x)}{|f(x)|}) 必有间断点$</p><p>$(\dfrac{\varphi(x)}{1+f^2(x)}) 必有间断点$</p><p>$(f(x)\varphi(x)) 必有间断点$</p><p>中，命题正确的是哪些？</p><h3 id="解答-30">解答</h3><p>$错误，直接令 (f(x) \equiv 0) 结束$</p><p>$正确，分类讨论：$</p><p>$若 (f(x)) 无零点连续，则 (|f(x)|) 无零点连续，故 (\dfrac{\varphi(x)}{|f(x)|}) 有间断点$</p><p>$若 (f(x)) 有零点，则 (\dfrac{\varphi(x)}{|f(x)|}) 必有间断点$</p><p>$正确，显然$</p><p>$错误，令 (f(x) \equiv 0) 结束$</p><p>$这里武老师有个小总结：$</p><p>$(|f(x)|) 有间断点 (\Rightarrow) (f(x)) 有间断点$</p><p>$(f^2(x)) 有间断点 (\Rightarrow) (f(x)) 有间断点$</p><p>$(f(x)) 连续 (\Rightarrow) (|f(x)|) 连续$</p><p>$反之，都不成立$</p><h2 id="题目255">题目255</h2><p>$设 (f(x) = \lim\limits_{n\to\infty}\dfrac{x^{n+2}}{\sqrt{2^{2n}+x^{2n}}})，则 (f(x)) 在其定义域内 ((~~))$</p><p>$A.连续 B.有(1)个可去间断点 C.有(1)个跳跃间断点 D.有(1)个第二类间断点$</p><h3 id="解答-31">解答</h3><p>$常用极限结论：(\lim\limits_{n\to\infty} x^n = \begin{cases} 0 &amp; ,|x| &lt; 1 \\ \infty &amp; ,|x| &gt; 1 \\ 1 &amp; ,x = 1 \\ \not\exists &amp;,x=-1 \end{cases})$</p><p>$分母是两个指数函数相加，谁作为分母无穷大上的最大数量级，考虑分类讨论$</p><p>$(|x| &lt; 2) 时，(f(x) = \lim\limits_{n\to\infty}\dfrac{(\dfrac{x}{2})^{n} \cdot x^2}{\sqrt{1+(\dfrac{x}{2})^{2n}}} = 0)$</p><p>$(x = 2) 时，(f(x) = \lim\limits_{n\to\infty}\dfrac{2^{n+2}}{\sqrt{2^{2n+1}}} = 2^{\frac{3}{2}})$</p><p>$(x = -2) 时，(f(x) = \lim\limits_{n\to\infty}(-1)^{n+2} \cdot 2^{\frac{3}{2}} = \text{不存在})$</p><p>$(|x| &gt; 2) 时，(f(x) = \lim\limits_{n\to\infty}\dfrac{x^{2}}{\sqrt{(\dfrac{2}{x})^{2n}+1}} = x^2)$</p><p>$故 (x = 2) 为跳跃间断点$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第224-239题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC224-239%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC224-239%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目224">题目224</h2><p>$设函数 (f(x)) 一阶连续可导,且 (f(0)=0), (f’(0)\ne0) ,求 (\lim\limits_{x\to0}\dfrac{\displaystyle\int_0^{x^2}f(t)dt}{x^2\displaystyle\int_0^xf(t)dt})$</p><h3 id="解答">解答</h3><blockquote><p>连续可导：函数可导，且导函数连续</p></blockquote><p>$(f(x)) 一阶连续可导 (\quad\Rightarrow\quad) (\lim\limits_{x \to 0} f’(x_0 + x) = f’(x_0))$</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\dfrac{\displaystyle\int_0^{x^2}f(t)dt}{x^2\displaystyle\int_0^xf(t)dt} &amp;\xlongequal{L’} \lim\limits_{x\to0}\dfrac{2x f(x^2)}{2x\displaystyle\int_0^xf(t)dt + x^2f(x)} \\ &amp;= \lim\limits_{x\to0}\dfrac{2f(x^2)}{2\displaystyle\int_0^xf(t)dt + xf(x)} \\ &amp;\xlongequal{L’} \lim\limits_{x\to0}\dfrac{4xf’(x^2)}{3f(x) + xf’(x)} \\ &amp;= \lim\limits_{x\to0}\dfrac{4f’(x^2)}{3 \cdot \dfrac{f(x)}{x} + f’(x)} \\ &amp;= \frac{4f’(0)}{3 \cdot \lim\limits_{x\to0} \dfrac{f(x)}{x} + f’(0)} \\ &amp;= \frac{4f’(0)}{3f’(0) + f’(0)} \\ &amp;= 1 \\ \end{aligned} ]$</p><h2 id="题目225">题目225</h2><p>$[ \lim_{x\to0^+}\frac {\displaystyle\int_0^x\int_u^xu^2\arctan(1+tu)dtdu} {\displaystyle(\int_0^x\ln(1+t)dt)^2} ]$</p><h3 id="解答-2">解答</h3><p>本题核心思路还是 <strong>洛必达法则</strong> 去 <strong>积分符号</strong></p><p>分子是一个 <strong>积分变量</strong> 分别为 $(t)$ 和 $(u)$ 的 <strong>二重积分</strong>，且两个 <strong>积分上限</strong> 都是 $(x)$ 不好直接 <strong>洛必达</strong></p><p>先考虑一下 <strong>交换积分次序</strong> 的手段，能否解决这个问题（答案是显然的，因为积分域是一个三角形）</p><p>先画出 积分域，是一个边长为 (x) 的 <strong>正方形</strong> <strong>副对角线</strong> 上方的 <strong>三角形区域</strong></p><p>然后利用该 <strong>积分域</strong>，<strong>交换积分次序</strong></p><p>$[ \displaystyle\int_0^x\int_u^xu^2\arctan(1+tu)dtdu = \displaystyle \int_0^x\int_0^t u^2\arctan(1+tu)dudt ]$</p><p>通过 <strong>交换积分次序</strong> 的手段，我们成功在 <strong>积分限</strong> 上只保留了一个$(x)$，接下来就可以 <strong>洛必达</strong> 了</p><p>然后观察一下分母，可以利用 <strong>变上限积分</strong>，对 <strong>被积函数</strong> 做 <strong>等价无穷小代换</strong>，如下：</p><p>$[ \ln(1+x)\sim x \quad\Rightarrow\quad \int_0^x\ln(1+t)dt\sim\int_0^xtdt ]$</p><p>预处理都完成了，剩下的洛就完事了：</p><p>$[ \begin{aligned} &amp;\lim_{x\to0^+}\frac {\displaystyle \int_0^x\int_0^t u^2\arctan(1+tu)dudt} {\displaystyle(\int_0^x t dt)^2} \\ \xlongequal{L’}&amp; \lim_{x\to0^+}\frac {\displaystyle \int_0^x u^2\arctan(1+xu)du} {2x\displaystyle\int_0^xtdt} \\ \xlongequal{\scriptscriptstyle\text{广义积分中值定理}}&amp; \lim_{x\to0^+}\frac {\displaystyle \arctan(1+x\xi) \cdot \int_0^x u^2du} {2x\displaystyle\int_0^xtdt} \quad \text{其中} \xi\in(0,x) \\ =&amp; \frac{\pi}{8} \cdot \lim_{x\to0^+}\frac {\displaystyle \int_0^x u^2du} {x\displaystyle\int_0^x tdt} \\ \xlongequal{L’}&amp; \frac{\pi}{8} \cdot \lim_{x\to0^+}\frac {x^2} {\displaystyle\int_0^x tdt + x^2} \\ \xlongequal{L’}&amp; \frac{\pi}{8} \cdot \lim_{x\to0^+}\frac {2x} {3x} \\ =&amp; \frac{\pi}{12} \end{aligned} ]$</p><h2 id="题目226">题目226</h2><p>$[ \lim_{x\to+\infty}\frac{\displaystyle\int_0^xt|\sin t|dt}{x^2} ]$</p><h3 id="解答-3">解答</h3><p>本题直接 洛必达 的话，洛必达法则会失效</p><p>洛必达法则成立的三大条件：</p><ol><li>$(\dfrac{0}{0},\dfrac{\infty}{\infty}, \dfrac{\cdot}{\infty}) 型$</li><li>函数 $(f(x))$ 和 $(g(x))$ 在 $(x_0)$ 的 <strong>去心邻域内</strong> 可导</li><li>求导后 $(\lim\limits_{x\to x_0}\dfrac{f’(x)}{g’(x)} = A)$ 存在 $（(A)$ 可为 <strong>实数</strong>，也可为$(\infty)）$</li></ol><p>本题直接求导的话，原式 = $(\lim\limits_{x\to+\infty}\dfrac{|\sin x|dt}{2})$ 极限不存在，故 <strong>洛必达失效</strong></p><hr><p>考虑一下如何求解该题，对于 绝对值函数 来说，首要目标就是去 绝对值</p><p>$(|\sin x|) 的 周期 是 (\pi)，故我们可以考虑能不能用 不等式 进行 放缩，然后 夹逼$</p><p>$对于任意 (k\pi \lt x \lt k\pi + \pi)，有：$</p><p>$[ \begin{aligned} \int_0^{k\pi}t|\sin t|dt &amp;\lt \int_0^xt|\sin t|dt &amp;\lt \int_0^{k\pi + \pi}t|\sin t|dt \end{aligned} ]$</p><p>$考虑如何求积分 (\displaystyle \int_0^{k\pi}t|\sin t|dt)$</p><p>$[ \begin{aligned} I_1 &amp;= \int_0^{\pi} t|\sin t| dt = \pi \\ I_2 &amp;= \int_\pi^{2\pi} t|\sin t| dt = 3\pi \\ \cdots \\ I_n &amp;= \int_{(n-1)\pi}^{n\pi} t|\sin t| dt = (2n - 1)\pi \\ \end{aligned} ]$</p><p>$故 (\displaystyle \int_0^{k\pi}t|\sin t|dt = k^2\pi)$</p><blockquote><p>这里分享另一个做法(区间再现+积分再现) $ [ \begin{aligned} \int_0^{k\pi}t|\sin t|dt &amp;= \int_0^{k\pi}(k\pi - t)|\sin (k\pi - t)|dt \\ &amp;= k\pi\int_0^{k\pi}|\sin t|dt - \int_0^{k\pi} t|\sin t|dt \\ I &amp;= k\pi\int_0^{k\pi}|\sin t|dt - I \\ I &amp;= \frac{k\pi}{2}\int_0^{k\pi}|\sin t|dt \\ \end{aligned} ]$ 而积分 $(\displaystyle\int_0^{k\pi} |\sin t|dt = 2k)$ 是显然的$（一拱的面积为 (2)，(k) 拱的面积为 (2k)） 则 (I = k^2\pi)$，这个做法必上述递推要简单</p></blockquote><p>接着我们的任务就是 凑出题设的极限，然后 夹逼</p><p>$[ \lim_{x\to+\infty}\frac{k^2\pi}{x^2} \lt \lim_{x\to+\infty}\frac{\displaystyle\int_0^xt|\sin t|dt}{x^2} \lt \lim_{x\to+\infty}\frac{(k+1)^2\pi}{x^2} ]$</p><p>由 $kx k+ x - kx {x+} {x+} _{x+} $</p><p>$故 (\lim\limits_{x\to+\infty}\dfrac{k^2\pi}{x^2} = \dfrac{1}{\pi})，代入不等式中夹逼可得：(\lim\limits_{x\to+\infty}\dfrac{\displaystyle\int_0^xt|\sin t|dt}{x^2} = \dfrac{1}{\pi})$</p><hr><p>知道 O’Stolz定理（洛必达推广的离散型） 这题就变成 构造题 了</p><p>$令 (x_n = \displaystyle\int_0^{n\pi} t|\sin t|dt)，(y_n = x^2)，由于 (\{y_n\}) 单调递增，且 (\lim\limits_{n\to\infty} y_n = +\infty)$，由 O’Stolz 定理：</p><p>$[ \lim_{n\to+\infty} \frac{x_n}{y_n} = \lim_{n\to+\infty} \frac{x_{n+1} - x_n}{y_{n+1} - y_n} = \lim_{n\to+\infty} \frac{\dfrac{(2n+2)(n+1)\pi}{2} - \dfrac{n\cdot 2n\pi}{2}}{(n\pi + \pi)^2 - (n\pi)^2} = \dfrac{1}{\pi} ]$</p><p>再由 海涅定理 可知：</p><p>$[ \lim_{n\to+\infty} \frac{\displaystyle\int_0^xt|\sin t|dt}{x^2} = \lim_{n\to+\infty} \frac{x_n}{y_n} = \dfrac{1}{\pi} ]$</p><h2 id="题目227">题目227</h2><p>$[ \text{求极限 }\lim_{x\to+\infty}\sin\frac{1}{x}\cdot\int_x^{x^2} (1+\frac{1}{2t})^t\sin\frac{1}{\sqrt{t}}dt ]$</p><h3 id="解答-4">解答</h3><p>$[ \begin{aligned} &amp; \lim_{x\to+\infty}\sin\frac{1}{x}\cdot\int_x^{x^2} (1+\frac{1}{2t})^t\sin\frac{1}{\sqrt{t}}dt \\ =&amp; \lim_{x\to+\infty}[\frac{\displaystyle\int_x^{x^2} (1+\frac{1}{2t})^t\sin\frac{1}{\sqrt{t}}dt}{x}] \\ \xlongequal{L’}&amp; \lim_{x\to+\infty}[2x(1+\frac{1}{2x^2})^{x^2}\cdot \sin\frac{1}{x} - (1+\frac{1}{2x})^{x}\cdot \sin\frac{1}{\sqrt{x}}] \\ =&amp; \lim_{x\to+\infty}[2 \cdot e^{x^2\ln(1+\frac{1}{2x^2})} - e^{x\ln(1+\frac{1}{2x})}\cdot \frac{1}{\sqrt{x}}] \\ =&amp; 2\lim_{x\to+\infty}e^{x^2\ln(1+\frac{1}{2x^2})} - \lim_{x\to+\infty} e^{x\ln(1+\frac{1}{2x})}\cdot \frac{1}{\sqrt{x}} \\ =&amp; 2e^{\frac{1}{2}} - 0 \\ =&amp; 2e^{\frac{1}{2}} \\ \end{aligned} ]$</p><h2 id="题目228">题目228</h2><p>$[ \text{求极限 }\lim_{x\to+\infty}x(1-\frac{\ln x}{x})^x ]$</p><h3 id="解答1-暴力解">解答1(暴力解)</h3><p>$“(\infty \cdot 0)” 型，考虑倒代还化为 “(\dfrac{0}{0})” 型$</p><p>$令 (x = \dfrac{1}{t})，则：$</p><p>$[ \begin{aligned} \lim_{x\to+\infty} x(1-\frac{\ln x}{x})^x &amp;= \lim_{t\to0^+} \frac{(1+t\ln t)^{\dfrac{1}{t}}}{t} \\ &amp;= \lim_{t\to0^+} \frac{e^{\dfrac{\ln(1 + t\ln t)}{t}}}{t} \\ &amp;= \lim_{t\to0^+} \frac{e^{\dfrac{t\ln t - \frac{1}{2}t^2\ln^2 t + o(t^2\ln^2t)}{t}}}{t} \\ &amp;= \lim_{t\to0^+} \frac{e^{\ln t}}{t} \\ &amp;= \lim_{t\to0^+} \frac{t}{t} \\ &amp;= 1 \end{aligned} ]$</p><h3 id="解答2（取对数）">解答2（取对数）</h3><p>考虑乘积幂次都有的式子，不妨取对数，转化为加减法（求导里常用）</p><p>令 $(y = x(1-\dfrac{\ln x}{x})^x)$</p><p>$[ \begin{aligned} \lim_{x\to+\infty} \ln y &amp;= \lim_{x\to+\infty} [\ln x + x\ln(1 - \dfrac{\ln x}{x})] \\ &amp;= \lim_{x\to+\infty} x[\ln(1 - \dfrac{\ln x}{x}) - (-\dfrac{\ln x}{x})] \\ &amp;= \lim_{x\to+\infty} x[-\dfrac{1}{2}(-\dfrac{\ln x}{x})^2] \\ &amp;= -\frac{1}{2} \lim_{x\to+\infty} \dfrac{\ln^2 x}{x} \\ &amp;= 0 \end{aligned} ]$</p><p>$(\lim\limits_{x\to+\infty} \ln y = 0 \quad\Rightarrow\quad \lim\limits_{x\to+\infty} y = 1)$</p><h2 id="题目229">题目229</h2><p>$[ \text{求极限 }\lim_{x\to0}\Bigg(\frac{1 + \displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \frac{1}{\sin x}\Bigg) ]$</p><h3 id="解答-5">解答</h3><p>$[ \begin{aligned} \lim_{x\to0}\Bigg(\frac{1 + \displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \frac{1}{\sin x}\Bigg) &amp;= \lim_{x\to0}\Bigg(\frac{\displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \frac{\sin x - e^x + 1}{(e^x-1)\sin x}\Bigg) \\ &amp;= \lim_{x\to0} \frac{\displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \lim_{x\to0}\frac{\sin x - e^x + 1}{(e^x-1)\sin x} \\ &amp;= \lim_{x\to0} \frac{\displaystyle\int_0^xe^{t^2}dt}{x} - \lim_{x\to0}\frac{x - x - \dfrac{1}{2}x^2}{x^2} \\ &amp;= 1 - \dfrac{1}{2} \\ &amp;= \frac{1}{2} \end{aligned} ]$</p><h2 id="题目230">题目230</h2><p>$[ \lim_{x\to0}\Big[\frac{1}{\ln(x+\sqrt{1+x^2})} - \frac{1}{\ln(1+x) + \int_0^xt(1+t)^{\frac{1}{t}}dt}\Big] ]$</p><h3 id="解答-6">解答</h3><p>$[ \lim_{x\to0}\frac{\ln(x+\sqrt{1+x^2})}{x} = 1 \quad\Rightarrow\quad \ln(x+\sqrt{1+x^2}) \sim x ]$</p><p>$[ \lim_{x\to0}\frac{\int_0^xt(1+t)^{\frac{1}{t}}dt}{x} = 0 \quad\Rightarrow\quad \Big[ \ln(1+x) + \int_0^xt(1+t)^{\frac{1}{t}}dt\Big] \sim \ln(1+x) \sim x ]$</p><p>$[ \begin{aligned} &amp; \lim_{x\to0}\Big[\frac{1}{\ln(x+\sqrt{1+x^2})} - \frac{1}{\ln(1+x) + \displaystyle\int_0^xt(1+t)^{\frac{1}{t}}dt}\Big] \\ =&amp; \lim_{x\to0}\frac {\ln(1 + x) + \displaystyle\int_0^xt(1 + t)^{\frac{1}{t}}dt - \ln(x+\sqrt{1+x^2})} {x^2} \\ =&amp; \lim_{x\to0}\Bigg[\frac{\ln(1+x) - \ln(x+\sqrt{1+x^2})}{x^2}\Bigg] + \lim_{x\to0}\Bigg[\frac{\int_0^xt(1+t)^{\frac{1}{t}}dt}{x^2}\Bigg] \quad(极限的四则运算) \\ =&amp; \lim_{x\to0}\Bigg[\frac{\dfrac{1}{\xi}(1 - \sqrt{1+x^2})}{x^2}\Bigg] + \lim_{x\to0}\Bigg[\frac{x(1+x)^{\frac{1}{x}}}{2x}\Bigg] \quad\bigg(Lagrange中值定理\bigg) \\ =&amp; \lim_{x\to0}\Bigg(\frac{1 \cdot (-1)}{2\sqrt{1+x^2}}\Bigg) + \lim_{x\to0}\Bigg(\frac{e}{2}\Bigg) \quad(洛必达) \\ =&amp; \frac{e - 1}{2} \end{aligned} ]$</p><h2 id="题目231">题目231</h2><p>$[ \lim_{x\to+\infty} \bigg[{ (x^3 - x^2 + \dfrac{x}{2} + 1) e^{\frac{1}{x}} - \sqrt{x^6 + x^2 + x + 1} }\bigg] ]$</p><h3 id="解答-7">解答</h3><p>$[ \begin{aligned} &amp;\lim_{x\to+\infty} \bigg[{ (x^3 - x^2 + \dfrac{x}{2} + 1) e^{\frac{1}{x}} - x^3 + x^3 - \sqrt{x^6 + x^2 + x + 1} }\bigg] \\ =&amp; \lim_{x\to+\infty} x^3 [(1-\dfrac{1}{x} + \dfrac{1}{2x^2} + \dfrac{1}{x^3})e^{\frac{1}{x}} - \sqrt{1 + \dfrac{1}{x^4} + \dfrac{1}{x^5} + \dfrac{1}{x^6}}] \\ =&amp; \lim_{x\to+\infty} x^3 \cdot e^{\frac{1}{x}} [(1-\dfrac{1}{x} + \dfrac{1}{2x^2} + \dfrac{1}{x^3}) - e^{-\frac{1}{x}}\sqrt{1 + \dfrac{1}{x^4} + \dfrac{1}{x^5} + \dfrac{1}{x^6}}] \\ =&amp; \lim_{x\to+\infty} x^3 \cdot [(1-\dfrac{1}{x} + \dfrac{1}{2x^2} + \dfrac{1}{x^3}) - (1 - \dfrac{1}{x} + \dfrac{1}{2x^2} - \dfrac{1}{6x^3}) (1 + o(\dfrac{1}{x^3}))] \\ =&amp; \lim_{x\to+\infty} x^3 \cdot [\dfrac{7}{6} \cdot \dfrac{1}{x^3} + o(\dfrac{1}{x^3})] \\ =&amp; \dfrac{7}{6} \end{aligned} ]$</p><h2 id="题目232">题目232</h2><p>$[ \lim_{x \to 0} \frac{\ln(1+\sin^2 x) - 6(\sqrt[3]{2-\cos x} - 1)}{x^4} ]$</p><h3 id="解答-8">解答</h3><p>复合函数处理方法： 1. 强行泰勒展开（多项式计算量大） 2. 添项减项（精度随缘）</p><p>$[ \ln(1 + \sin^2 x) - \sin ^2x \sim -\dfrac{1}{2}\sin^4x \sim -\dfrac{1}{2}x^4 ]$</p><p>$[ (1 + x)^{\frac{1}{3}} - 1 - x \sim -\dfrac{1}{9} x^2 ]$</p><p>$[ [1 + (1 - \cos x)]^{\frac{1}{3}} - 1 - \dfrac{1}{3}(1 - \cos x)\sim -\dfrac{1}{9} (1 - \cos x)^2 \sim -\dfrac{1}{36} x^4 ]$</p><p>$[ \begin{aligned} &amp;\lim_{x \to 0} \frac{\ln(1+\sin^2 x) - 6(\sqrt[3]{2-\cos x} - 1)}{x^4} \\ =&amp; \lim_{x \to 0} \frac{\ln(1+\sin^2 x) - \sin^2x + 2(1-\cos x)- 6(\sqrt[3]{2-\cos x} - 1)+\sin^2x - 2(1 - \cos x) }{x^4} \end{aligned} ]$</p><p>$[ \dfrac{\sin^2x - 2 + 2\cos x}{x^4} = \dfrac{\cos x - 1}{2x^2} = -\dfrac{1}{4} ]$</p><p>$[ \begin{aligned} &amp; \lim_{x \to 0} \frac{\ln(1+\sin^2 x) - \sin^2x}{x^4} - \lim_{x \to 0} \frac{-2(1-\cos x) + 6(\sqrt[3]{2-\cos x} - 1)}{x^4} \\ +&amp; \lim_{x \to 0} \frac{\sin^2x - 2(1 - \cos x)}{x^4} \\ = &amp; -\dfrac{1}{2} + \dfrac{1}{6} + \dfrac{1}{4} = -\dfrac{7}{12} \end{aligned} ]$</p><h2 id="题目233">题目233</h2><p>$[ \lim_{x\to0} \int_0^x\Big(\frac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}\cot x dt ]$</p><h3 id="解答-9">解答</h3><p>$[ \begin{aligned} &amp; \lim_{x\to0} \int_0^x\Big(\frac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}\cot x dt \\ =&amp; \lim_{x\to0} \dfrac{\displaystyle\int_0^x \Big(\dfrac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}dt}{\tan x} \\ =&amp; \lim_{x\to0} \Big(\dfrac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}dt \\ &amp; \lim_{x\to0} \dfrac{\ln(\dfrac{\arctan t}{t})}{\displaystyle\int_0^t \ln(1+u)du} \\ =&amp; \lim_{x\to0} \dfrac{\arctan t - t}{t\displaystyle\int_0^t udu} \\ =&amp; -\dfrac{2}{3} \\ &amp; \lim_{x\to0} \int_0^x\Big(\frac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}\cot x dt \\ =&amp; e^{-\frac{2}{3}} \end{aligned} ]$</p><h2 id="题目234">题目234</h2><p>$[ \lim_{x\to+\infty}\Big[\frac{\ln(x+\sqrt{x^2+1})}{\ln(x+\sqrt{x^2-1})}\Big]^{x^2\ln x} ]$</p><h3 id="解答-10">解答</h3><p>$[ \lim\limits_{x\to+\infty}\frac{\ln(x+\sqrt{x^2-1})}{\ln x} = 1 \quad\Rightarrow\quad \ln(x+\sqrt{x^2-1}) \sim \ln x ]$</p><p>$[ \lim\limits_{x\to+\infty}\frac{\sqrt{x^2+1} - \sqrt{x^2-1}}{\frac{1}{x}} = 1 \quad\Rightarrow\quad \sqrt{x^2+1} - \sqrt{x^2-1} \sim \dfrac{1}{x} ]$</p><p>$[ \begin{aligned} 原式 &amp;= \lim_{x\to+\infty} e^{x^2\ln x\cdot\ln(\frac{\ln(x+\sqrt{x^2+1})}{\ln(x+\sqrt{x^2-1})})} \quad(幂指函数互化) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\ln x\cdot (\frac{\ln(x+\sqrt{x^2+1}) - \ln(x+\sqrt{x^2-1})}{\ln(x+\sqrt{x^2-1})})} \quad(等价无穷小代换) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\ln x\cdot (\frac{\ln(x+\sqrt{x^2+1}) - \ln(x+\sqrt{x^2-1})}{\ln x})} \quad(\ln(x+\sqrt{x^2-1}) \sim \ln x) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\cdot \Big((\ln(x+\sqrt{x^2+1}) - \ln(x+\sqrt{x^2-1})\Big)} \quad = e^{\lim\limits_{x\to+\infty}x^2\cdot \ln\frac{x+\sqrt{x^2+1}}{x+\sqrt{x^2-1}}} \quad (\ln\frac{A}{B} = \ln A - \ln B) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\cdot \frac{x+\sqrt{x^2+1} - x - \sqrt{x^2-1}}{x+\sqrt{x^2-1}}} \quad = e^{\lim\limits_{x\to+\infty}x^2\cdot \frac{\sqrt{x^2+1} - \sqrt{x^2-1}}{x+\sqrt{x^2-1}}} \quad(等价无穷小代换) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\cdot \frac{\frac{1}{x}}{x+\sqrt{x^2-1}}} \quad = e^{\lim\limits_{x\to+\infty}\frac{x}{x+\sqrt{x^2-1}}} \quad(\sqrt{x^2+1} - \sqrt{x^2-1} \sim \dfrac{1}{x}) \\ &amp;= e^{\frac{1}{2}} \end{aligned} ]$</p><h2 id="题目235">题目235</h2><p>$设 (f(x)) 连续, (\lim\limits_{x\to0}\dfrac{f(x)}{x}=1) ,求极限 (\lim\limits_{x\to0}\Big[ 1+\displaystyle\int_0^xtf(x^2-t^2)dt \Big]^{\dfrac{1}{(\tan x - x)\ln(1+x)}})$</p><h3 id="解答-11">解答</h3><p>$(f(x)) 连续 (\&amp;) $_{x0}=1 $ (\quad \Rightarrow \quad) (f(0) = 0) 且 (f’(0) = 1)$</p><p>幂指函数，先取指对数，然后单独处理指数部分</p><p>$[ \begin{aligned} &amp; \lim_{x\to0} \dfrac{\ln(1 + \displaystyle\int_0^x tf(x^2 - t^2)dt)}{(\tan x - x) \ln(1 + x)} \\ =&amp; \lim_{x\to0} \dfrac{\displaystyle\int_0^x tf(x^2 - t^2)dt}{\dfrac{1}{3}x^4} \\ &amp; \text{令} x^2 - t^2 = u, \text{则} -2tdt = du \\ =&amp; \dfrac{3}{2} \lim_{x\to0} \dfrac{\displaystyle\int_0^{x^2} f(u)du}{x^4} \\ \xlongequal{L’}&amp; \dfrac{3}{4} \lim_{x\to0} \dfrac{f(x^2)}{x^2} \\ =&amp; \dfrac{3}{4} \lim_{x\to0} \dfrac{f(x^2) - f(0)}{x^2 - 0} \\ =&amp; \dfrac{3}{4} f_+'(0) \\ =&amp; \dfrac{3}{4} \\ \end{aligned} ]$</p><p>故 $(\lim\limits_{x\to0}\Big[ 1+\displaystyle\int_0^xtf(x^2-t^2)dt \Big]^{\dfrac{1}{(\tan x - x)\ln(1+x)}} = e^{\frac{3}{4}})$</p><h2 id="题目236">题目236</h2><p>$[ \lim_{x\to+\infty} \Big(x^{\frac{1}{x}} - 1\Big)^{\frac{1}{\ln x}} ]$</p><h3 id="解答-12">解答</h3><p>这里介绍一个 <strong>对数函数的等价无穷大技巧</strong>：</p><p>$若 (x \to x_0) 时，(A) 与 (B) 是等价无穷小 （(A \sim B)），则 (\ln A) 与 (\ln B) 是 等价无穷大$</p><p>证明：</p><p>$[ \text{欲证：}\lim_{x\to x_0} \dfrac{\ln A}{\ln B} = 1,\text{不妨证} \lim_{x\to x_0} \dfrac{\ln A}{\ln B} - 1 = 0 ]$</p><p>$[ \lim_{x\to x_0} \dfrac{\ln A}{\ln B} - 1 = \lim_{x\to x_0} \dfrac{\ln A - \ln B}{\ln B} = \lim_{x\to x_0} \dfrac{\ln\dfrac{A}{B}}{\ln B} = \dfrac{0}{\infty} = 0 \quad QED ]$</p><p>在本题中，取过指对数后，可利用该技巧：</p><p>$[ \begin{aligned} &amp;\lim_{x\to +\infty} \dfrac{\ln (e^{\dfrac{\ln x}{x}} - 1)}{\ln x} \\ =&amp;\lim_{x\to +\infty} \dfrac{\ln ({\dfrac{\ln x}{x}})}{\ln x} \\ =&amp; \lim_{x\to +\infty} \dfrac{\ln\ln x - \ln x}{\ln x} \\ \xlongequal{L’}&amp; \lim_{x\to +\infty} \dfrac{1 - \ln x}{\ln x} \\ =&amp; -1 \end{aligned} ]$</p><p>故原式 = $(e^{-1})$</p><h2 id="题目237">题目237</h2><p>若 $(\lim\limits_{x\to0}\dfrac{\cos(xe^x)-e^{-\dfrac{x^2e^{2x}}{2}}}{x^\alpha}= \beta\ne0)，求 (\alpha,\beta)$</p><h3 id="解答-13">解答</h3><blockquote><p>已知极限反求参数，<strong>不能使用洛必达，不能使用洛必达，不能使用洛必达</strong> 这个行为违背了洛必达的 <strong>先验性</strong> 在已知极限的情况下，再洛必达获得的新极限，不一定与原极限相等</p></blockquote><p>由泰勒展开：</p><p>$[ \cos(xe^x) = 1 - \dfrac{1}{2} (x^2e^{2x}) + \dfrac{1}{24}x^4e^{4x} + o(x^4e^{4x}) ]$</p><p>$[ e^{-\dfrac{x^2e^{2x}}{2}} = 1 - \dfrac{1}{2}(x^2e^{2x}) + \dfrac{1}{8}(x^4e^{4x}) + o(x^4e^{4x}) ]$</p><p>可以推得：</p><p>$[ \cos(xe^x)-e^{-\dfrac{x^2e^{2x}}{2}} \sim -\dfrac{1}{12}x^4e^{4x} ]$</p><p>故：</p><p>$[ \lim\limits_{x\to0}\dfrac{\cos(xe^x)-e^{-\dfrac{x^2e^{2x}}{2}}}{x^\alpha} = \lim\limits_{x\to0} \dfrac{-\dfrac{1}{12}x^4}{x^\alpha} = \beta \ne 0 ]$</p><p>由于 极限存在，且不为 $(0)$，故 $(\alpha = 4, \beta = - \dfrac{1}{12})$</p><h2 id="题目238">题目238</h2><p>$[ \lim_{x\to0}\frac{\cos 2x - \cos x\sqrt{\cos 2x}}{x^k} = a \ne 0,\text{求k,a} ]$</p><h3 id="解答-14">解答</h3><p>对 <strong>分子</strong> 恒等变形：</p><p>$[ \begin{aligned} \cos 2x - \cos x\sqrt{\cos 2x} &amp;= \sqrt{\cos 2x} \cdot (\sqrt{\cos 2x} - \cos x) \\ &amp;= \sqrt{\cos 2x} \cdot \dfrac{\cos 2x - \cos^2 x}{\sqrt{\cos 2x} + \cos x} \\ &amp;= \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot (2\cos^2 x - 1 - \cos^2 x) \\ &amp;= \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot (\cos^2 x - 1) \\ &amp;= \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot (- \sin^2 x) \\ \end{aligned} ]$</p><p>故原式为</p><p>$[ \begin{aligned} \lim_{x\to0}\frac{\cos 2x - \cos x\sqrt{\cos 2x}}{x^k} &amp;= \lim_{x\to0} \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot \frac{(- \sin^2 x)}{x^k} \\ &amp;= -\dfrac{1}{2} \lim_{x\to0} \frac{\sin^2 x}{x^k} \\ &amp;= -\dfrac{1}{2} \lim_{x\to0} \frac{x^2}{x^k} \\ \end{aligned} ]$</p><p>由于 <strong>极限存在</strong>，故 $(k = 2, a = -\dfrac{1}{2})$</p><h2 id="题目239">题目239</h2><p>若 $(\lim\limits_{x\to0}\dfrac{ax^2+bx+1-e^{x^2-2x}}{x^2}=2)$,求$(a,b)$的值</p><h3 id="解答-15">解答</h3><p>由 <strong>泰勒展开</strong>：</p><p>$[ e^{x^2 - 2x} - 1 = x^2 - 2x + \dfrac{1}{2}(x^2 - 2x)^2 + o(x)^2 = 3x^2 - 2x + o(x^2) ]$</p><p>故可对原式进行 <strong>泰勒展开</strong>：</p><p>$[ \lim\limits_{x\to0}\dfrac{ax^2+bx+1-e^{x^2-2x}}{x^2} = \lim\limits_{x\to0}\dfrac{(a - 3)x^2+(b + 2)x}{x^2} ]$</p><p>极限存在，故 $(b = -2, a = 5)$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第211-223题</title>
      <link href="/2022/06/04/%E6%AD%A6%E9%92%9F%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC211-223%E9%A2%98/"/>
      <url>/2022/06/04/%E6%AD%A6%E9%92%9F%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC211-223%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目211">题目211</h2><p>设 $(f(x)=1-\cos{x})$，求极限 $(\lim\limits_{x\to0}\dfrac{(1-\sqrt{\cos{x}})(1-\sqrt[3]{\cos{x}})(1-\sqrt[4]{\cos{x}})(1-\sqrt[5]{\cos{x}})}{f\{f[f(x)]\}})$</p><h3 id="解答-140">解答</h3><p>当 $(x \to 0)$ 时：</p><p>$[ 1-\sqrt{\cos x} \sim 1 - (1 - \frac{1}{2}x^2)^{\frac{1}{2}} \sim -(-\frac{1}{4})x^2 = \frac{1}{4}x^2 ]$</p><p>同理，由此推导可证得：$(1 - \cos^\alpha x \sim \dfrac{1}{2} \alpha x^2)$</p><p>$[ \begin{aligned} \text{原式} &amp;= \frac {\dfrac{1}{4} \cdot \dfrac{1}{6} \cdot \dfrac{1}{8} \cdot \dfrac{1}{10} \cdot x^8} {1 - \cos(f[f(x)])} \\ &amp;= \frac {\dfrac{x^8}{1920}} {\dfrac{1}{2}[1 - \cos f(x)]^2} \\ &amp;= \frac {\dfrac{x^8}{1920}} {\dfrac{1}{2}[\dfrac{1}{2}(1 - \cos x)^2]^2} \\ &amp;= \frac {\dfrac{x^8}{1920}} {\dfrac{1}{128} \cdot x^8} \\ &amp;= \frac{1}{15} \\ \end{aligned} ]$</p><h2 id="题目-212">题目 212</h2><p>$[ \text{求极限 } \lim_{x\to0}\frac{\tan(\sin x) - x}{\arctan x - \arcsin x} ]$</p><h3 id="解答-141">解答</h3><p>该极限为 $(\dfrac{0}{0})$ 型极限，常用方法有：</p><ol><li>洛必达法则</li><li>等价无穷小</li><li>泰勒展开<br>$[ \tan x - x \sim \frac{1}{3}x^3 \quad\Rightarrow\quad \tan(\sin x) - \sin x \sim \frac{1}{3}\sin^3x ]$</li></ol><p>由以上 等价无穷小，我们可以考虑 加减交叉项 凑出需要的形式</p><p>$[ \begin{aligned} \text{原式} &amp;= \lim_{x\to 0} \frac{\tan(\sin x) - \sin x + \sin x - x}{-\dfrac{1}{3}x^3 - \dfrac{1}{6}x^3} \\ &amp;= -2\lim_{x\to 0} \frac{\tan(\sin x) - \sin x}{x^3} -2\lim_{x\to 0} \frac{\sin x - x}{x^3} \\ &amp;= -2\lim_{x\to 0} \frac{\dfrac{1}{3}\sin^3 x}{x^3} -2\lim_{x\to 0} \frac{-\dfrac{1}{6}x^3}{x^3} \\ &amp;= -\frac{2}{3} + \frac{1}{3} \\ &amp;= -\frac{1}{3} \\ \end{aligned} ]$</p><h2 id="题目-213">题目 213</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{\sqrt[4]{1-\sqrt[3]{1-\sqrt{1-x}}} - 1} {(1+x)^\frac{1}{\sqrt[3]{x^2}} - 1} ]$$</p><h3 id="解答-142">解答</h3><p>$[ \sqrt[4]{1-\sqrt[3]{1-\sqrt{1-x}}} - 1 \sim \sqrt[4]{1-\sqrt[3]{\frac{1}{2}x}} - 1 \sim -\frac{1}{2^{\frac{7}{3}}}x^{\frac{1}{3}} ]$</p><p>$[ (1+x)^\frac{1}{\sqrt[3]{x^2}} - 1 \sim x^{\frac{1}{3}} ]$</p><p>$[ \text{原式} = \lim_{x\to0}\frac{-\dfrac{1}{2^{\frac{7}{3}}}x^{\frac{1}{3}}}{x^{\frac{1}{3}}} = -\frac{1}{2^{\frac{7}{3}}} ]$</p><h2 id="题目-214">题目 214</h2><p>$$[ \lim_{x\to0}\frac{(3+\sin x^2)^x-3^{\sin x}}{x^3} ]$$</p><h3 id="解答-143">解答</h3><p>底数相同 的 幂指函数 相减，一般考虑 左提右式 或 拉格朗日中值定理（不推荐）</p><p>$[ \begin{aligned} \lim_{x\to0}\frac{(3+\sin x^2)^x-3^{\sin x}}{x^3} &amp;= \lim_{x\to0}\frac{e^{x\ln(3+\sin x^2)} - e^{\sin x\ln 3}}{x^3} \\ &amp;= \lim_{x\to0}\frac{e^{\sin x\ln 3}[x\ln(3+\sin x^2) - \sin x\ln 3]}{x^3} \\ &amp;= \lim_{x\to0}\frac{x\ln(3+\sin x^2) - x\ln 3 - (\sin x\ln 3 - x\ln 3)}{x^3} \\ &amp;= \lim_{x\to0}\frac{x\cdot [\ln(3+\sin x^2) - \ln 3]}{x^3} - \ln 3\cdot \lim_{x\to0}\frac{\sin x - x}{x^3} \\ &amp;= \lim_{x\to0}\frac{x\cdot \ln(1+\dfrac{\sin x^2}{3})}{x^3} + \frac{\ln 3}{6} \\ &amp;= \lim_{x\to0}\frac{x \cdot \sin x^2}{3x^3} + \frac{\ln 3}{6} \\ &amp;= \frac{1}{3} + \frac{\ln 3}{6} \\ &amp;= \frac{2 + \ln 3}{6} \\ \end{aligned} ]$</p><h2 id="题目-215">题目 215</h2><p>$$[ \text{求极限 }\lim_{x\to 1}\frac{x - x^x}{1 - x + \ln x} ]$$</p><h3 id="解答-144">解答</h3><p>先处理分子：</p><p>$[ \lim_{x\to 1}\frac{x - x^x}{1 - x + \ln x} = \lim_{x\to 1}x \cdot \frac{1 - x^{x - 1}}{1 - x + \ln x} = -\lim_{x\to 1}\frac{e^{(x-1)\ln x} - 1}{1 - x + \ln x} = -\lim_{x\to 1}\frac{(x-1)\ln x}{1 - x + \ln x} ]$</p><p>不妨换元，令 $(t = x - 1)，则 (x = 1 + t)$</p><p>$[ \text{原式}= -\lim_{t\to0} \frac {t\ln(1 + t)} {ln(1 + t) - t} = -\lim_{t\to0} \frac {t^2} {\bigg(t - \dfrac{1}{2}t^2 + o(t^2)\bigg) - t} = 2 ]$</p><h2 id="题目-216">题目 216</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{(1+x)^{\frac{2}{x}} - e^2[1 - \ln(1+x)]}{x} ]$$</p><h3 id="解答-145">解答</h3><p>$$[ \begin{aligned} \lim_{x\to0}\frac{(1+x)^{\frac{2}{x}} - e^2[1 - \ln(1+x)]}{x} &amp;= \lim_{x\to0}\frac{e^{\frac{2\ln(1 + x)}{x}} - e^2[1 - \ln(1+x)]}{x} \\ &amp;= e^2 \cdot \lim_{x\to0}\frac{e^{\frac{2\ln(1 + x) - 2x}{x}} - 1 + \ln(1+x)}{x} \\ &amp;= e^2 \cdot \lim_{x\to0}\frac{e^{\frac{2\ln(1 + x) - 2x}{x}} - 1}{x} + e^2 \cdot \lim_{x\to0}\frac{\ln(1+x)}{x} \\ &amp;= e^2 \cdot \lim_{x\to0}\frac{2\ln(1 + x) - 2x}{x^2} + e^2 \\ &amp;= -e^2 + e^2 \\ &amp;= 0 \end{aligned} ]$$</p><h2 id="题目-217">题目 217</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{(1+x)^{\frac{1}{x}} - (1 + 2x)^{\frac{1}{2x}}}{\sin x} ]$$</p><h3 id="解答-146">解答</h3><p>$$[ \begin{aligned} \lim_{x\to0}\frac{(1+x)^{\frac{1}{x}} - (1 + 2x)^{\frac{1}{2x}}}{\sin x} &amp;= \lim_{x\to0}\frac{e^{\frac{\ln(x + 1)}{x}} - e^{\frac{\ln(2x + 1)}{2x}}}{x} \\ &amp;= \lim_{x\to0} e^{\frac{\ln(2x + 1)}{2x}} \cdot \frac{e^{\frac{2\ln(x + 1) - \ln(2x + 1)}{2x}} - 1}{x} \\ &amp;= e\cdot \lim_{x\to0} \frac{2\ln(x + 1) - \ln(2x + 1)}{2x^2} \\ &amp;= e\cdot \lim_{x\to0} \frac{2x -x^2 - 2x + 2x^2 + o(x^2)}{2x^2} \\ &amp;= \frac{e}{2} \end{aligned} \ ] $$</p><h2 id="题目-218">题目 218</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{x\sin x^2 - 2(1 - \cos x)\sin x}{x^5} ]$$</p><h3 id="解答-147">解答</h3><p>$[ x\sin x^2 = x^3 - \dfrac{1}{6}x^6 + o(x^6) \quad ]$</p><p>$[ 2(1 - \cos x) \sin x = (x^2 - \dfrac{1}{12}x^4 + o(x^4)) \cdot (x - \dfrac{1}{6}x^3 + o(x^3)) = x^3 - (\frac{1}{6} + \frac{1}{12}) x^5 + o(x^5) ]$</p><p>$[ \lim_{x\to0}\frac{x\sin x^2 - 2(1 - \cos x)\sin x}{x^5} = \lim_{x\to0}\frac{x^3 - \dfrac{1}{6}x^6 - x^3 + \dfrac{1}{4}x^5 + o(x^5)}{x^5} = \frac{1}{4} ]$</p><h2 id="题目-219">题目 219</h2><p>设 $(f’(0) = 0), (f’'(0))$存在, 求极限 $ _{x0} $</p><h3 id="解答-148">解答</h3><p>“f-f” 型 同名函数 相减，考虑 拉格朗日中值定理</p><p>然后，通过题干给出的条件，建立等式</p><p>由于 $(f’‘(0))$ 存在，故 $(f’(x))$ 在点 $(x=0)$ 处 连续 （可导 $(\Rightarrow)$ 连续）</p><p>故 $(\lim\limits_{x\to 0}f’(x) = f’(0))$</p><p>先由 $(Lagrange)$ 中值定理可得：</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\dfrac{f(x) - f(\ln(1 + x))}{x^3} &amp;= \lim\limits_{x\to0}\dfrac{f’(\xi)(x - \ln(1+x))}{x^3} \end{aligned} ]$</p><p>其中 $(\ln(1 + x) &lt; \xi &lt; x)$，两侧同除 x 取极限 ，然后 夹逼，可得:</p><p>$[ \lim\limits_{x\to 0}\dfrac{\ln(1 + x)}{x} &lt; \lim\limits_{x\to 0} \dfrac{\xi}{x} &lt; \lim\limits_{x\to 0}\dfrac{x}{x} \quad\Rightarrow\quad \lim\limits_{x\to 0} \dfrac{\xi}{x} = 1 \quad\Rightarrow\quad \xi \sim x \quad(x\to 0) ]$</p><p>最后用 导数定义 收尾：</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\dfrac{f’(\xi)(x - \ln(1+x))}{x^3} &amp;= \dfrac{1}{2} \lim\limits_{x\to0} \dfrac{f’(\xi)}{x} \\ &amp;= \dfrac{1}{2} \lim\limits_{x\to0} \dfrac{f’(\xi) - f’(0)}{\xi} \cdot \dfrac{\xi}{x} \\ &amp;= \dfrac{1}{2} \lim\limits_{x\to0} \dfrac{f’(\xi) - f’(0)}{\xi - 0} \cdot 1 \\ &amp;= \dfrac{1}{2} f’'(0) \\ \end{aligned} ]$</p><h2 id="题目-220">题目 220</h2><p>$[ \lim_{x\to0^+}\frac{\sqrt{a}\arctan\sqrt{\dfrac{x}{a}}-\sqrt{b}\arctan\sqrt{\dfrac{x}{b}}}{x\sqrt{x}} ]$</p><h3 id="解答-149">解答</h3><p>$[ \arctan x = x - \dfrac{1}{3}x^3 \quad \Rightarrow \quad \arctan \sqrt{\dfrac{x}{a}} = \sqrt{\dfrac{x}{a}} - \dfrac{x^{\frac{3}{2}}}{3a^{\frac{3}{2}}} + o(x^{\frac{3}{2}}) ]$</p><p>根据上述推导，可对等式中的分子进行如下变形：</p><p>$[ \sqrt{a}\arctan\sqrt{\dfrac{x}{a}}-\sqrt{b}\arctan\sqrt{\dfrac{x}{b}} = x^{\frac{1}{2}} - \dfrac{x^{\frac{3}{2}}}{3a} - x^{\frac{1}{2}} + \dfrac{x^{\frac{3}{2}}}{3b} + o(x^{\frac{3}{2}}) = \dfrac{a - b}{3ab} x^{\frac{3}{2}} + o(x^{\frac{3}{2}}) ]$</p><p>刚好展开到分母对应的阶数，于是就做完了</p><p>$[ \lim_{x\to0^+}\frac{\sqrt{a}\arctan\sqrt{\dfrac{x}{a}}-\sqrt{b}\arctan\sqrt{\dfrac{x}{b}}}{x\sqrt{x}} = \dfrac{a - b}{3ab} ]$</p><h2 id="题目-221">题目 221</h2><p>设函数 $(f(x))$ 连续, 且$(f(0)\ne0)$, 求极限 $(\lim\limits_{x\to0}\dfrac{x\int^x_{0}f(x-t)dt}{\int_0^xtf(x-t)dt})$</p><h3 id="解答-150">解答</h3><p>极限中有 变上限积分，考虑用 洛必达法则 求导消掉积分符号</p><p>然后分母的 被积函数 中含有 $(x)$，考虑对积分变量换元，从而分离出 $(x)$</p><p>令 $(x - t = u)$，则 $(-dt = du)$，有</p><p>$[ \int_0^xf(x-t)dt = \int_0^xf(u)du ]$</p><p>$[ \int_0^xtf(x-t)dt = \int_0^x(x - u)f(u)du = x\int_0^xf(u)du - \int_0^x uf(u)du ]$</p><p>拆分好后，按照先前给出的思路，洛必达 即可</p><p>$[ \lim\limits_{x\to0}\dfrac{x\int_0^xf(u)du}{x\int_0^xf(u)du - \int_0^x uf(u)du} = \lim\limits_{x\to0}\dfrac{\int_0^xf(u)du + xf(x)}{\int_0^xf(u)du} ]$</p><p>这里没说 (f(x)) 可导，再洛就寄了，考虑 积分中值定理 来去掉 积分符号</p><p>$(\exists \xi \in (0,x), s.t. xf(\xi) = \int_0^x f(u)du)$，则原式 $ = {x0} = {x0}$</p><p>又由于 $(f(x))$ 连续，且 $(f(0) \ne 0)$，故 $(\lim\limits_{\xi \to 0} f(\xi) = f(0) \ne 0)$</p><p>于是，原式 $ $ = _{(, x) (0,0)} = = 2$ $</p><h2 id="题目-222">题目 222</h2><p>$设函数 (f(x)) 连续, 且(f(0)\ne0), 求极限 (\lim\limits_{x\to0}\dfrac{x\int^x_{0}f(x-t)dt}{\int_0^xtf(x-t)dt})$</p><h3 id="解答-151">解答</h3><p>极限中有 变上限积分，考虑用 洛必达法则 求导消掉积分符号</p><p>然后分母的 被积函数 中含有 $(x)$，考虑对积分变量换元，从而分离出 $(x)$</p><p>令 $(x - t = u)$，则 $(-dt = du)$，有</p><p>$[ \int_0^xf(x-t)dt = \int_0^xf(u)du ]$</p><p>$[ \int_0^xtf(x-t)dt = \int_0^x(x - u)f(u)du = x\int_0^xf(u)du - \int_0^x uf(u)du ]$</p><p>拆分好后，按照先前给出的思路，洛必达 即可</p><p>$[ \lim\limits_{x\to0}\dfrac{x\int_0^xf(u)du}{x\int_0^xf(u)du - \int_0^x uf(u)du} = \lim\limits_{x\to0}\dfrac{\int_0^xf(u)du + xf(x)}{\int_0^xf(u)du} ]$</p><p>这里没说 $(f(x))$ 可导，再洛就寄了，考虑 积分中值定理 来去掉 积分符号</p><p>$(\exists \xi \in (0,x), s.t. xf(\xi) = \int_0^x f(u)du)$，则原式 $ = {x0} = {x0}$</p><p>又由于 $(f(x))$ 连续，且 $(f(0) \ne 0)$，故 $(\lim\limits_{\xi \to 0} f(\xi) = f(0) \ne 0)$</p><p>于是，原式 =  2</p><h2 id="题目-223">题目 223</h2><p>$设函数 (f(x)) 连续,且(\lim\limits_{x\to0}\dfrac{f(x)}{x} = 2), 求极限 (\lim\limits_{x\to0}\dfrac{\displaystyle\int_0^xe^{xt}\arctan(x-t)^2dt}{\displaystyle\int_0^xtf(x-t)dt})$</p><h3 id="解答-152">解答</h3><p>由函数 $(f(x))$ 连续 及 $(\lim\limits_{x\to0}\dfrac{f(x)}{x} = 2)$，易知：$(\lim\limits_{x\to0}f(x)=f(0)=0)$</p><p>再由 导数定义，可得：$(f’(0) = \lim\limits_{x\to0}\dfrac{f(x) - f(0)}{x - 0} = 2)$</p><p>变上限积分函数 求极限，考虑 洛必达法则 求导去积分符号</p><p>分子的 变上限积分函数 中，既有 $(xt)$ 又有 $(x-t)$，换元法 不能同时消掉，故考虑 广义积分中值定理</p><p>由 广义积分中值定理 $(\displaystyle\int_a^b f(x)g(x)dx = f(\xi) \displaystyle\int_a^b g(x)dx)$，其中 $(g(x))$ 在 $((a,b))$ 上不变号</p><p>易知在 $(x\to 0)$ 时，$(\arctan(x-t)^2)$ 不变号，于是有：</p><p>$(\displaystyle\int_0^xe^{xt}\arctan(x-t)^2dt = e^{x\xi}\displaystyle\int_0^x\arctan(x-t)^2dt)，其中 (\xi\in(0,x))$</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\frac{\displaystyle\int_0^xe^{xt}\arctan(x-t)^2dt}{\displaystyle\int_0^xtf(x-t)dt} &amp;= e^0 \cdot \lim\limits_{x\to0}\frac{\displaystyle\int_0^x\arctan(x-t)^2dt}{\displaystyle\int_0^xtf(x-t)dt} \\ &amp;= \lim\limits_{x\to0}\frac{\displaystyle\int_0^x\arctan u^2du}{x\displaystyle\int_0^xf(u)du - \displaystyle\int_0^x uf(u)du} \\ &amp;= \lim\limits_{x\to0}\frac{\arctan x^2}{xf(x) + \displaystyle\int_0^xf(u)du - xf(x)} \\ &amp;= \lim\limits_{x\to0}\frac{x^2}{\displaystyle\int_0^xf(u)du} \\ &amp;= \lim\limits_{x\to0}\frac{2x}{f(x)} = 2 \cdot \lim\limits_{x\to0}\frac{1}{\dfrac{f(x) - f(0)}{x - 0}} \\ &amp;= \frac{2}{f’(0)} \\ &amp;= 1 \end{aligned} ]$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘与大数据分析复习</title>
      <link href="/2022/05/27/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/27/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题型">题型</h2><ul><li>选择题——单选、多选</li><li>大题——2道计算题 大部分是简答题 最后一题是综合题</li></ul><blockquote><ul><li>决策树的流程</li><li>聚类有哪些类型</li><li>数据挖掘的任务有哪些~</li><li>关联规则挖掘</li><li>分类/预测 与 回归</li><li>聚类分析</li><li>孤立点检测</li></ul></blockquote><h2 id="第一章-数据挖掘与大数据简介">第一章 数据挖掘与大数据简介</h2><p><img src="https://img-blog.csdnimg.cn/20210604113812714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzA0OTQy,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="复习提纲">复习提纲</h3><ol><li>基本概念<ul><li>什么是大数据</li><li>什么是数据挖掘</li></ul></li><li>大数据的4V特征</li><li>数据挖掘的主要任务</li><li>KDD过程（数据挖掘是核心）</li><li>DM（数据挖掘）挑战</li><li>数据挖掘和多个学科的融合</li></ol><h3 id="基本概念">基本概念</h3><h4 id="什么是大数据">什么是大数据</h4><p>大数据是一个流行词，或称流行语，用来描述大量的结构化和非结构化数据，这些数据如此之大，<br>很难使用传统的数据库和软件技术进行处理<br>无法在<strong>一定时间内用常规软件工具</strong>对其内容进行<strong>抓取，管理，处理</strong>的数据集合<br>是要更新处理模式才能具有更强的决策力，洞察发现力，流程优化能力来适应海量，高增长率，多样化的信息资产</p><h4 id="什么是数据挖掘">什么是数据挖掘</h4><p>从<strong>大量</strong>数据中挖掘那些<strong>令人感兴趣的，有用的，隐含的，先前未知的，可能有用的模式或者知识</strong></p><p>关键是从“大量的数据中挖掘令人感兴趣的模式或知识”<br><strong>注意</strong>：并非所有数据分析都是“数据挖掘”</p><ul><li>查询处理</li><li>专家系统或者是数学计算/统计程序</li></ul><h4 id="大数据的4V特征">大数据的4V特征</h4><ul><li>规模性</li><li>多样性</li><li>高速性</li><li>价值性</li></ul><h3 id="数据挖掘主要任务">数据挖掘主要任务</h3><ol><li><strong>关联规则分析</strong> 发掘数据之间的关联规则，如挖掘空气质量和气象条件之间的关系</li><li><strong>聚类分析</strong> 将数据归为不同的类，形成新的类别进行分析，最大化<strong>类内相似性</strong>和最小化<strong>类间相似性</strong></li><li><strong>分析 回归 预测</strong> 找出描述和区分数据类或者概念的模型 让该模型可以预测未知的对象类标签</li><li><strong>离群点分析</strong> 分析孤立而原本会被当作噪音丢弃的数据 在欺骗检测中通过孤立点分析得到的结论</li></ol><blockquote><p>这些内容在之后的章节都会讲到</p></blockquote><h3 id="（重点）KDD过程（知识发现过程）">（重点）KDD过程（知识发现过程）</h3><p>KDD：从数据中获取知识</p><ol><li>数据清理：消除噪声和删除不一致的数据</li><li>数据集成： 多种数据源可以组合在一起</li><li>数据选择：从数据库中提取与分析任务相关的数据</li><li>数据变化：把数据变换和统一成适合挖掘的形式</li><li><strong>数据挖掘</strong>：核心步骤，<strong>使用智能方法提取数据模式</strong></li></ol><blockquote><p>知识发现的核心是数据挖掘！</p></blockquote><ol start="6"><li>模式评估：根据兴趣度度量，识别代表知识的真正有趣的模式</li><li>知识表示：使用可视化和知识表示技术，向用户提供挖掘的知识</li></ol><blockquote><p>注意数据挖掘是核心</p></blockquote><h3 id="数据挖掘挑战">数据挖掘挑战</h3><p>数据<strong>容量</strong> <code>Scale of Data</code>——VOLUMN<br>数据的实时性 <code>Data Stream</code> ——VELOCITY<br>数据的多样性<code>Different format of data different sources</code>——VARIETY<br>数据的不确定性 <code> Uncertainty, missing value</code></p><h3 id="数据挖掘与多个学科融合">数据挖掘与多个学科融合</h3><ul><li>机器学习，数据库系统，信息检索</li><li>统计学，物理学，其他学科</li></ul><h2 id="第二章-认识数据和数据预处理">第二章 认识数据和数据预处理</h2><h3 id="复习提纲-2">复习提纲</h3><ol><li>属性类型</li><li>数据的统计描述</li></ol><ul><li>中心性<ul><li>均值</li><li>众数</li><li>中位数</li><li>中列数</li></ul></li><li>散度<ul><li>极差</li><li>最小</li><li>最大</li><li>四分位</li><li>百分位</li><li>方差</li></ul></li></ul><ol start="3"><li>相似性度量</li></ol><ul><li>标称<code>d(i,j)=#不同/# 总</code></li><li>数值<ul><li>欧式</li><li>曼哈顿</li></ul></li><li>数据标准化<ul><li>最大最小法</li><li>Z-Score</li></ul></li><li>其他相似性<ul><li>余弦相似性</li><li>马氏距离</li><li>相关散度</li><li>KL散度</li></ul></li><li>数据预处理<br>清理$\to$集成$\to$规约$\to$变换$\to$离散化</li><li>清理：缺值，噪声</li><li>集成：相关分析，卡方分析</li><li>规约：采用PCA小波分析，特征筛选（信息增益）</li><li>变换：最大最小法，E-score，数据离散化</li></ul><ol start="4"><li>数据类型</li></ol><h3 id="属性类型">属性类型</h3><p><strong>分类型</strong></p><ul><li>标称型-<strong>特殊（二元）</strong></li></ul><blockquote><p>标称型目标变量的结果<strong>只在有限目标集中取值</strong>，比如真与假（标称型目标变量主要用于<strong>分类</strong>）</p><ul><li>例：ID号，眼球颜色，邮政编码</li><li>特殊：二元</li></ul></blockquote><ul><li>序数型<ul><li>例：军阶，GPA，用{tall,medium,short}表示身高</li></ul></li></ul><p><strong>数值型</strong></p><blockquote><p>数值型目标变量则可以<strong>从无限的数值集合中取值</strong>，如0.555，666.666等（数值型目标变量主要用于<strong>回归分析</strong>）</p></blockquote><ul><li>区间<ul><li>例如：日历，摄氏或华氏温度</li></ul></li><li>比率<ul><li>例如：开式温度，长度，计数</li></ul></li><li><strong>标称属性</strong>的值是一些符号和事物的名称（比如头发的颜色）</li></ul><blockquote><p>标称：意味着“与名称有关”</p></blockquote><p><strong>离散和连续属性</strong><br><strong>二元属性</strong>是标称的一种 1代表有 0代表没有<br>如果是对称的说明无权重（例如男女性别）<br>如果是非对称的说明有权重（例如检测结果为阴性/阳性） 一个值比另一个值重要，重要的通常较少出现，通常用1表示</p><p>数值属性：区间，比率</p><h3 id="数据类型">数据类型</h3><ul><li>记录数据<ul><li>数据矩阵</li><li>文档数据</li><li>购物篮数据</li></ul></li><li>图数据<ul><li>万维网</li><li>分子结构</li></ul></li><li>有序数据<ul><li>时序数据</li><li>序列数据</li><li>基因序列数据</li><li>空间数据</li></ul></li></ul><h3 id="（重点）【选填题】数据的描述性统计">（重点）【选填题】数据的描述性统计</h3><p><strong>中心趋势度量：均值，众数，中位数，中列数</strong>——（中心性描述）<br><strong>数据的散步：极差，四分位数，四分位数极差，五数概括，盒图</strong>——（散布描述）<br><strong>可视化</strong></p><ul><li>分位数图</li><li>分位数-分位数图</li><li>直方图</li></ul><h4 id="中心趋势度量">中心趋势度量</h4><p><strong>均值</strong><br>均值=总和/个数</p><p>加权平均：考虑权重的均值</p><p><strong>中列数</strong><br>数据集的最大和最小值的平均值</p><p><strong>中位数（median）</strong><br>有序数据值的中间值</p><p>大数据：近似值估计（线性插值法）</p><p><strong>众数（mode）</strong><br>在集合中出现最频繁的值。（一个数据集中可能有多个众数）</p><p>对于非对称的单峰数据，有以下经验关系</p><p><code>mean-mode ~ 3 * (mean-median)</code>即为<code>均值-众数近似等于3*（均值-中位数）</code></p><blockquote><p>选填可能会考！</p></blockquote><h4 id="数据的散布">数据的散布</h4><ul><li>方差</li><li>标准差</li><li>极差</li></ul><p><strong>max-min</strong></p><ul><li>四分位数（quantile）</li><li>四分位数极差（距离）<br><code>IQR=Q3-Q1</code></li><li>五数概括</li></ul><blockquote><p>[min, Q1,median,Q3,max]</p></blockquote><h3 id="（重点）【上机实习】-数据的相似度度量">（重点）【上机实习】 数据的相似度度量</h3><h4 id="标称属性数据">标称属性数据</h4><p>标称变量是二元变量的拓展，它可以取多于两种状态</p><p>相异性度量方法中，不匹配率</p><p>计算方法为 $d(i,j)=\frac{p-m}{p}$</p><blockquote><p>m是状态取值匹配的变量数目 p是变量总数</p></blockquote><h4 id="二元变量属性数据">二元变量属性数据</h4><p>首先获取列联表<br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_de3d687adf-1.png" alt="1.png"></p><p>对称的二元变量的相异度计算</p><blockquote><p>对于对称属性，r+s是一个1一个0的总数和，q是两个1</p></blockquote><p>$$d(i,j)=\frac{r+s}{q+r+s+t}$$</p><p>如果是非对称则t被忽略<br>$$d(i,j)=\frac{r+s}{q+r+s}=1-\frac{q}{q+r+s}=1-Jaccard(i,j)$$</p><p>不对称的二元变量的相异度计算</p><blockquote><p>二元变量的两个状态的输出不是同样重要</p></blockquote><h4 id="序数型变量数据">序数型变量数据</h4><p><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_730900c2df-2.png" alt="2.png"></p><h4 id="数值属性数据">数值属性数据</h4><p>使用<strong>距离</strong>来度量两个数据对象之间的<strong>相似性/相异性</strong></p><ul><li>闵可夫斯基(Minkowski) 距离</li><li>曼哈顿距离</li></ul><blockquote><p>一维 绝对值之和</p></blockquote><ul><li>欧式距离</li></ul><blockquote><p>二维开根号</p></blockquote><h4 id="数据标准化">数据标准化</h4><p><strong>使用平均绝对偏差比使用标准差更具有鲁棒性</strong></p><h4 id="混合型数据">混合型数据</h4><p><strong>基本思想</strong>：将不同类型的变量组合在<strong>单个相异度矩阵中</strong>，把所有变量转换到共同的值域区间[0.0,1.0]上</p><h4 id="相似性度量">相似性度量</h4><ul><li>余弦相似性</li><li>马氏距离</li><li>相关散度</li><li>KL散度</li></ul><h3 id="（重点）数据预处理">（重点）数据预处理</h3><h4 id="为什么要挖掘？">为什么要挖掘？</h4><p>现实世界的数据是“肮脏的”</p><ul><li>不完整的：有些感兴趣的属性缺少属性值，或仅包含聚集数据</li><li>含噪声的：包含错误或者“孤立点”</li><li>不一致的：在编码或者命名上存在差异</li></ul><p>没有高质量的数据，就没有高质量的挖掘结果</p><h4 id="数据预处理的主要任务">数据预处理的主要任务</h4><h5 id="（重点）-数据清理-（数据的填充方式重点）">（重点） 数据清理 （数据的填充方式重点）</h5><p>【重点】填充方法</p><ul><li>忽略元组</li><li>人工填充缺省值：工作量大，可行性低</li><li>使用一个全局变量填充空缺值：比如使用unknown或-∞替换</li><li>使用属性的平均值填充空缺值</li><li>使用与给定元组属同一类的所有样本的均值</li><li>使用最可能的值填充空缺值：使用像Bayesian公式或判定树这样的预测的方法</li></ul><blockquote><p>空缺值 噪声数据 删除孤立点 解决不一致性</p></blockquote><p>用均值或者用临近数</p><p>噪声使用过滤的方法（聚类，回归，分箱）</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_a40d3865df-3.png" alt="3.png"></p><h5 id="数据集成">数据集成</h5><p>将多个数据源的数据整合到一个一致的存储中</p><p>集成多个数据库时，经常会出现冗余数据</p><p><strong>冗余分析</strong>：</p><ul><li>数字型 相关分析 皮尔逊相关系数</li><li>标称数据 卡方检验<br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_6cac7c94df-4.png" alt="4.png"></li></ul><h5 id="数据规约">数据规约</h5><p>得到数据集的压缩表示，但可以得到相同或相近的结果</p><p>分为</p><ol><li>维度规约：小波分析，<strong>PCA，特征筛选</strong></li><li>数量规约：回归，<strong>聚类，采样</strong>，数据立方体聚集</li><li>数据压缩（非重点）：使用变换</li></ol><p><strong>维度规约</strong>：PCA，小波分析，<strong>特征筛选</strong><br>**PCA基本思想：**找到一个投影，其能表示数据的最大变化</p><blockquote><p>特征筛选<br>目的：通过删除不相干的属性或维减少数据量<br>挑战：枚举所有几乎不可能<br>策略：启发式方法</p></blockquote><ul><li>逐步向前选择法</li><li>逐步向后删除法</li><li>向前选择和向后删除相结合</li></ul><p>利用信息增益，信息熵等（信息增益越大越好）</p><blockquote><blockquote><p>信息熵：刻画信息的混乱程度</p></blockquote></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_3ac0b253df-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_f61ae973df-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_2f00c283df-3.png" alt="3.png"></p><p><a href="https://blog.csdn.net/xwd18280820053/article/details/70739368">信息熵的介绍</a></p><p><strong>数量规约</strong>：回归，聚类，采样</p><h5 id="数据变化">数据变化</h5><blockquote><p>规范化和聚集<br>把数据变换和统一成适合挖掘的形式</p></blockquote><ul><li>最大最小规范化</li><li>Z-score规范化</li></ul><h5 id="数据离散化">数据离散化</h5><p>将连续数据进行离散处理</p><p>离散化（连续数据）<br>概念分层（标称数据）</p><h2 id="第三章-关联规则挖掘">第三章 关联规则挖掘</h2><h3 id="复习提纲-3">复习提纲</h3><p>定义</p><ul><li>关联规则挖掘</li><li>频繁模式</li><li>项集</li><li>支持度/计数</li><li>置信度</li></ul><p><code>Apriori</code>算法</p><ul><li>剪枝基本思想</li><li><code>Apriori</code>流程，计算</li><li>存在挑战及改进</li></ul><p>FP-Growth算法</p><ul><li>如何构造FP树</li><li>如何挖掘</li></ul><p>评估方法</p><ul><li>支持度</li><li>置信度</li><li>兴趣因子</li></ul><h3 id="定义以及一些概念">定义以及一些概念</h3><p>关联规则的挖掘：在事务，关系数据库中的项集和对象中发现<strong>频繁模式，关联规则，相关性</strong>或者<strong>因果结构</strong></p><p>频繁模式：数据库中频繁出现的项集</p><p>支持度 support</p><p>置信度 confidence</p><p>这两个标准来衡量事物关联规则的强度</p><ul><li>支持度support$X\to Y$：确定项集的频繁程度</li></ul><p>包含项集的事务数与总事务数的比值</p><ul><li>置信度</li><li>项集</li><li>频繁项集</li><li>置信度计算公式</li></ul><h3 id="Apriori算法">Apriori算法</h3><p>通过对数据的多次扫描来计算项集的支持度，发现所有频繁项集从而生成关联规则</p><p>剪枝的基本思想</p><p><strong>性质1：如果一个项集是频繁的，则它的所有子集一定也是频繁的</strong></p><p><strong>性质2：相反，如果一个项集是非频繁的，则它的所有超集也一定是非频繁的</strong></p><p><strong>提高Apriori算法的方法</strong></p><ul><li>Hash-based itemset counting（散列项集计数），压缩候选k项集</li><li>Transaction reduction（事务压缩），删除不可能对寻找频繁项集有用的事务</li><li>Partitioning（划分），分而治之</li><li>Sampling（采样），选取原数据库的一个样本, 使用Apriori 算法在样本中挖掘频繁模式</li></ul><h3 id="FP-growth算法">FP-growth算法</h3><p>优点：<strong>快</strong><br>该算法不同于Apriori算法的“产生-测试”范型。而是使用一种称为FP树的紧凑数据结构组织数据，并<strong>直接从该结构中提取频繁项集</strong></p><p><strong>基本思想</strong><br>首先：将<strong>代表频繁项集的数据库</strong>压缩到FP树上<br>其次：将FP树划分为一组条件数据库（每个数据关联一个频繁项或“模式段”），挖掘每个条件数据库获取频繁项集<br><strong>如何构造FP树</strong></p><ol><li>支持度排序</li><li>构建FP树</li></ol><h3 id="支持度，置信度及兴趣因子">支持度，置信度及兴趣因子</h3><h2 id="第四章-分类-回归">第四章 分类/回归</h2><h3 id="复习提纲-4">复习提纲</h3><p>基本概念</p><ul><li>监督/无监督</li><li>生成/判别</li><li>分类 VS 回归</li></ul><p>分类算法</p><ul><li>（重点）决策树<ul><li>建构过程</li><li>属性选择基本准则</li><li>信息增益率</li><li>基尼指数</li></ul></li><li>（重点）过拟合问题<ul><li>如何避免</li><li>决策树中</li></ul></li><li>（重点）KNN<ul><li>基本思想</li><li>优缺点</li></ul></li><li>Naive Bayes 朴素贝叶斯<ul><li>贝叶斯理论（优缺点）</li></ul></li><li>（重点）SVM支持向量机<ul><li>支持向量/小样本/泛化能力</li><li>基本思想</li><li>非线性函数： 核函数</li></ul></li><li>人工神经网络</li></ul><p>集成学习</p><ul><li>学习准则<ul><li>准确性</li><li>多样性</li></ul></li><li>集成策略<ul><li>RF</li><li>Ada Boost</li><li>Stacking</li></ul></li></ul><p>评估</p><ul><li>准确度</li><li>轻度</li><li>吕四率</li><li>F1</li><li>类不平衡：灵敏性，特效性</li></ul><h3 id="基本概念-2">基本概念</h3><h4 id="监督学习-VS-无监督学习">监督学习 VS 无监督学习</h4><p>监督学习</p><p>分类，预测等</p><blockquote><p>“告诉机器怎么学”</p></blockquote><p>无监督学习</p><p>关联规则挖掘，聚类分析都是无监督学习</p><blockquote><p>“不告诉机器怎么学”</p></blockquote><h4 id="（重要）-模型分类">（重要） 模型分类</h4><h5 id="生成模型">生成模型</h5><p>希望从数据中<strong>学习/还原出原始的真实数据生成模型</strong></p><blockquote><p>朴素贝叶斯，隐马尔可夫模型</p></blockquote><h5 id="判别模型">判别模型</h5><p>从数据中<strong>学习到</strong>不同类概念的<strong>区别从而进行分类</strong></p><blockquote><p>KNN SVM ANN 决策树</p></blockquote><h5 id="二者的区别">二者的区别</h5><p>生成模型</p><ul><li>容量大 生成模型容易接近真实模型</li><li>能够处理具有<strong>隐含变量</strong>的情景</li></ul><p>判别模型</p><ul><li>速度快</li><li>准确率高</li></ul><p>分类和回归</p><p>分类：根据训练数据集和类标号属性，构建模型来分类现有数据，并用来分类新数据</p><p>预测：建立连续函数值模型，预测未来的情况比如预测空缺值</p><h3 id="决策树（DT）">决策树（DT）</h3><h4 id="（重点）-决策树的优缺点">（重点） 决策树的优缺点</h4><p>优点</p><ul><li>容易转换成分类规则</li><li>计算量相对较小，所以速度较快</li><li>准确性高（挖掘出来的分类规则准确性高 便于理解）</li></ul><p>缺点</p><ul><li>容易过拟合</li><li>忽略了属性之间的相关性</li></ul><h4 id="（重点）-构建决策树的方法">（重点） 构建决策树的方法</h4><p>构造方式</p><h4 id="（重点）-属性选择基本准则">（重点） 属性选择基本准则</h4><p>具有最好度量得分的属性（对分类数据类别越“纯”）选定为分裂属性</p><p>三种度量：信息增益，信息增益率，Gini指标</p><h5 id="（重点）-信息增益（ID3）">（重点） 信息增益（ID3）</h5><p>信息增益：原来的信息与分裂后的信息之差，说明我们通过划分得到了多少信息</p><h5 id="（重点）-信息增益率（C4-5）">（重点） 信息增益率（C4.5）</h5><p>信息增益倾向于有大量不同取值的属性，但每个划分只有一个类的时候 info=0</p><p>C4.5（ID3后继）使用增益率来克服这一问题（规范化信息增益）</p><p>公式为信息增益/根据当前的那个类利用信息熵计算出来的值，越大越好</p><h5 id="Gini指数（CART）">Gini指数（CART）</h5><p>Gini指数度量数据元组的不纯度，越小越好</p><p>如果是三个属性，要进行二元分裂，那么两两为一组，计算后加权后的Gini指数</p><h3 id="（重点）-过拟合问题和解决">（重点） 过拟合问题和解决</h3><p>过拟合：为了得到一致性假设而使<strong>假设变得过度复杂</strong>称为过拟合</p><p>过拟合是监督学习中普遍存在的问题</p><ul><li>原因：因为训练样本<strong>只是</strong>真实情况下的<strong>一个抽样集</strong></li><li>结果：<strong>泛化能力不强</strong></li></ul><h4 id="过拟合问题的解决策略">过拟合问题的解决策略</h4><ol><li>增加样本集</li><li>噪声去除</li><li>降低模型复杂度</li><li>模型选择正确：正则项等（例如选择VC堆）</li></ol><h4 id="（重点）在决策树中如何避免过拟合">（重点）在决策树中如何避免过拟合</h4><p>一颗归纳的树可能过分拟合数据训练数据造成的后果</p><ul><li>分支太多，某些反映训练数据中的异常，噪声/孤立点</li><li>未参与训练的样本的低精度预测</li></ul><p>具体做法</p><ul><li>限制决策树的层数来限制树的生长</li><li>设定每个节点必须包含的最少的记录数 节点个数小于这个最小记录数就停止分隔</li><li>树剪枝<ul><li>先剪枝<strong>提前终止树构造</strong></li><li>后剪枝<strong>从完全生长的树中剪去树枝</strong>（但是后剪枝的计算量代价比先剪枝方法大很多！尤其是大样本集中）【在小样本中后剪枝要好】</li></ul></li></ul><h3 id="（重点）-KNN">（重点） KNN</h3><h4 id="基本思想">基本思想</h4><p>算法步骤：</p><ol><li>算距离：给定测试对象，计算它与训练集中的每个对象的距离</li><li>找邻居：圈定距离最近的k个训练对象，作为测试对象的近邻</li><li>做分类：根据这k个近邻归属主要的类别，来对测试对象分类</li></ol><h4 id="优缺点">优缺点</h4><p>优点：</p><ul><li>简单，易于实现，无需估计参数，无需训练</li><li>准确率一般较高</li><li>适合对稀有事件进行分类，特别适合于多分类问题</li></ul><p>缺点：</p><ul><li>懒惰算法，对测试样本分类时计算量大，内存开销大，评分慢</li><li>当类解释不平衡的时候，倾向于将类全部归于大类</li><li>可解释性差，无法给出决策树那样的规则。对噪声非常敏感</li></ul><h3 id="朴素贝叶斯">朴素贝叶斯</h3><p>关注分子：哪个更大<br>找更大的y（y是类别）<br>优点：概率输出，对文本分类效果较好</p><h3 id="（重点）SVM支持向量机">（重点）SVM支持向量机</h3><h4 id="（重点）SVM的优缺点">（重点）SVM的优缺点</h4><h4 id="什么是支持向量？">什么是支持向量？</h4><p>在<strong>分界点上的点</strong>称为支持向量</p><p>SVM的优点：</p><ol><li>可以处理小样本</li><li>泛化能力强</li></ol><h3 id="人工神经网络">人工神经网络</h3><p>人工神经网络（ANN，Artificial Neural Networks）是人类对大脑神经网络认识的基础上，人工构造的能够实现某种功能的神经网络。<br>它是理论化的人脑神经系统的数学模型，是基于模仿大脑神经结构和功能而建立起来的一种信息处理系统。<br>是一个多输入单输出的非线性阈值器件。</p><h3 id="集成学习">集成学习</h3><p>考的可能性不大，PPT里面没有<br>集成学习：通过<strong>构建并结合多个学习器</strong>来完成学习任务，个体学习器要有一定的“准确性”，并且要有“多样性”，即学习器间有差异</p><blockquote><p>多样性是核心</p></blockquote><h3 id="分类评价指标">分类评价指标</h3><p><strong>准确度：Accuracy=$\frac{TP+TN}{ALL}$</strong><br>精度<br>A代表实际，PR代表预测，左上角和右下角是预测正确的<br><strong>准确度：Accuracy=$\frac{TP+TN}{ALL}$</strong><br><strong>误差率：1-Accuracy</strong><br><strong>错误率=$\frac{FP+FN}{ALL}$</strong><br><strong>精度：被分类预测为正确的占所有实际正确的比例$\frac{TP}{TP+FP}$</strong><br><strong>召回率：在所有实际正确的类别中被识别为正确的比率$\frac{TP}{TP+FN}$</strong></p><h3 id="练习题">练习题</h3><h2 id="第五章-聚类算法和噪声检测">第五章 聚类算法和噪声检测</h2><h3 id="复习提纲-5">复习提纲</h3><ol><li>什么是聚类？</li><li>聚类算法分类</li><li>KMEANS DBSCAN算法</li><li>什么是离群点？</li><li>离群点种类</li><li>LOF</li></ol><h3 id="什么是聚类">什么是聚类</h3><p>无监督学习的一种，就是将数据分为多个簇（Clusters），使得在同一簇内对象之间具有较高的相似度，而不同簇之间的对象差别较大.<br>目的是寻找出数据中<strong>潜在的自然分组结构</strong>，<strong>让一个簇内的数据尽可能相似，不同簇内的数据尽可能不同</strong></p><h3 id="聚类算法分类">聚类算法分类</h3><p>一般而言，从<strong>不同角度出发</strong>可以将各种聚类算法分成不同的类型。如按照聚类的基本思想可主要分为：</p><ul><li><p>基于<strong>划分</strong>方法<br>给定一个有n个对象的数据集，划分聚类技术将构造数据k个划分，每一个划分就代表一个簇<br>对于给定的k，算法首先给出了一个初始的划分办法，以后“通过反复迭代的方法改变划分，使得每一次改进后的划分方案都较前一次更好”。经典的算法有：K-MEANS（K-均值），K-Medoids（K-中心点）等</p></li><li><p>基于<strong>层次</strong>方法<br>层次聚类方法对给定的数据集进行层次的分解，直到满足某种条件为止<br><strong>凝聚的层次聚类</strong>是一种自底向上的策略，首先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，知道某个终结条件被满足。AGENS算法<br><strong>分裂的层次聚类</strong></p></li><li><p>基于<strong>密度</strong>方法<br>密度聚类方法的指导思想是，只要一个区域中的点的密度大于某个阈值，就可把它加到与之相近的聚类中去。<br>这类算法<strong>能克服基于距离的算法只能发现“类圆形”的聚类的缺点</strong>，可以发现任意形状，<strong>且对噪声数据不敏感</strong></p></li><li><p>基于<strong>网格</strong>方法<br>将对象空间量化为有限数目的单元，形成一个网格结构，所有的聚类都在这个网格结构上进行。</p></li></ul><h3 id="（重点）KMEANS">（重点）KMEANS</h3><p>KMEANS</p><ul><li>选取K个点作为初始的类中心点，这些点一般都是从数据集中随机抽取的</li><li>将每个点分配到最近的类中心点，这样就形成了K个类，然后重新计算每个类的中心点；（一般用欧几里得距离公式算最近，用每个维度的平均值重新计算每个类的中心点）</li><li>重复第二步，直到类不发生变化，或者你也可以设置最大迭代次数，这样即使类中心点发生变化，但是只要达到最大迭代次数就会结束</li></ul><h3 id="KMEANS优缺点">KMEANS优缺点</h3><p>优点：速度快，相对可伸缩和高效率<br>缺点：对K值敏感，对初值敏感，<strong>不适合非球形的簇</strong>，对孤立点和噪声敏感</p><h3 id="（重点）DBSCAN">（重点）DBSCAN</h3><p>缺点：</p><ul><li>对参数EPS和Minspt非常敏感，但是这两个参数的选取主要依靠主观判断</li><li>数据库比较大的话，会有比较大的IO开销</li></ul><h3 id="什么是离群点">什么是离群点</h3><p>“离群点是一个数据对象，它显著不同于其他数据对象，好像它是被不同的机制产生的一样。”</p><blockquote><p>异常数据具有<strong>特殊意义和很高的使用价值</strong>，异常数据虽然有时候或作为离群点被排斥掉，但是却也有可能给我们新的视角，比如</p></blockquote><ul><li>在欺诈检测中，异常数据可能意味着欺诈行为的发生</li><li>在入侵检验中，异常数据可能意味着入侵行为的发生</li></ul><h3 id="离群点种类">离群点种类</h3><ul><li>全局离群点 和别的一点点关系都没有</li><li>局部离群点，对全局来说不是离群点，但是对于某个簇来说是离群点</li><li>集体离群点 某一个群体和其他不同</li></ul><h3 id="LOF离群（异常-孤立）点检测">LOF离群（异常/孤立）点检测</h3><ul><li>基于统计学的孤立点检测</li><li>基于距离的孤立点检测</li><li>基于偏离的孤立点检测</li><li>基于密度判断：<br>对象P的局部可达密度(Local Reachable Distance)<br>对象P的局部可达密度为对象P与它的MinPts-邻域的平均可达距离的倒数<br>对象P的局部异常因子（Local Outlier Factor）<br>Lrd是局部密度，所以孤立点的密度小，分子大，分母小，所以最终结果大<br>对象P的局部异常因子表示P的异常程度，局部异常因子愈大，就认为它可能更异常，反之可能性越小</li></ul><h2 id="第六章-大数据分析">第六章 大数据分析</h2><h3 id="复习提纲-6">复习提纲</h3><p>哈希技术</p><ul><li>Mini Hash 最小哈希-签名矩阵的计算</li><li>LSH局部敏感哈希</li><li>其中 签名矩阵的计算 与局部敏感哈希近似<br>数据流挖掘</li><li>数据流挑战</li><li>概念漂移（PCC（x）改变）检测方法</li><li>分类（VFDT$\to$Hoe）</li><li>聚类：线上+线下<ul><li>线上：数据抽象：微簇</li><li>线下：KMEANS DBSCAN</li></ul></li></ul><h3 id="哈希技术">哈希技术</h3><h4 id="（重点）-Min哈希（最小哈希）">（重点） Min哈希（最小哈希）</h4><p>步骤</p><ol><li>计算签名矩阵<br><strong>（重点） 会算签名矩阵</strong></li><li>通过签名矩阵寻找相似的签名</li><li>检测签名相似的是否真的相似（可选）</li></ol><p>主要思想：<br>把每一列转换成一个更小的签名矩阵C，让C足够小能够放到内存里面，让C1和C2能表征原始数据的相似性<br>相似性用雅阁比距离来表征：$\frac{a}{a+b+c}$ a为两者都是1，b和c表示一个0和一个1<br>最小哈希定义<br>首次出现1的行号</p><h4 id="LSH（局部敏感哈希）">LSH（局部敏感哈希）</h4><p><strong>原因</strong><br>想要比较两个文档，一一校对是非常苦难的，提出LSH<br><strong>哈希的思想</strong><br>不一一匹配，把数据放到桶里，<strong>每个桶里的东西都非常相似</strong><br>把列向量b划分为b块，对每一块进行映射，如果是相似的，那么至少有一块会映射到一个桶子里<br>将签名矩阵划分为几块，对每一块进行映射，候选对是至少散列到一个桶的对<br>概率随比例变化<br>将每一列划分为b个bands，然后每个bands分别放到桶里<br>如果相似度很大（超过0.5），至少有一个band全部放到一个桶里，就可以放到一起</p><h3 id="数据流挖掘">数据流挖掘</h3><p><strong>（重点）如何检测概念漂移</strong><br>数据流：<strong>持续的依次到达的对象，无穷长，有概念漂移</strong><br>挑战：<strong>单程处理，内存限制，低时间复杂度，概念漂移</strong><br><strong>概念漂移</strong><br>在预测分析和机器学习中，概念漂移意味着模型试图预测目标的统计特征随时间以不可预见的方式改变<br>条件概率发生变化<br>如下图，中间是真正的概念漂移，右边是虚假的，如果P（x）变化整体不会变<br><strong>如何检测数据漂移</strong><br><strong>使用分布</strong><br>用于检测突变的概念漂移<br>检测相同时间间隔（窗口）检测P（C|X）,如果检测到变化就说明发生了<br>问题：1.窗口大小不好确定；2.学习漂移慢；3.虚假的概念漂移<br>ADWIM：处理当前数据，发生显著性变化就用新的替代老的<br><strong>错误率</strong><br>缺点：1.对噪声敏感 2.对缓慢变化的数据难以处理 3.取决于学习模型的健壮性<br><strong>分类</strong><br>传统静态不适用，每一次输入一个数据后快速进行分类<br>方法：快速决策树（VFDT）<br>动态地构造决策树，利用小部分数据构造<br>算法：假如新来的数据满足关系，那么就划分一次 如果错误变多了，那么可以认为是发生了概念漂移，使用新的节点<br><strong>聚类</strong><br>数据流抽象，分为在线和离线<br>线上把数据用合适地数据结构处理，线下用传统方式去进行聚类<br>微簇：用几个点表示几个相近的点<br>动态变化，线上（重要），如何去线上整出这些微簇<br><strong>簇特征（重要）</strong><br>CF=（N，LS，SS）N是点的个数，LS是横坐标之和，SS是横坐标平方和<br><strong>为什么要做处理</strong></p><ol><li>可以计算这些点的中心和半径</li><li>可以支持动态增量式计算</li><li>因为数据连续不断的进入，只需要加新增的数据就可以（可加性，可减性）</li></ol><h3 id="（重点）-Hadoop-spark的基本概念！">（重点） Hadoop/spark的基本概念！</h3><p><strong>Hadoop</strong>：Hadoop是一个软件框架，用于跨大型计算机群对大型数据集进行分布式处理TB PB级别<br><strong>Spark</strong>：一个统一的完整的引擎<br><strong>Hadoop设计准则</strong><br>需要处理大数据<br>需要跨数千个节点并行计算，大量廉价机器并行计算<br>分而治之<br>1.自动并行化 2.容错和自动恢复 3.给用户提供接口<br><strong>Hadoop生态</strong><br>MapReduce（计算）和HDFS（存储） ZOOKeeper用来协调<br><strong>HDFS怎么存储</strong><br>分而治之，分为很多块<br>Namenode和Datanode<br>用Namenode去存哪一块放到哪个机器里面，存储数据原信息<br>Datenode存储实际数据，文件被存在各个节点里，拥有时钟机制，每个几秒发送一次汇报工作，如果过了很久还没能发送，那么已经默认你已经挂掉，重新创建节点存储被挂掉节点存储的数据<br>可以存储大数据<br><strong>MapReduce VS Spark</strong><br>MaoReduce适用于一次操作，对多次操作不适用，共享机制落后，花费大量时间IO<br>Spark是用于推广reduce去支持同一引擎的新应用，拥有RDD支持内存计算，提供多种API<br><strong>RDD弹性分布式数据集</strong><br>只读，便于内存计算<br>操作方式：</p><ol><li>Transformation<br>他从现有的数据集创建一个新数据集，所有操作都是懒惰的</li><li>Action<br>它在对数据集运行计算后向驱动程序返回一个值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘与大数据分析 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础复习</title>
      <link href="/2022/05/27/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/27/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-绪论">第一章 绪论</h2><h3 id="软件开发六步骤（了解）">软件开发六步骤（了解）</h3><ol><li>问题理解</li><li>算法设计</li><li>数据结构选择</li><li>算法分析</li><li>程序设计</li><li>程序实现</li></ol><h3 id="操作系统的主要功能（了解）">操作系统的主要功能（了解）</h3><ol><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>用户接口</li></ol><h4 id="软件程序编译">软件程序编译</h4><p><strong>程序需要编译成计算机能理解的代码才能在操作系统上运行</strong><br>软件是运行在操作系统之上的，因此与操作系统息息相关。同一个软件逻辑和程序在不同的操作系统上的实现可能是不同的，其可运行的二进制码也是不同的<br>程序实现的区别</p><ul><li>Window：进程和线程的概念都是有着明确定义</li><li>Linux：没有很明确的进程，线程概念</li></ul><h4 id="数据库管理系统（了解）">数据库管理系统（了解）</h4><p><strong>定义</strong>数据库管理系统是位于用户与操作系统之间的数据管理软件</p><p><strong>功能</strong>1.数据定义 2.数据操作 3.数据库运行管理 4.数据组织，存储和管理 5.数据库的建立和维护 6.数据通信接口<br><strong>组成</strong></p><ol><li>数据定义语言及其翻译处理程序</li><li>数据操作语言及其翻译处理程序</li><li>数据运行控制程序</li><li>适中程序</li></ol><h2 id="第二章-数据结构与算法">第二章 数据结构与算法</h2><h3 id="线性表的逻辑存储结构">线性表的逻辑存储结构</h3><p>在线性结构中，数据元素之间存在着一对一的关系，其特点是数据元素之间按某种规定存在一个<strong>顺序关系</strong>（逻辑结构）<br>线性表：n个同类数据元素的有限序列，记为：L($a_1，a_2,…，a_i,…，a_n$)<br>L为表名，i为数据元素$a_i$在线性表中的位序；n为线性表的表长，n=0时称为空表，$a_i$的数据类型相同<br>特点：</p><ul><li>$a_i$的数据类型相同</li><li>位序i从1开始</li><li>前驱（前一个元素），后继（后一个元素）</li></ul><h3 id="线性表的顺序存储结构">线性表的顺序存储结构</h3><p><strong>基本概念</strong><br>用一组地址连续的存储单元依次存放线性表中的数据元素，线性表的起始地址s称作线性表的基地址，数据元素ai的存储位置为：LOC(ai) = LOC(a1) + (i-1)×d<br><strong>顺序表的c语言定义</strong><br><img src="https://img-blog.csdnimg.cn/20210702140718959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>插入操作</strong></p><ol><li>检查插入位置是否合法，如果合法则继续，否则退出；</li><li>判表是否已占满；因为是事先静态地分配空间，可能存在所分配存储空间全部被占用的情况，此时也不能实现插入。</li><li>若前面检查通过则数据元素依次向后移动一个位置；为避免覆盖原数据，应从最后一个向前依次移动。</li><li>新数据元素放到恰当位置；</li><li>表长加1。<br><strong>代码</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status  <span class="hljs-title">List_Insert</span><span class="hljs-params">(ListPtr L, <span class="hljs-type">int</span> pos, ElemType elem)</span></span>&#123;<br>    Status status = range_error;<br>    <span class="hljs-type">int</span> len = L-&gt;length, i;<br>    <span class="hljs-keyword">if</span> (len == MAXSIZE) status = overflow;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= pos &amp;&amp; pos &lt;= len + <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= pos; i -- )<br>            L-&gt;elem[i + <span class="hljs-number">1</span>] = L-&gt;elem[i];<br>        L-&gt;elem[pos] = elem;<br>        L-&gt;length ++ ;<br>        status = success;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$</p><p><strong>删除操作</strong></p><ol><li>检查删除位置是否合法；</li><li>若检查通过，数据元素依次向前移动一个位置；</li><li>表长减1</li></ol><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">List_Remove</span><span class="hljs-params">(ListPtr L,<span class="hljs-type">int</span> pos)</span></span>&#123;<br>    Status status = range_error;<br>    <span class="hljs-type">int</span> len = L-&gt;length, i;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= pos &amp;&amp; pos &lt;= len)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; len; i ++ )<br>            L-&gt;elem[i] = L-&gt;elem[i + <span class="hljs-number">1</span>];<br>        L-&gt;length -- ;<br>        status = success;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性表的链式存储结构">线性表的链式存储结构</h3><p>用一组地址任意的存储单元存放线性表中的数据元素。<br>数据域 (数据元素) + 指针域 (指示后继元素存储位置) =  结点，以“结点的序列”表示线性表——称作链表<br><img src="https://img-blog.csdnimg.cn/20210702145330594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>带头节点和不带头节点的区别</strong><br>不带：链表指针存放链表第一个数据元素节点的地址，空链表时该指针域为NULL<br>带：一个专门的节点，称为头节点，该头节点是永远存在的，该头节点指针域存放第一个数据元素节点的地址，空链表为L.next=NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//单链表的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>&#125;ListNode, *ListNodeptr;<br><span class="hljs-keyword">typedef</span> ListNodePtr List, *Listptr;<br><br><span class="hljs-comment">//变量的定义和使用</span><br>ListNode n1, n2; <span class="hljs-comment">// 定义2个节点变量</span><br>ListNodePtr p = &amp;n1; <span class="hljs-comment">// 定义一个指向节点的指针变量p,并存放n1的地址(指针)</span><br>n1.next = &amp;n2; <span class="hljs-comment">// 节点n1的指针域存放节点n2的地址</span><br>List L; <span class="hljs-comment">// 定义单链表</span><br></code></pre></td></tr></table></figure><p><strong>插入操作</strong><br><img src="https://img-blog.csdnimg.cn/2021070215030488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>步骤：找到$a_{i-1}$的位置，构造一个数据为elem的新节点，将其挂在单链表上<br>s-&gt;data=elem;<br>s-&gt;next=pre-&gt;next;<br>pre-&gt;next = s;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status  <span class="hljs-title">List_Insert</span><span class="hljs-params">(ListPtr L, <span class="hljs-type">int</span> pos, ElemType elem)</span></span>&#123;<br>    Status status;<br>    ListNodePtr pre, s;<br>    status = <span class="hljs-built_in">List_SetPosition</span>(L, pos - <span class="hljs-number">1</span>, &amp;pre);<br>    <span class="hljs-keyword">if</span> (status == success)<br>    &#123;<br>        s = (LinkNodePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br>        <span class="hljs-keyword">if</span> (s)&#123;<br>            s-&gt;data = elem;<br>            s-&gt;next = pre-&gt;next;<br>            pre-&gt;next = s;<br>        &#125;<br>        <span class="hljs-keyword">else</span> status = fatal;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除操作</strong><br><img src="https://img-blog.csdnimg.cn/20210702150556389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>步骤：首先找到第i-1个节点p，修改第i-1的节点的后继为第i+1个节点的地址，再释放第pos个节点所占的存储空间<br>q=pre-&gt;next;<br>pre-&gt;nxt=q-&gt;next;<br>free(q);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">List_Remove</span><span class="hljs-params">(ListPtr L, <span class="hljs-type">int</span> pos)</span></span>&#123;<br>    Status status;<br>    ListNodeptr pre, q;<br>    status = <span class="hljs-built_in">List_SetPosition</span>(L, pos - <span class="hljs-number">1</span>, &amp;pre);<br>    <span class="hljs-keyword">if</span> (status == success)&#123;<br>    q = pre-&gt;next;<br>    pre-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种存储方式的优缺点">两种存储方式的优缺点</h3><p><strong>顺序表</strong><br>优点：空间利用率高，数据是连续存放的，命中率比较高；存取速度高效，通过下标来直接访问。<br>缺点：插入删除效率低；需要预分配空间<br><strong>时间复杂度</strong>：查找操作为O(1),插入和删除操作为O(n)<br><strong>链表</strong><br>优点：插入删除速度快；没有空间限制，储存元素无上限；动态内存分配<br>缺点：占用额外空间以存储指针；查找速度慢<br><strong>时间复杂度</strong>：查找操作为O(n)，插入和删除操作为O(1)和O(n)<br><strong>链表插入删除是读操作的O（n），而顺序表是写操作的O（n），两者速度不同</strong></p><h3 id="时间复杂度渐进分析（大题）">时间复杂度渐进分析（大题）</h3><p>渐进分析：</p><ol><li>渐近上界记号O<br>O(g(n)) = { f(n) | 存在正常数c和$n_0$使得对所有n $\geq$ $n_0$有：$0 \leq f(n) \leq cg(n)$ }</li><li>渐近下界记号$\Omega$<br>$\Omega$(g(n)) = { f(n) | 存在正常数c和$n_0$使得对所有n $\geq$ $n_0$有：$0 \leq cg(n) \leq f(n)$   }</li><li>紧渐进记号 $\Theta$<br>$\Theta$(g(n)) = { f(n) | 存在正常数c1,c2和$n_0$使得对所有n$\geq$ $n_0$有：$c_1g(n) \leq f(n) \leq c_2g(n)$ }</li><li>非紧上界记号o<br>o(g(n)) = { f(n) | 对于任何正常数c &gt; 0，存在正数和 $n_0$ &gt;0使得对所有 $ n \leq n_0$有：$0 \leq f(n) &lt;cg(n)$ }<br>等价于  f(n) / g(n) $\to 0$ ，as  n$\to \infty$</li><li>非紧下界记号$\omega$<br>$\omega$ (g(n)) = { f(n) | 对于任何正常数c&gt;0，存在正数和$n_0$ &gt;0使得对所有$n \leq n_0$有：$0 \leq cg(n) &lt; f(n)$ }<br>等价于  f(n) / g(n) $\to \infty$ ，as  n $\to \infty$。<br>$logn&lt;n&lt;nlogn&lt;n^2&lt;2^n&lt;n!$<br><strong>常用关系式</strong><br><img src="https://img-blog.csdnimg.cn/20210702152611349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>例题</strong><br><img src="https://img-blog.csdnimg.cn/20210702161341161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>解：首先得知道渐进关系O的定义：</li></ol><p>O(g(n)) = { f(n) | 存在正常数c和n0使得对所有 n≧n0 有：0 ≦ f(n) ≦ cg(n) }</p><p>即：若 f(n)=O(g(n))，则f(n)≦ g(n)</p><p>主要利用上面的指数和对数两个式子：<br><img src="https://img-blog.csdnimg.cn/20210704192243318.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="分治算法求解排序问题">分治算法求解排序问题</h3><p><strong>分治思想</strong></p><ul><li>对这k个子问题分别求解。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止</li><li>将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解</li><li>分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</li></ul><p><strong>分治算法的适用条件</strong></p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有<strong>最优子结构性质</strong></li><li>利用该问题分解出的子问题的解可以合并为该问题的解</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li></ul><blockquote><p>这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210702162858489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>基本思想：</strong><br>将待排序元素分成大小大致相同的2个子集合.递归的分别对2个子集合进行排序.最终将排好序的子集合并成为所要求的排好序的集合.<br><img src="https://img-blog.csdnimg.cn/20210702163103476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(Comparable a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right)&#123;<br>        <span class="hljs-type">int</span> i = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(a, left, i);<br>        <span class="hljs-built_in">mergeSort</span>(a, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-built_in">merge</span>(a, b, left, i, right);<br>        <span class="hljs-built_in">copy</span>(a, b, left, right);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="各个排序算法的时间复杂度">各个排序算法的时间复杂度</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6611f12fde5c92d2aa299a172794b2e0.png" alt=""></p><h3 id="树">树</h3><p><strong>定义：</strong><br>由一个或多个（n$\leq$0）的节点组成的有限集合，有且仅有<strong>一个节点称为根（root）</strong>，当n&gt;1，其余的节点分为m(m$\leq$0)个<strong>互不相交</strong>的有限集合$T_1,T_2,…,T_m$，被称为这个根的<strong>子树</strong></p><blockquote><p>注意空树也是树</p></blockquote><p>基本概念：</p><p>结点：</p><p>根结点：</p><p>叶子：度为0的结点</p><p>结点的度：拥有所有的子树的个数称为结点的度</p><p>树的度：所有结点度中的最大值</p><p>树的深度/高：所有结点中的最大的层数</p><p><strong>树和线性结构的比较</strong></p><table><thead><tr><th style="text-align:center">线性结构</th><th style="text-align:center">树型结构</th></tr></thead><tbody><tr><td style="text-align:center">第一个数据元素（无前驱）</td><td style="text-align:center">根节点（无前驱）</td></tr><tr><td style="text-align:center">最后一个数据元素（无后继）</td><td style="text-align:center">多个叶子节点（无后继）</td></tr><tr><td style="text-align:center">其他数据元素（一个前驱，一个后继）</td><td style="text-align:center">其他数据元素（一个前驱，多个后继）</td></tr></tbody></table><h3 id="二叉树的概念">二叉树的概念</h3><p><strong>定义</strong>：是一个n（n≥0）个节点的有限集合，由一个根节点以及两课互不相交的，分别称为左子树和右子树的二叉树组成（递归定义）<br><strong>基本特征：</strong><br>每个结点最多有两颗字数；左右子树的次序不能颠倒<br><strong>满二叉树：</strong><br>深度为k，且有$2^{k-1}$个结点的二叉树<br>节点层序编号方法：从根节点起，从上到下逐层（层内从左到右）对二叉树的节点进行连续编号<br><strong>完全二叉树</strong><br>深度为k，结点数为n的二叉树，当且仅当每个节点的编号都与相同深度的满二叉树中从1到n的节点一一对应时，称为完全二叉树。<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_37e5bd75e4-1.png" alt="1.png"></p><p><strong>二叉树与度数为2的树的区别</strong></p><ol><li>度不同 度为2的树要求每个节点最多只能有两棵子树,并且至少有一个节点有两棵子树。二叉树的要求是度不超过2,节点最多有两个叉,可以是1或者0。 在任意一棵二叉树中,叶子结点总是比度为2的结点多一个。</li><li>分支不同 度为2的树有两个分支,但分支没有左右之分; 一棵二叉树也有两个分支,但有左右之分,左右子树的次序不能随意颠倒。</li><li>次序不同 度为2的树从形式上看与二叉树很相似,但它的子树是无序的,而二叉树是有序的。即在一般树中若某结点只有一个孩子,就无需区分其左右次序,而在二叉树中即使是一个孩子也有左右之分。</li></ol><h3 id="二叉树的存储">二叉树的存储</h3><p><strong>顺序存储结构</strong><br>按二叉树的节点“自上而下，从左到右”编号，用一组连续的存储单元存储<br>若是完全二叉树或满二叉树，可以做到<strong>唯一</strong>复原，有规律：下表为i的双亲，其左孩子的下标值必为2i,其右孩子的下标值必为2i+1<br>若不是完全二叉树，一律转化为完全二叉树，通过补空节点节点完成，但是会浪费空间，插入删除不方便<br><strong>链式存储结构</strong><br>二叉链表：2个链表分别存放左孩子和右孩子<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_af34691de4-1.png" alt="1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//二叉链表的存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;<br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p>三叉链表：2个链表分别存放左孩子和右孩子，一个指向双亲<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_eef65435e4-2.png" alt="2.png"></p><h3 id="二叉树的遍历">二叉树的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210702165829672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>先序遍历结果：ABCDEFGHIJK<br>中序遍历结果：CDBEFAHGJIK<br>后序遍历结果：DCFEBHJKIGA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BiTree bt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, bt-&gt;data);<br>        <span class="hljs-built_in">preorder</span>(bt-&gt;lchild);<br>        <span class="hljs-built_in">preorder</span>(bt-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BiTree bt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">inorder</span>(bt-&gt;lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, bt-&gt;data);<br>        <span class="hljs-built_in">inorder</span>(bt-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(BiTree bt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">postorder</span>(bt-&gt;lchild);<br>        <span class="hljs-built_in">postorder</span>(bt-&gt;rchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, bt-&gt;data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历：利用队列，节点出队时将其左右孩子入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">LayerTraverse</span><span class="hljs-params">(BiTree T, Status(*visit)(ElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//层次遍历二叉树</span><br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    <span class="hljs-keyword">if</span> (T) <span class="hljs-built_in">EnQueue</span>(Q, T);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(Q))&#123;<br>        <span class="hljs-built_in">Dequeue</span>(Q, p);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> ERROR;<br>        <span class="hljs-keyword">if</span> (p-&gt;lchild) <span class="hljs-built_in">Enqueue</span>(Q, p-&gt;lchild);<br>        <span class="hljs-keyword">if</span> (p-&gt;rchild) <span class="hljs-built_in">Enqueue</span>(Q, p-&gt;rchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树和二叉树的互换">树和二叉树的互换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/fe460605a43c811a25acbb92a7534eae.png" alt=""></p><h3 id="先序和中序遍历恢复二叉树">先序和中序遍历恢复二叉树</h3><p>一棵二叉树的先序序列和中序序列分别我：A B C D E F G H J K L M N和C B E D G F A J H K M L N，则二叉树的后序序列为（A）。</p><pre><code>A. C E G F D B J M N L K H A     B. C E D G F B J H K M N L AC. C G F E D B J M N L K H A     D. C E G D F B M N J L K H A</code></pre><h3 id="树的存储结构">树的存储结构</h3><ol><li>双亲表示法</li><li>孩子表示法</li><li>孩子兄弟表示法</li></ol><h3 id="树的遍历方式">树的遍历方式</h3><ol><li>先根层次遍历<br>树的先根遍历简单而言就与，二叉树的前序遍历相似，都是“根左右”，只不过在左右之分上面，不是简单的只是左右而已，而是同一层上面的节点，从左边的节点遍历结束之后才轮到右边的下一个节点（同一层不一定只是左右两个节点）；<br><img src="https://img-blog.csdnimg.cn/20210311080429252.png" alt=""></li><li>后根层次遍历<br>树的后根遍历简单而言就与，二叉树的后序遍历相似，都是“左右根”，只不过在左右之分上面，并没有二叉树那么明确而已。其实树的遍历与二叉树的遍历都是相似的，只不过没有了明确的左右子树的划分而已。<br><img src="https://img-blog.csdnimg.cn/20210311080453995.png" alt=""></li></ol><h3 id="二叉搜索树">二叉搜索树</h3><p><strong>查找</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, SearchTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (x &lt; T-&gt;Element) <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, T-&gt;Left);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, T-&gt;Right);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">Insert_BST</span><span class="hljs-params">(BiTree &amp;T, ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SerachBST</span>(T, e.key, p)) &#123;<br>        s = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (BiTNode));<br>        s-&gt;data = e;<br>        s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">if</span> (!p) T = s;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &lt; p-&gt;data.key)<br>            p-&gt;lchild = s;<br>        <span class="hljs-keyword">else</span> p-&gt;rchild = s;<br><br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图">图</h3><p><strong>定义</strong><br>图G由顶点集V和关系集E组成,记为 G=(V,E)，V是顶点(元素)的有穷非空集，记为V(G).E是V中两个顶点对（称为边）的有穷集合。记为E(G).</p><p>有向图和无向图</p><p><strong>存储结构</strong></p><ol><li>邻接矩阵</li><li>邻接表</li></ol><h4 id="邻接矩阵-2">邻接矩阵</h4><p><strong>01矩阵</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_bcf65c6ce4-1.png" alt="1.png"><br><strong>权重矩阵</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_c47a3ea9e4-2.png" alt="2.png"></p><p>在无向图中顶点$v_i$的度等于邻接矩阵中第i行（或第i列）的元素之和（非零元素个数）</p><p>在有向图中，顶点$V_i$的出度为邻接矩阵中第i行元素之和，顶点$V_i$的入度为邻接矩阵中第i列元素之和</p><h4 id="邻接表">邻接表</h4><p><img src="https://img-blog.csdnimg.cn/20210702171839145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20210702172004557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20210702172113680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="图的邻接矩阵和邻接表的表示比较">图的邻接矩阵和邻接表的表示比较</h3><ol><li>一个图的邻接矩阵表示是唯一的；邻接表表示不唯一。邻接表中各边表结点的次序取决于建立算法和及输入边的次序.</li><li>邻接表（逆邻接表）中，每个边表对应邻接矩阵中的一行(或一列）；边表中结点的个数等于邻接矩阵中的一行(或一列)非0元素的个数。</li><li>邻接表或逆邻接表的空间复杂度为S(n,e)=O(n+e)。若图中的边数e远远小于n2,称为稀疏图，其邻接表比邻接矩阵要节省存储空间。当边数e接近n2 （无向图:e接近n(n-1)/2;有向图:e接近n(n-1)）时，称为稠密图,考虑链域占空间，应选择邻接矩阵存储为宜。</li><li>求有向图顶点的度，采用邻接矩阵比邻接表结构方便。在邻接表结构中，求顶点的出度容易，入度困难。逆邻接表中，求顶点的入度容易，出度困难。</li><li>判断边，邻接矩阵比邻接表容易；求边数：邻接矩阵中花费的时间复杂度为O(n2),邻接表中花费的时间复杂度为O(n+e)</li></ol><h3 id="图的遍历">图的遍历</h3><p><strong>深度优先搜索：</strong><br>关键：递归，栈<br>思想：选定一个出发点后进行遍历，如果有邻接的未被访问过的节点则继续前进。若不能继续前进，则回退一步再前进，若回退一步仍然不能前进，则连续后退至可以前进的位置为止。重复此过程，直到所有与选定点相通的节点都被遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v0)</span></span><br><span class="hljs-function"></span>&#123;<br>    visited[v0] = <span class="hljs-number">1</span>;<br>    w = <span class="hljs-built_in">firstadj</span>(g, v0);<br>    <span class="hljs-keyword">while</span> (w != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(w);<br>        w = <span class="hljs-built_in">nextadj</span>(g, v0, w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>广度优先搜索：</strong><br>关键：队列、类似层次遍历<br>思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Graph g, <span class="hljs-type">int</span> v0)</span></span>&#123;<br>    visited[v0] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">Enqueue</span>(Q, v0);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">Empty</span>(Q))&#123;<br>        v = <span class="hljs-built_in">Dlqueue</span>(Q);<br>        w = <span class="hljs-built_in">Firstadj</span>(g, v);<br>        <span class="hljs-keyword">while</span> (w != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-number">0</span>)&#123;<br>                visited[w] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">Enqueue</span>(Q, w);<br>            &#125;<br>            w = <span class="hljs-built_in">nextadj</span>(g, v, w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心算法">贪心算法</h3><p><strong>思想：</strong><br>在对问题求解时，总是<strong>做出在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的<strong>局部最优解</strong>。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是<strong>整体最优解的近似解</strong><br>活动安排问题<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_09805dd3e4-3.png" alt="3.png"></p><p>由于输入的活动以其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。<br>算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p><h3 id="Dijkstr算法求最短路径">Dijkstr算法求最短路径</h3><p><strong>算法思路</strong></p><ul><li>维护一个已被探索过的点集S。S中我们已经得到了从源点s到点u的最短路径</li><li>初始化S={s}，d(s)=0,d(其他)=$+\infty$</li><li>选择出未探索的点中具有最小$\pi(v)$值的点v<br>$$\pi(v)=mind(u)+l_e$$<br>下一个加入探索节点集的点假设为v’</li><li>添加v’到S，并设置d(v’)=$\pi(v’)$</li></ul><ol><li>无向图和有向图无影响</li><li>非负环无影响</li></ol><p><img src="https://img-blog.csdnimg.cn/20210704201100819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="第三章-操作系统">第三章 操作系统</h2><h3 id="程序顺序执行时的特征">程序顺序执行时的特征</h3><ol><li>顺序性<br>处理机的操作严格按照程序所规定的<strong>顺序</strong>执行</li><li>封闭性<br>程序运行时<strong>独占</strong>全机资源，程序一旦开始执行，其执行结果不受外界因素影响。</li><li>可再现性<br>只要程序执行时的环境和初始条件相同，都将获得<strong>相同</strong>的结果。</li></ol><h3 id="进程的定义">进程的定义</h3><ul><li>一个正在<strong>执行</strong>中的程序。</li><li>一个正在计算机上<strong>执行</strong>的程序实例。</li><li>能分配给处理器并由处理器<strong>执行</strong>的实体</li><li>一个具有以下特征的活动单元：一组指令序列的<strong>执行</strong>、一个当前状态和相关的系统资源集</li><li>可并发执行的程序在一个数据集合上的<strong>运行</strong>过程</li></ul><p><strong>引入进程的目的</strong><br>使<strong>多道</strong>程序能够正确地<strong>并发</strong>执行，以保证程序运行结果的可再现性。</p><h3 id="进程三状态转换模型">进程三状态转换模型</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_d1781c36e4-1.png" alt="1.png"></p><h3 id="进程五状态转换模型">进程五状态转换模型</h3><p><img src="https://img-blog.csdnimg.cn/20210702190638127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="挂起状态">挂起状态</h3><p><strong>定义：</strong><br>使执行程序暂停执行，静止下来，不再参与CPU竞争<br><strong>进程挂起的原因</strong></p><ul><li>进程全部阻塞，处理机空闲</li><li>系统负荷过重，内存空间紧张</li><li>操作系统需要，操作系统可能需要挂起后台进程或一些服务进程，或某些可能导致系统故障的进程。</li><li>终端用户的请求</li><li>父进程请求<br><strong>挂起和阻塞的区别：</strong></li><li>挂起是主动行为，阻塞是被动行为</li><li>阻塞会释放CPU，挂起不释放</li><li>挂起时进程在外存而不在主存</li></ul><h3 id="进程的构成和PCB（了解）">进程的构成和PCB（了解）</h3><p><strong>进程的构成</strong>：程序段+数据段+进程控制块(PCB)<br>**进程控制块PCB的作用：**进程存在的唯一标识；PCB常驻内存<br><strong>PCB内部的信息</strong>标识，处理机状态，进程调度信息，进程控制信息。</p><h3 id="运行Fork-创建进程">运行Fork()创建进程</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_2f1103c5e4-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_90d67df1e4-3.png" alt="3.png"><br>父进程要快一点，从fork下一句返回，但是子进程会采用一种操作使得fork返回值为0<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_aa6a7e6be4-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_eecd8bd7e4-5.png" alt="5.png"></p><h3 id="线程">线程</h3><p>**定义：**线程是进程中的一个实体，是独立调度和分派的基本单位。</p><p><strong>三类线程：</strong><br>分类依据：依据线程是否对内核透明</p><ol><li>用户级线程<br>线程的创建等操作全由应用进程完成，操作系统内核不知道线程的存在，仍以进程为调度单位</li></ol><blockquote><p>Infomix支持用户级线程</p></blockquote><ol start="2"><li>内核级线程<br>线程的创建等操作全由系统内核完成，以线程为调度单位</li></ol><blockquote><p>Windows 2000/XP、Linux和OS/2等操作系统采用了内核级线程技术</p></blockquote><ol start="3"><li>混合线程<br>线程的创建，撤销，调度和同步等操作在用户级应用程序中完成，多个用户级线程被影射到一个或较少的某些内核级线程</li></ol><blockquote><p>Solaris操作系统采用了混合线程模式</p></blockquote><h3 id="进程和线程的区别">进程和线程的区别</h3><ol><li>定义不一样，进程是执行中的一段程序，而一个进程中执行的每个任务即为一个线程</li><li>一个线程只属于一个进程，但一个进程可以包含多个线程</li><li>线程无地址空间，他被包含在进程的地址空间中</li><li>线程的开销比进程小</li></ol><h3 id="竞争临界资源引起的问题">竞争临界资源引起的问题</h3><p>间接制约【资源共享】 $\to$ 互斥<br>直接制约【进程合作】 $\to$ 同步<br><strong>临界资源</strong>：必须互斥使用的资源<br><img src="https://img-blog.csdnimg.cn/20210702194249623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>死锁：如果一组进程中的每一个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程是死锁的。<br>饥饿：指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。<br>例子：<br>死锁：砍树你需要一个斧子，但是斧子又需要木头来做，这就发生了死锁。<br>饥饿：排队过程中，总有人插队到你前面，你一直处于排队状态，这就发生了饥饿。</p><h3 id="互斥的条件">互斥的条件</h3><ul><li>空闲让进：如临界区空闲，则有进程申请就立即进入</li><li>忙则等待：每次只允许一个进程处于临界区</li><li>有限等待：保证进程在有限的时间内能进入临界区</li><li>让权等待：进程在临界区不能长时间阻塞等待某事件</li></ul><h3 id="信号量方法">信号量方法</h3><p>信号量的两个原子操作：<strong>wait(s)<strong>和</strong>signal(s)</strong>，有时也称作P(s)和V(s)。<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_451b0c1be4-1.png" alt="1.png"><br>P：先将信号量-1，判断信号量是否大于等于0，若是执行程序，否则进程阻塞，进入等待队列<br>V：使信号量+1，释放信号量<br><strong>信号量的物理意义</strong></p><ul><li>s.count &gt; 0表示目前临界资源的<strong>可用</strong>数量，即还可执行wait(s)而不会阻塞的进程数</li><li>每执行一个wait(s)操作，意味着<strong>请求分配</strong>一个单位的资源</li><li>s.count $\leq 0$ 表示已无可用的临界资源，请求该资源的进程被阻塞。此时，s.count的绝对值等于该信号量队列中的<strong>等待进程数</strong></li><li>执行一次signal操作，就意味着<strong>释放</strong>一个单位的资源。若s.count $\leq 0$ 表示s.queue队列中还有被阻塞的进程，需要唤醒该队列中的第一个进程，将它转移到就绪队列中。</li></ul><p><strong>wait，signal的应用</strong></p><ul><li>进程进入临界区之前，首先执行wait(s)原语，若s.count&lt;0,则进程调用阻塞原语，将自己<strong>阻塞</strong>，并插入到s.queue队列中排队。</li><li>一旦其他某个进程执行了signal(s)原语中的s.count+1操作后，发现s.count$\leq$0，即阻塞队列中还有被阻塞进程，则调用<strong>唤醒</strong>原语，把s.queue中第一个进程修改为就绪状态，送就绪队列，准备执行临界区代码。<br><strong>互斥信号量</strong><br>用于申请获释放资源的使用权，通常初始化为1<br><strong>资源信号量</strong><br>用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数<br><strong>互斥信号量的取值范围和含义</strong></li><li><strong>两个</strong>并发程序共享临界资源<ul><li>s.count=1,表示无进程进入临界区</li><li>s.count=0,表示已有一个进程进入临界区</li><li>s.count=-1,则表示已有一个进程正在等待进入临界区</li></ul></li><li><strong>n个</strong>进程共享临界区<br>$$-(n-1)\leq s.count \leq 1$$<br><strong>资源信号量的取值范围</strong><br>依赖于<strong>临界资源数量</strong>和<strong>并发程序数量</strong></li></ul><h3 id="生产者消费者问题">生产者消费者问题</h3><p>缓冲区：固定长度<br>生产者：满则等待，空则填充<br>消费者：空则等待，有则获取</p><ul><li>各个生产者，消费者<strong>独立自主</strong>向前推进<ul><li>指针in和out初始化指向缓冲区的第一个存储单元</li><li>生产者通过in指针向存储单元存放数据，一次存放一条数据</li><li>每存放一条数据，in指针向后移动一个位置</li><li>消费者从缓冲区中逐条取走数据，一次取一条数据，相应的存储单元变为“空”</li><li>每取走一条数据后，out指针向后移动一个存储单元</li></ul></li><li>生产者/消费者必须互斥<ul><li>生产者和消费者不能同时读写一个存储单元</li><li>多个生产者不能同时写缓冲区</li><li>多个消费者不能同时取缓冲区数据</li></ul></li><li>生产者/消费者必须同步<ul><li>生产者不能向满缓冲区写数据</li><li>消费者也不能在空缓冲区中取数据<br><strong>用PV解决生产者消费者模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_418f766ae4-1.png" alt="1.png"></li></ul></li></ul><p><strong>例题</strong></p><ol><li>图书馆有N个座位，一张登记表，要求(1)阅读者进入时登记，取得座位号；(2)出来时注销。请用P、V操作描述一个读者的使用过程。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP">semaphore empty = N; <span class="hljs-comment">// 记录空闲座位数量</span><br>semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 作为互斥的登记和注销操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(empty);<br>    <span class="hljs-built_in">P</span>(mutex);<br>    <span class="hljs-comment">//登记</span><br>    <span class="hljs-built_in">V</span>(mutex);<br>    <span class="hljs-comment">//阅读</span><br>    <span class="hljs-built_in">P</span>(mutex);<br>    <span class="hljs-comment">//注销</span><br>    <span class="hljs-built_in">V</span>(empty);<br>    <span class="hljs-built_in">V</span>(mutex);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>有3个进程PA，PB和PC合作解决文件打印问题：(1)PA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录；(2)PB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；(3)PC将缓冲区2的内容打印出来，每执行一次打印一个记录。缓冲区的大小等于一个记录大小。请用P，V操作来保证文件的正确打印。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">int</span> empty1=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录缓冲区 1 是否为空</span><br><span class="hljs-type">int</span> empty2=<span class="hljs-number">1</span>; <span class="hljs-comment">//记录缓冲区 2 是否为空</span><br><span class="hljs-type">int</span> full1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录缓冲区 1 是否有数据</span><br><span class="hljs-type">int</span> full2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录缓冲区 2 是否有数据</span><br><span class="hljs-type">int</span> mutex1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//对缓冲区 1 的访问互斥</span><br><span class="hljs-type">int</span> mutex2 = <span class="hljs-number">1</span>;<span class="hljs-comment">//对缓冲区 2 的访问互斥</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">cobegin</span><br><span class="hljs-function">    <span class="hljs-title">PA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-built_in">PB</span>();<br>    <span class="hljs-built_in">PC</span>();<br>    coend<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//从磁盘读数据</span><br>    <span class="hljs-built_in">P</span>(empty1);<br>    <span class="hljs-built_in">P</span>(mutex1);<br>    <span class="hljs-comment">//将数据存入缓冲区 1</span><br>    <span class="hljs-built_in">V</span>(mutex1);<br>    <span class="hljs-built_in">V</span>(full1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PB</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(full1);<br>    <span class="hljs-built_in">P</span>(mutex1);<br>    <span class="hljs-comment">//从缓冲区 1 读数据</span><br>    <span class="hljs-built_in">V</span>(mutex1);<br>    <span class="hljs-built_in">V</span>(empty1);<br>    <span class="hljs-built_in">P</span>(empty2);<br>    <span class="hljs-built_in">P</span>(mutex2);<br>    <span class="hljs-comment">//将数据写入缓冲区 2</span><br>    <span class="hljs-built_in">V</span>(mutex2);<br>    <span class="hljs-built_in">V</span>(full2);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PC</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(full2);<br>    <span class="hljs-built_in">P</span>(mutex2);<br>    <span class="hljs-comment">//读取缓冲区 2 的数据并打印</span><br>    <span class="hljs-built_in">V</span>(mutex2);<br>    <span class="hljs-built_in">V</span>(empty2)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进程间的通信">进程间的通信</h3><p><strong>低级通信</strong><br>以信号，信号量作为通信工具，由于其所交换的信息量少而被归结为低级通信<br><strong>高级通信</strong><br>用户可直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式<br><strong>消息传递的同步</strong><br>当发送进程调用Send原语发送消息时，若没有空闲的消息缓冲区，则发送进程阻塞<br>当接受进程调用Receive原语接收消息时，如果没有消息可接收，则接收进程阻塞，直到一条消息到达。<br><strong>三种同步方式</strong><br>阻塞发送，阻塞接收<br>不阻塞发送， 阻塞接收<br>不阻塞发送，不阻塞接收<br><strong>如何利用信息传递实现互斥</strong></p><blockquote><p><strong>互斥</strong>：不允许<strong>两个</strong>或<strong>两个以上</strong>的进程<strong>同时</strong>进入临界区</p></blockquote><ul><li>多个并发执行的发送进程和接收进程共享一个邮箱box，且box的初始状态为仅包含一条空消息；</li><li>采用“不阻塞发送，阻塞接收”方式传递消息；</li><li>若邮箱中存在一条消息，则允许一个进程进入临界区。</li><li>若邮箱为空，则表明有一个进程位于临界区，其它试图进入临界区的进程必须阻塞。</li><li>只要保证邮箱中最多只有一条消息，就能保证只允许一个进程进入临界区，从而实现进程互斥使用临界资源。<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_da2a4d7ee4-2.png" alt="2.png"></li></ul><h3 id="链接方式">链接方式</h3><p><strong>高级语言源代码转换为进程的3个基本步骤</strong></p><ol><li>编译</li><li>链接</li><li>装入<br><strong>静态链接：<strong>在程序运行之前，先将目标模块及他们所需的库函数，链接成一个</strong>完整的装配模块</strong>，以后不再拆开<br>缺点：不利于代码共享；不利于模块的独立升级；可能链接一些不会执行的模块，浪费空间和处理时间<br>**装入时链接：**目标模块在装入内存时，采用边装入边链接的链接方式。<br>优点：便于各模块的独立升级；便于实现模块的共享。<br>缺点：可能链接一些不会执行的模块，浪费空间和处理时间；装入后不能移动位置<br><strong>运行时动态链接：<strong>对于某些目标模块的链接，是在程序</strong>执行</strong>中需要该模块时，由操作系统去找到该模块并将其装入内存，随后把它链接到调用者模块上。<br>优点：不会装入未被用到的目标模块，加快了程序的装入过程，<strong>节省</strong>大量内存空间<br><strong>三者的区别</strong><br>分别在运行之前链接个模块和所需库函数，边装入边链接，执行时链接</li></ol><h3 id="装入方式（了解）">装入方式（了解）</h3><p><strong>绝对装入方式：</strong><br>优点：实现简单。<br>缺点：每次必须装入同一内存区，需要提前知道内存使用情况；不适于多道程序系统。<br><strong>可重定位装入方式：</strong><br>优点：容易实现。<br>缺点：装入后不能移动；存储空间只能连续分配；难于共享</p><h2 id="第四章-编译原理">第四章 编译原理</h2><h3 id="编译相关概念">编译相关概念</h3><p><strong>翻译</strong>：将一种语言编写的程序转换成完全等效的另一种语言编写的程序的过程称为翻译；在计算机中，翻译由一个程序来实现，称为翻译程序。<br><strong>编译</strong>：将高级程序语言翻译成低级语言程序称为编译<br><strong>三种语言</strong>：源语言，工具语言，目标语言<br><strong>三种程序</strong>：源程序，编译程序，目标程序</p><h3 id="编译前端与后端">编译前端与后端</h3><blockquote><p>前端和后端通过中间代码连接，可极大的提高编译器设计与实现的效率<br>前端：主要是与源语言相关的部分<br>词法，语法分析，语义分析和中间代码是生成等<br>后端：主要是与目标语言相关的部分<br>包括优化，目标代码生成等</p></blockquote><h3 id="定义语言">定义语言</h3><p>语言=语法（规则）+语义（规则）<br><strong>语法</strong>：用以<strong>构造语言（程序）<strong>及其成分（语法单位）的</strong>规则</strong>的集合<br><strong>语义</strong>：用以规定语法正确的语法单位<strong>含义</strong>的<strong>规则</strong>的集合</p><p><strong>如何定义一门语言</strong><br>生成（文法）；识别（语法图）</p><blockquote><p>文法和语法图是语言语法的等价表示，<strong>文法从产生的观点来定义语言的语法</strong>，更通用，更准确。<strong>语法图以识别的观点定义语言的语法</strong>，更直观，更清晰。采用生成的方法还是采用识别的方法来定义由语言的设计者确定<br><strong>语法图</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_06004362e5-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_3916c99fe5-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_3daeebece5-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_3f47f8c5e5-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_429e8a18e5-5.png" alt="5.png"></p></blockquote><h3 id="文法">文法</h3><p><strong>定义：<strong>文法是描述语言的语法结构的形式规则，文法G定义成一个四元式：G=($V_T$, $V_N$, $S$, $P$),其中$V_T$是终结符的有限集合，$V_N$是非终结符的有限集合；S是开始符号，S $\in V_N$，P是产生式的非空有限集<br><strong>0型文法</strong>：<br>又称短文语法，能力相当于图灵机<br>产生式形如：α→β，α$\in (V_N ∪ V_T)$且至少含有一个非终结符，β$\in(V_N ∪ V_T)*$<br><strong>产生式左边至少有一个大写字母（非终结符），右边随意</strong><br><strong>1型文法</strong>：<br>上下文有关文法，对终结符进行替换时必须考虑上下文<br>对于其产生式：α→β 要求 |α|≦|β| （S→ε例外） 或产生式形如 αAβ→αωβ，ω属于V +<br>即</strong>右边生成的字母个数必须大于等于左边的字母个数</strong><br><strong>2型文法</strong><br><a href="https://www.zhihu.com/question/21833944">二型文法的理解</a><br>上下文无关文法，简称文法<br>A→α 即产生式左边必须完全都是大写字母。<br><strong>3型文法</strong><br>正则文法，右线性文法<br>A→α 或 A→αB 其中 A、B ∈ $V_N$ ，α ∈ $V_T$ *<br>通俗的解释：所有产生式右边要么没有大写字母，如果有，必须全部写在小写字母的同一边，也就是要保持线性一致<br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_9c176cc3e5-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_9e6f12bce5-7.png" alt="7.png"><br><strong>约定</strong></p><ul><li>用<strong>英文大写字母</strong>表示终结符</li><li><strong>小写字母</strong>表示<strong>终结符</strong></li><li><strong>希腊小写字母</strong>表示<strong>串</strong></li></ul><h3 id="推导和规约">推导和规约</h3><p><a href="https://blog.csdn.net/weixin_43320847/article/details/105032230?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165445214616781483761418%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165445214616781483761418&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-105032230-null-null.142%5Ev11%5Econtrol,157%5Ev13%5Econtrol&amp;utm_term=%E6%8E%A8%E5%AF%BC%E4%B8%8E%E8%A7%84%E7%BA%A6&amp;spm=1018.2226.3001.4187">推导和规约</a><br><strong>推导</strong>：由产生式右边替换产生式左边<br><strong>规约</strong>：推导的逆过程<br>若存在$v =w0\Rightarrow w1 \Rightarrow …\Rightarrow wn=w, (n&gt;0)称v推导出（产生）w（推导长度为n）, w规约到v$,$记作v \Rightarrow ^{+} w$</p><p>$若有 v \Rightarrow ^{+} w或v=w，则记为v\Rightarrow ^{*}w$</p><p>$\Rightarrow ^{*}包含左右相等即推导长度等于0的情况即最小步数为0而\Rightarrow ^{+}不包括$，即最小步数为1</p><p><strong>最左推导过程</strong>:总是选择每个句型的最左非终结符进行替换<br><img src="https://img-blog.csdnimg.cn/20210703133644202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>最右推导过程（规范推导）</strong>:也称为规范推导，总是选择每个句型的最右非终结符进行替换<br><img src="https://img-blog.csdnimg.cn/20210703133718705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="句型和句子">句型和句子</h3><p><img src="https://img-blog.csdnimg.cn/20210703133939317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>二者关系</strong>：句子是只含终结符的句型，特殊情况<br><img src="https://img-blog.csdnimg.cn/20210703134512198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>注意s本身也是一个句型</strong></p><h3 id="文法和语言">文法和语言</h3><p>文法 G=($V_T,V_N,S,P$) 产生的所有句子的集合, 称为由文法G产生的语言记为L(G)<br>例：<br><img src="https://img-blog.csdnimg.cn/20210703135019956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>若两个文法G和G2有L(G)=L(G2), 则称两文法等价</p><h3 id="短句和直接短语">短句和直接短语</h3><p>令G是一个文法，S是文法的开始符号，假定 αβδ是文法G的一个句型，</p><p>如果有S$\Rightarrow^{*}$ αAδ且 A $\Rightarrow^{+}$ β，则此时称β是相对于非终结符A的, 句型αβδ的短语；</p><p>如果有 S$\Rightarrow^{*}$αAδ且 A $\Rightarrow$ β，则此时称β是相对于非终结符A的, 句型αβδ的直接短语；</p><p>区别在于A是不是一步推导出β，注意不是αAδ的短语</p><p>补充：素短语：含有终结符的短语，并且它的真子 串不具有这个特性。</p><h3 id="句柄">句柄</h3><p><strong>定义</strong>：一个<strong>句型</strong>的<strong>最左直接短语</strong>称为该句型的句柄。<br><strong>特征</strong>：直接短语，所以，它是某规则右部；<br>它是最左边的直接短语<br>一个句型的直接短语可能不止一个，但是其最左直接短语是唯一的。<br><img src="https://img-blog.csdnimg.cn/20210703140457498.png" alt=""></p><h3 id="语法树">语法树</h3><p>语法树的构造过程是从文法的开始符号出发，构造了一个推导的过程<br><img src="https://img-blog.csdnimg.cn/20210703142807306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>文法的二义性</strong>：一个句子有两颗不同的推导树<br><strong>依语法树求：</strong></p><ol><li>n个内部节点（根节点也算）则有n颗子树，每颗子树的叶节点从左至右排列组成一个<strong>短语</strong></li><li>只有父子两代的为直接子树，其叶节点从左至右排列为<strong>直接短语</strong></li><li>由最左端的直接子树求的<strong>句柄</strong></li></ol><h3 id="编译步骤">编译步骤</h3><p><img src="https://img-blog.csdnimg.cn/20210703145437932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><ol><li>词法分析：输入字符串，根据词法规则识别出单词符号</li><li>语法分析：根据语法规则，将单词符号构成各类语法单位，并进行语法检查</li><li>语义分析：根据语义规则，理解语句功能，进行初步编译</li><li>优化：对中间代码进行时间，空间优化，以使代码更有效</li><li>目标代码生成：生成机器语言程序或汇编语言程序</li><li>符号表管理：完成符号表的建立，查找，更新</li><li>出错处理：发现，指出，限制</li></ol><p><strong>说明：</strong></p><ul><li>使用的编译程序不一定总是分成5个阶段</li><li>目标程序不一定能立即执行，可能还要经过链接，装入等阶段</li><li>编译的各阶段均需要和符号表管理程序，出错处理程序打交道</li></ul><h3 id="词法分析">词法分析</h3><p><strong>词法分析功能</strong>：</p><ol><li><strong>扫描</strong>源程序的字符串</li><li>按照词法<strong>规则</strong></li><li><strong>识别</strong>出单词符号作为输出</li><li>对识别过程中发现的词法错误，则输出出错误信息</li><li>过滤到源程序中的注释和空白</li><li>将编译器生成的错误信息与源程序的位置关</li></ol><blockquote><p>词法分析器在编译器中负责1.读取源程序，2.识别单词</p></blockquote><p><strong>词法分析器的输出形式</strong></p><ol><li>单词种类</li></ol><ul><li>标识符：用来命名程序中出现的变量、数组、函 数、过程、标号等</li><li>基本字：也可称关键字或保留字, 如if、while、 for、do、goto等</li><li>常数：各种类型的常数, 如216、3.14159、TRUE 等</li><li>运算符：如+  -   *   /等</li><li>界符：如;   :   /*   */等</li></ul><ol start="2"><li>单词的输出形式</li></ol><ul><li>二元组<br><strong>词法分析扫描缓冲区结构</strong><br><img src="https://img-blog.csdnimg.cn/2021070413582328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li></ul><ol><li>输入缓冲区：源程序 =&gt;输入缓冲区</li><li>预处理程序：取消注解，剔除无用的空白、跳格、回车、换行等</li><li>扫描缓冲区：输入固定长度字符串，双缓冲区结构：左缓冲区读完后新读入的字符存入右缓冲区</li><li>词法分析：直接在扫描缓冲区进行符号识别<br><strong>超前搜索</strong>：为了判断一个单词符号的类别，而该单词符号并没有这么长，这种扫描方式叫做“超前搜索”<br>起始指针：用来指示正在扫描的单词的起点<br>搜索指针：用来向前搜索，寻找单词的结束</li></ol><h3 id="词法分析两大类型">词法分析两大类型</h3><p><strong>自上而下</strong><br>从文法开始符出发，能否找到一个<strong>最左推导</strong>序列，使得s$\Rightarrow^*w$<br>或者从根节点S开始，能否构造一颗语法树，使得该语法树的叶节点自左至右的连接正好是w？<br><strong>自下而上</strong>：<br>从w出发，能否找到一个<strong>最左规约</strong>（最右推导的逆过程）序列，逐步向上规约，直至文法的开始符S？或者对生成的w语法树，按最左规约对语法树进行剪枝，能否最后只剩下根节点S<br>基本方法：采用栈，移进–规约，将输入串的符号一次入栈，若栈顶（一个或多个符号）形成某个非终止符的候选式（注意此时在栈中  从下往上读），则将其替换，最后只剩下开始符号S则合法<br><img src="https://img-blog.csdnimg.cn/2021070415241429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="自下而上可能遇到的问题">自下而上可能遇到的问题</h3><p>**关键问题：**如何判断栈顶符号串能否形成可规约串？如何进行规约？<br>二者冲突：移进与归约的冲突；归约与归约的冲突</p><h3 id="确定与不确定">确定与不确定</h3><p>自下而上的语法分析分为不确定性和确定的两类<br>回溯分析法是不确定的分析方法<br>递归下降分析法和预测分析法属于确定的分析方法。</p><h3 id="递归下降分析法">递归下降分析法</h3><p><strong>产生回溯的原因</strong><br>1.</p><ol><li>公共左因子：<br>是指在文法的产生式集合中，某个非终止符的多个候选式具有相同的前缀。如：$\alpha \to \alpha \beta_1 | \alpha \beta_2$<br>解决方法：提取左公共因子<br><img src="https://img-blog.csdnimg.cn/20210704141632618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>例如：<br><img src="https://img-blog.csdnimg.cn/20210704141723941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>左递归<br>可能产生无限循环<br>形式为：$A \Rightarrow^+ A\beta$或者直接$A \Rightarrow A\beta$<br>解决办法：</li><li>直接左递归的消除，改写为右递归<br><img src="https://img-blog.csdnimg.cn/20210704143109316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>间接左递归的消除，先把候选式转为直接左递归<br><img src="https://img-blog.csdnimg.cn/20210704143556491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li></ol><h3 id="预测分析法">预测分析法</h3><p><a href="https://www.bilibili.com/video/BV1Cu411m7VX/?spm_id_from=333.788.recommend_more_video.-1">预测分析法</a><br><a href="">预测分析法</a><br><strong>组成</strong>：预测分析法是一种表驱动的方法，它由下推栈，预测分析表和控制程序组成<br><strong>三种情况的判断</strong></p><ol><li>若</li></ol><h3 id="一遍扫描处理法">一遍扫描处理法</h3><p>在语法分析的同时计算属性值</p><h3 id="算法优先分析法">算法优先分析法</h3><h3 id="FIRSTVT集">FIRSTVT集</h3><h3 id="LASTVT集">LASTVT集</h3><h3 id="优先关系表构造法">优先关系表构造法</h3><h2 id="第五章-数据库">第五章 数据库</h2><h3 id="数据库基本概念">数据库基本概念</h3><p><strong>数据库定义</strong>：数据库（Database,简称DB）是长期存储在计算机内，有组织，可共享的大量数据集合<br><strong>数据</strong>：数据是一种符号序列，它的内容是事物特性的反映。数据是对现实世界的事物采用计算机能够识别，存储和处理的方法进行描述，或者说是计算机化的信息。<br><strong>DBMS数据库管理系统</strong>：一个能让用户定义，创建和维护数据库以及控制数据库访问的软件系统。由查询器和存储器管理组成。<br><strong>数据库系统</strong>：数据库系统是指在计算机系统中引入数据库后的系统组成。</p><h3 id="数据管理技术体系结构分类">数据管理技术体系结构分类</h3><ul><li>集中式</li><li>客户机/服务器式</li><li>并行式</li><li>分布式</li><li>基于互联网</li></ul><h3 id="模式的体系结构">模式的体系结构</h3><p><strong>模式的定义：</strong>：数据库逻辑结构和特征的描述；是型的描述；反映的是数据的结构及联系；模式是相对稳定的<br><strong>三种模式</strong>：</p><ol><li>内模式：是数据物理结构和存储方式的描述，是数据在数据库内部的表示方法，要改变存储数据库的结构，仅需把修改反映在存储模式中，一个数据库只有一个<strong>内模式</strong></li><li>模式：数据库中全体数据的逻辑结构和特征描述，所有用户的公共数据视图，综合了所有用户的需求，一个数据库只有一个模式</li><li>外模式：数据库用户（包括应用程序员和最终用户）使用的局部数据逻辑结构和特征描述，外模式可以有多个，可以不同，是模式的子集和变形<br><img src="https://cdn.acwing.com/media/article/image/2022/06/07/99310_4b66e42be5-1.png" alt="1.png"><br><strong>独立性</strong></li></ol><ul><li>逻辑数据独立性：外部数据不受概念模式变化影响</li><li>物理数据独立性：概念模式不受内部模式影响</li></ul><h3 id="数据模型">数据模型</h3><ul><li>概念模型</li><li>逻辑模型</li><li>物理模型</li></ul><h3 id="数据模型三要素">数据模型三要素</h3><ul><li>数据结构</li><li>数据操作</li><li>数据的约束条件</li></ul><h3 id="关系模型基本概念">关系模型基本概念</h3><p>关系：是笛卡尔积的一个有意义的子集，是一张二维表<br>元组：表中的一行，表示一个实体，关系是由元组组成<br>属性：表中的每一列在关系中称为属性<br>域：属性的取值范围称为域<br>分量：元组中的一个属性值<br><img src="https://img-blog.csdnimg.cn/20210703170548298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="关系运算">关系运算</h3><ol><li>并</li><li>交</li><li>差</li><li>笛卡尔运算：<br>两个分别为n目和m目的关系R和S的笛卡尔积是一个 （n＋m）列的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。<br><img src="https://img-blog.csdnimg.cn/20210703184217834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>选择运算<br>从关系中找出满足给定条件的所有元组称为选择<br><img src="https://img-blog.csdnimg.cn/20210703184344336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>投影运算<br><img src="https://img-blog.csdnimg.cn/20210703184505747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>条件连接（θ连接):<br>在两个关系的笛卡尔积上进行的选择运算。<br><img src="https://img-blog.csdnimg.cn/20210703185638390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>自然连接<br>从两个关系的广义笛卡儿积中选取在相同属性列B上取值相等的元组，并去掉重复的行。<br>如果两个关系没有公共属性，自然连接就是笛卡尔积<br><img src="https://img-blog.csdnimg.cn/20210703210434273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li></ol><h3 id="连接运算">连接运算</h3><ol><li>等值连接<br>θ为“=”的条件连接</li><li>自然连接</li><li>左连接<br>R左连接S：所有来自R的元组和那些连接字段相等处的S的元组。</li><li>右连接<br>R右连接S：所有来自S的元组和那些连接字段相等处 的R的元组。<br><img src="https://img-blog.csdnimg.cn/20210703212448211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li></ol><h3 id="关系模式">关系模式</h3><p>包含关系名，属性的名字及相关联的域，完整性约束</p><h3 id="完整性约束">完整性约束</h3><p>定义：关系模式的完整性规则是对关系的某种约束条件，保证数据库中数据的正确性和一致性<br>实体完整性：主码不能取空值<br>参照完整性：通过外码实现，避免孤子记录<br>用户定义的完整性：各类商业规则<br>实体完整性和参照完整是关系模式必须满足的完整性约束条件，被称为是关系的不变性，应该由关系系统自动支持</p><h3 id="函数依赖">函数依赖</h3><p><strong>定义</strong>：<br><img src="https://img-blog.csdnimg.cn/20210703214419712.png" alt=""><br><strong>符号说明：</strong><br>t[X]表示元组t在属性X上的取值。例如 t[Dname] = ‘杨勋’<br><img src="https://img-blog.csdnimg.cn/202107032147340.png" alt=""></p><p>平凡函数依赖：如果Y⊆X,显然X→Y成立</p><p>完全函数依赖：X、Y是某关系不同属性集；不存在X’⊂X,使得 X’→Y成立</p><p>部分函数依赖：X、Y是某关系不同属性集；存在X’⊂X,使得 X’→Y成立</p><p>传递函数依赖：X、Y、Z是某关系不同属性集，如果X→Y， Y→Z，且不存在Y → X（说明X和Y不是一一对应），则X→Z。</p><p>在就诊关系R中，存在函数依赖Dname→Dlevel，Dlevel→Dsal，所以Dname→ Dsal。</p><h3 id="主码和候选码">主码和候选码</h3><p><img src="https://img-blog.csdnimg.cn/2021070322361337.png" alt=""><br>包含在任何候选码中的属性称为主属性（Prime Attribute）。不包含在任何候选码中的属性称为非主属性（Non-Key Attribute）。最简单的情况，单个属性是码。最极端的情况，整个属性组是码，称为全码（All-key）</p><h3 id="模式分解">模式分解</h3><p>定义：<br><img src="https://img-blog.csdnimg.cn/20210703223947757.png" alt=""><br>无损分解：</p><p>无损中的损是指信息丢失。如果一个分解不是无损分解， 则所得结果的元组数总比原来的多（增加了噪声，但把原来的信息丢失了）。所谓“有损”就损在出现多余的元组上。</p><p><img src="https://img-blog.csdnimg.cn/2021070322453820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="不好的模式造成问题">不好的模式造成问题</h3><ul><li>数据冗余</li><li>操作异常<ul><li>更新异常</li><li>删除异常</li><li>插入异常</li></ul></li></ul><h3 id="范式">范式</h3><p>定义：</p><p>范式（Normal Forma，NF）是一种关系的状态，是衡量关系模式的标准。</p><p>1NF：每个属性值都是不可再分的原子值，不允许出现表中有表的现象</p><p>2NF：关系模式R∈1NF，且每个非主属性（不是组成候选码的属性）完全函数依赖于候选码</p><p>3NF：关系模式R∈1NF，且不存在部分依赖和传递依赖</p><p>如何区分：若存在部分依赖则必是1NF，不存在部分依赖和传递依赖则必是3NF</p><p>如何判断是否部分依赖于主码：找出一个属性只依赖于主码中的一个（主码本身有多个属性）</p><p><img src="https://img-blog.csdnimg.cn/20200515154918593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="重要例题">重要例题</h3><p>寻找依赖关系、确定候选码、判断范式类型、模式分解</p><p>【转载】<a href="https://blog.csdn.net/weixin_43941364/article/details/106143475">(3条消息) 数据库关系模式的函数依赖习题讲解_WS的小屋-CSDN博客_数据库函数依赖例题</a></p><h3 id="三种数据模型">三种数据模型</h3><p>关系、网状、层状数据模型</p><h3 id="E-R模型">E-R模型</h3><p>概念：面向问题的概念模型；用简单的图形方式（E-R图）描述显示世界中的数据；E-R图不涉及数据在数据库中的表示和存取方法；非常接近人的思维方式</p><p><strong>结构</strong>实体用方框，属性用椭圆框，关系用菱形框<br><img src="https://img-blog.csdnimg.cn/20210704124543154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>构造数据库的方法</strong>：在需求分析的基础上，用E-R图构造一个反映现实世界实体之间联系的企业模式转换成基于某一特定的DBMS的概念模式。</p><h3 id="数据库设计阶段">数据库设计阶段</h3><ol><li><p><strong>需求分析阶段</strong>：</p></li><li><p><strong>概念设计阶段</strong>：将用户的需求抽象为用户与开发人员都能接受的概念模型，</p></li><li><p><strong>逻辑设计阶段</strong>：把抽象的概念结构进一步转换为可以被具体的DBMS产品所能支持的数据模型</p></li><li><p><strong>物理设计阶段</strong>：确定的物理存储结构</p></li><li><p><strong>实现阶段</strong>：开发和调试，以及现实数据的录入和试运行等基本工作。</p></li><li><p><strong>运行与维护阶段</strong>：保证数据库系统的效率，以及根据实际运行情况和用户的需求变动进行调整</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算智能复习</title>
      <link href="/2022/05/23/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/23/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-互联网情境下的智能预测">第一章 互联网情境下的智能预测</h2><h3 id="强弱连接基本概念">强弱连接基本概念</h3><p>强连接：连接稳定，共通点多，传播范围有限，例如亲戚，朋友，社会认知<br>弱连接：共同点少，例如无意间提到或打开收音机听到的信息</p><h3 id="图的定义">图的定义</h3><p>一个图G=(V,E)由一个非空顶点（或节点）集合V和一个边集合E组成。每条边都有一个或两个与之相关的顶点，称为端点。一条边被称为连接它的端点。</p><h3 id="邻接矩阵">邻接矩阵</h3><p><strong>基本规则</strong><br>连边存在，值为1，连边不存在值为0.<br><strong>对于有向图</strong><br>第i行的含义为从顶点$v_i$出发的边，出度边，箭头的尾，即<strong>出度=第i行中元素之和</strong><br>第j列的含义为到顶点$v_j$结束的边，入度边，箭头的头，即<strong>入度=第i列中元素之和</strong><br><strong>邻接矩阵的n次方</strong><br>R代表可通过1条边到达某节点之间的路径数</p><p>$R*R=R^2$代表可通过R的两条边到达某节点的路径数</p><p>$R^n$代表可通过R中n条边到达的某节点的路径数</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/26/99310_17b7bce5dc-1.png" alt="1.png"></p><p><strong>优点：</strong></p><ul><li>直观，简单</li><li>方便寻找是否有连边存在</li><li>方便寻找任意顶点的邻接点</li><li>方便计算任意顶点的度</li></ul><p><strong>缺点：</strong></p><ul><li>不便于增删节点</li><li>浪费空间：稀疏图（点多，边少），有大量元素</li><li>浪费时间：稀疏图统计需要大量时间</li></ul><h3 id="交叉验证Cross-Validation">交叉验证Cross Validation</h3><p><strong>定义</strong><br>Cross Validation也叫Rotation Estimation，是一种统计学上讲数据样本切割成较小子集的使用方法</p><p><strong>目的：</strong><br>为了得到稳定可靠的模型</p><blockquote><p>在神经网络中常常将样本分为训练集，验证集，测试集，能提高训练精度防止过拟合<br><strong>常见形式</strong><br>K-Fold Cross Validation</p></blockquote><h3 id="混淆矩阵">混淆矩阵</h3><p><strong>定义：</strong><br>也叫误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵来表示（n代表预测类别）<br><strong>二元分类-预测类别：</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/26/99310_84c171d2dc-2.png" alt="2.png"></p><blockquote><p>关于上表的理解，阳性为真，阴性为假，真阳性就是预测为真，实际也为真，假阳性就是预测为真，但实际为假的，假阴性就是预测为假，实际为真，而真阴性就是预测为假，实际也为假，后面的单词就是缩写，真的为T，假的为F，阳性为P，阴性为N</p></blockquote><h3 id="链路预测">链路预测</h3><p><strong>定义：</strong><br>网络中的链路预测（Link Prediction）是指通过已知的网络节点以及网络结构等信息预测网络中尚未产生连边的两个节点之间产生链接的可能性。</p><p>如果两个节点具有相似的网络结构，则他们是相连的</p><p><strong>目的：</strong><br>预测两节点相连的可能性</p><p><strong>应用：</strong><br>社交媒体，好友推荐</p><p><strong>相似度指数：</strong><br>局部相似度Local similarity Indices：仅使用局部信息（信息 节点周围），不是很准确但很快<br>全局相似度Global similarity indices：使用全局信息（信息 在整个网络中），更准确但成本高<br>准本地指数Quasi-local indices：本地和全球之间的权衡</p><p><strong>分类</strong><br>Local Prediction</p><ul><li>公共邻居Common neighbors (CN)<br>两个节点的公共邻居个数<br><img src="https://img-blog.csdnimg.cn/20210629142818578.png" alt="1.png"></li><li>公共邻居比例Jaccard (JC)<br>公共邻居数占两点总邻居的比例<br><img src="https://img-blog.csdnimg.cn/20210629141325855.png" alt="1.png"></li><li>资源分配Resource Allocation (RA)<br>公共邻居的度取倒数，然后累加<br><img src="https://img-blog.csdnimg.cn/20210629141534871.png" alt="1.png"></li></ul><blockquote><p>可以看作公共邻居分配给自己的资源</p></blockquote><ul><li>Adamic-Adar (AA)<br>公共邻居的度数取对后再取倒数，然后累加<br><img src="https://img-blog.csdnimg.cn/20210629141651353.png" alt="1.png"></li><li>Preferential attachment (PA) …<br>两节点度 相乘<br><img src="https://img-blog.csdnimg.cn/20210629142733325.png" alt="1.png"></li></ul><p>Global Prediction</p><ul><li>Katz score</li><li>Hitting time</li><li>PageRank …</li></ul><p>Quasi-Local Prediction</p><h3 id="链路预测-机器学习性能评估指标">链路预测/机器学习性能评估指标</h3><p><strong>灵敏度Sensitivity=召回率Recall</strong></p><p>真阳性率，实际阳性案例中，检测出阳性的比例</p><blockquote><p>实际阳性包括真阳和假阴</p></blockquote><p>真阳性率=$\frac{TP}{TP+FN}$</p><p><strong>特异性Specificity</strong><br>真阴性率，实际阴性案例中，检测出阴性的比例</p><blockquote><p>实际阴性包括真阴和假阳</p></blockquote><p>真阴性率=$\frac{TN}{FP+TN}$</p><p><strong>Precision</strong><br>被预测出阳性的案例中实际为阳性的比例</p><p>$$\frac{TP}{TP+FP}$$</p><p><strong>Accuracy</strong><br>正确分类样本数占总样本数的比例，该值越高，分类效果越好</p><p>$$\frac{TP+TN}{TP+FP+TN+FN}$$</p><p><img src="https://img-blog.csdnimg.cn/20210626145320729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><strong>ROC&amp;AUC</strong><br>ROC是以真阳率和真阴率为轴的曲线</p><p>AUC是ROC曲线与坐标轴围成的面积，面积越接近于1，分类效果越好</p><h3 id="网页排序PageRank">网页排序PageRank</h3><p><strong>核心思想：</strong> 非竞价排名</p><p><strong>数量假设：</strong> 在Web图模型中，如果一个页面节点接收到的其他页面指向的入链数量越多，那么这个页面越重要</p><p><strong>质量假设：</strong> 指向网页的入链质量不同，质量高的页面会通过链接向其他页面传递更多的权重。所以越是质量高的页面指向网页，则这个页面越重要。</p><p><strong>迭代公式：</strong><br>$$PR(i)=\sum_{j \in B_i}\frac{PR(j)}{O_j}$$</p><p>$O_j$表示出度，$B_i$表示指向page i的所有网页集</p><p><strong>排名泄露</strong><br>如果存在网页没有出度链接，则会出现排名泄露问题，经过多次迭代后，所有网页的PR值都趋向于0</p><blockquote><p>可以这样理解，就是说所有的权重为1，有一个网站会不断的吸取权重，使得系统中的权重不断减少，经过多次迭代系统内部的权重被吸收完了。</p></blockquote><p><strong>排名下沉</strong><br>若网页没有入度链接，经过多次迭代，其PR值会趋向于0</p><p><strong>排名上升</strong><br>互联网中一个网页只有对自己的出链，或者几个网页的出链形成了一个循环圈。那么在不断迭代过程中，这一个或几个网页的PR值将只增不减</p><h2 id="第二章-互联网情境下的智能学习">第二章 互联网情境下的智能学习</h2><h3 id="过拟合-Overfitting">过拟合 Overfitting</h3><p><strong>根本原因：</strong> 参数过多<br><strong>实际原因：</strong></p><ul><li>训练集和测试集分布不一致</li><li>模型太过复杂而样本量不足</li></ul><p><strong>解决策略：</strong><br>增大数据规模，简化模型，交叉检验，增大正则化系数$\lambda$</p><h3 id="Bias-VS-Variance">Bias VS Variance</h3><p>Bias代表偏差，高Bias代表与真实值偏离大，对应着欠拟合</p><p>Variance代表方差，高Variance代表数据波动大，对应过拟合</p><p><img src="https://img-blog.csdnimg.cn/20210626154804445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="正则化">正则化</h3><p><strong>概念</strong><br>简单的来说，正则化是一种为了减小<strong>测试误差</strong>的行为（有时候会增加<strong>训练误差</strong>）<br><strong>常用方法</strong></p><ol><li>L1&amp;L2范数正则化<br>在目标函数后面添加一个惩罚项，之后的目标函数为<br><img src="https://img-blog.csdnimg.cn/20210626165721277.png" alt="1.png"><br>$\lambda$是超参数，用于控制正则化程度，L1或L2正则化时，惩罚项对应为L1/L2范数</li><li>Dropout<br>直接在网络层里加一个dropout层，随机丢弃神经网络参数</li><li>earlystopping<br>提前终止可能是最简单的正则化方法，他适用于模型的表达能力很强的时候。一般情况下，一般训练误差会随着训练次数的增多逐渐下降，而测试误差则会先下降而后再次上升。我们需要做的就是在测试误差最低的点停止训练即可。</li></ol><h3 id="范数">范数</h3><p><strong>定义</strong><br>在线性代数中，泛函分析等数学分支中，范数（Norm）是一个函数，其赋予了某个向量空间（或矩阵）中的每个向量以长度或大小，向量$x=[x_1,x_2,…,x_n]$,向量的长度，或者向量到零点的距离，或者相应的两个点之间的距离。对于零向量，另其长度为零。<br><strong>性质</strong><br>满足非负性$||x||\leq 0|，齐次性||CX||=|C|||X||，三角不等式$||x+y||\leq ||x||+||y||$<br><strong>分类</strong><br><strong>$L_0范数$</strong> ||x||为x向量中所有非零元素的个数<br>实现稀疏的模式表示，如果我们用$L_0$范数来求min，规则化一个参数矩阵W，就是使W的大部分元素都是0.（特征简单）</p><p>稀疏的意义：</p><p>实现特征的自动选择：去掉这些没有信息的特征，也就是把这些特征对应的权重置为0</p><p>模型更容易解释：例如患某种病的概率是y，收集到的数据x是1000维的，也 就是我们需要寻找这1000种因素到底是怎么影响患上这种病的概率的。假设 我们这个是个回归模型： y=w1 *x1+w2 *x2+…+w1000 <em>x1000+b 如果最后学习到 的w</em>就只有很少的非零元素，例如只有5个非零的$w_i$，那么我们就有理由相信， 这些对应的特征在患病分析上面提供的信息是巨大的，决策性的。</p><p><strong>L1范数</strong>：||x||为x向量各个元素绝对值之和</p><p>也叫“稀疏规则算子”，同样是使得W中的大部分元素都为0 ， 在一定条件下，L1范数和L0范数可以等价 ，L1范数和L0范数可以实现稀疏， L1因具有比L0更好的优化求解特性而被广泛应用；</p><p>在Wi=0的地方不可微，并且可以分解为一个“求和”的形式，它是L0范数的最 优凸近似，比L0范数要容易优化求解求min（有一些计算机解法）；</p><p><strong>L2范数</strong>||x||为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数 或者Frobenius范数</p><p>“岭回归”（Ridge Regression），也叫做“权值衰减weight decay”。将L2范数的规则项||W||2最小化，可以使得W的每个元素都很小，都接近于0 ，但与L1范数不同，它不会让它等于0，而是接近于0。</p><p>我们可以实现对模型空间的限制，从而在一定程度上避免了 过拟合</p><p><strong>Lp范数</strong>：||x||为x向量各个元素绝对值p次方和的1/p次方</p><p><strong>L∞范数</strong>：||x||为x向量各个元素绝对值最大那个元素的绝对值</p><h3 id="距离度量">距离度量</h3><p><strong>闵可夫斯基距离：</strong><br>闵氏距离不是一种距离，而是一组距离的定义，对应$L_p$范数，p为参数。</p><p><img src="https://img-blog.csdnimg.cn/20210626160819342.png" alt="1.png"></p><p><strong>典型的闵可夫斯基距离：</strong></p><ul><li>p=1时，即为曼哈顿距离</li><li>p=2时，就是欧几里得距离（欧式）距离</li><li>当$p \to$∞时，就是切比雪夫距离</li></ul><p><strong>损失函数</strong><br>铰链损失（Hinge Loss）：主要用于支持向量机（SVM） 中；</p><p>互熵损失 （Cross Entropy Loss，Softmax Loss ）：用于Logistic 回归与 Softmax 分类中；</p><p>平方损失（Square Loss）：主要是最小二乘法（OLS）中；</p><p>指数损失（Exponential Loss） ：主要用于Adaboost 集成学习算法中；</p><p>其他损失（如0-1损失，绝对值损失）</p><h3 id="时间复杂度">时间复杂度</h3><p><img src="https://img-blog.csdnimg.cn/20210626163143251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><strong>计算步骤</strong></p><ol><li>找出算法中重复执行次数最多的语句的频率来估计时间复杂度</li><li>保留算法的最高次幂，忽略所有低次幂和高次幂的系数</li><li>将算法实行次数的数量级放入大O记号中</li></ol><p><img src="https://img-blog.csdnimg.cn/20210626164812545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h2 id="互联网情景下的智能决策">互联网情景下的智能决策</h2><h3 id="四大基本智能体">四大基本智能体</h3><ol><li><p>简单反射智能体Simple Reflex Agent：<br><img src="https://img-blog.csdnimg.cn/20210628130410367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p></li><li><p>基于模型的反射智能体Model-based Reflex Agent：<br>相当于在action由一个网络模型（神经网络或其他网络模型应该都算）计算得到<br><img src="https://img-blog.csdnimg.cn/20210628130735828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p></li><li><p>基于目标的反射智能体 Goal-based agents：<br><img src="https://img-blog.csdnimg.cn/20210628130836443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p></li><li><p>基于用途的反射智能体Utility-based agents:<br>现在用的最多的智能个体框架</p></li></ol><p>个人理解可能相当于不止考虑当前action的V值，还考虑未来的V值，也就是以当前action的Q值为标准。<br><img src="https://img-blog.csdnimg.cn/20210628131018337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="强化学习框架">强化学习框架</h3><p><img src="https://img-blog.csdnimg.cn/20210628131341652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="博弈">博弈</h3><p>多智能体之间交互，互相学习训练的过程</p><p><img src="https://img-blog.csdnimg.cn/2021062813165051.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="机器学习定义">机器学习定义</h3><p>基本定义：</p><p>通过统计学的学习方法，使模型从大量数据中找到规律，从而得到预测未来的能力</p><p>白话定义：<br>举一反三，通过对大量样本的学习总结出规律，再次利用规律对从未见过的样本进行分析，判断并得出结论</p><h3 id="三大机器学习">三大机器学习</h3><ol><li>监督学习：<strong>预测分类</strong></li></ol><p>从<strong>有标签</strong>的训练数据中学习模型，以便对未知或者未来的数据做出预测</p><p>应用：自然语言处理，计算机视觉</p><ol start="2"><li><p>非监督学习：<strong>聚类</strong><br>从<strong>没有标签</strong>的训练数据中学习判断，寻找相似点进行聚类</p></li><li><p>强化学习：<strong>行为决策</strong><br>根据环境数据<strong>选择行为</strong>以最大化预期长期收益</p></li></ol><p>强化学习框架可以融合其他学习的方法但其他学习无法刻画强化学习</p><p>应用：智能机器人，游戏AI， Alpha Go</p><h3 id="强化学习的主要元素">强化学习的主要元素</h3><p>历史（History）：一连串的observation、action和reward</p><p>状态（state）：是历史（History）的函数，用来决定即将发生的情况</p><p>策略（Policy）：环境感知到动作的映射action = f ( state )</p><p>受益（Reward）：定义强化学习中智能个体的目标</p><p>状态估值（State Value）：一个状态的估值就是从这个状态开始，按照某一策略，智能个体期望在未来获得的奖赏</p><p>环境模型（Model of Environment）：刻画环境的演变</p><h3 id="强化学习应用">强化学习应用</h3><ol><li><p>各类游戏：Alpha Go、OpenAI Five</p></li><li><p>资源调度：带宽资源、功率资源</p></li><li><p>自动控制：交通信号灯、无人驾驶</p></li><li><p>推荐排序：个性化、网页排序</p></li></ol><h3 id="Discount">Discount</h3><p>折扣因子关注智能体在过去，现在和未来获得的rewards，也就是说它将奖励和时域联系起来。简单来说，就是对不同时期的reward加权</p><p>discount的值在[0, 1],若discount=0，那么智能体仅关注过去获得的第一个reward，若等于1，则关注未来获得所有的奖励，0，1之间的就介于值之间，自己理解</p><p>使用衰减因子的最终回报函数<br><img src="https://img-blog.csdnimg.cn/20210628150937843.png" alt="1.png"></p><p>通俗解释：不同时期的reward重要程度不一样，discount小于1时，越后期的reward加权值越小，重要程度越小</p><p>在大多数马尔可夫奖励和决策中都是使用了discount，原因是什么呢？</p><ul><li>数学上方便对奖励discount</li><li>避免循环马尔可夫过程中的无限汇报</li><li>未来的不确定性可能无法完全体现</li><li>如果奖励是财务奖励，即时奖励可能比延迟奖励赚取更多的利息</li><li>动物/人类行为表现出对即时奖励的偏好</li><li>有时可以使用未贴现的马尔可夫奖励过程（即discount=1），例如：如果所有序列都终止</li></ul><h3 id="Reward-VS-Value">Reward VS Value</h3><p>简单的来说，reward是当前收益（即时利益），value是长远收益</p><blockquote><p>• Whlie the reward signWal indicates what is good in an immediate sense, a value function     specifiWes what is good in the long run .<br>• Whlie rewards determine the immediate, intrinsic desirability of  environmental states,     values indicate the long-term desirability of states after taking into account the states that    are likely to follow and the rewards available in those states .<br>• Rewards are in a sense primary, whereas values, as predictions of rewards, are   secondary …<br>• We seek actions that bring about states of highest value, not highest reward, because   these actions obtain the greatest amount of reward for us over the  long run.<br>• Rewards are basically given directly by the environment, but values must be estimated   and re-estimated from the sequences of observations an agent makes over its entire   lifetime<br>• A state might always yield a low immediate reward but still have a high value because it is   regularly followed by other states that yield high rewards. Or the reverse could be true<br>• It is much harder to determine values than it is to determine rewards</p></blockquote><ul><li>虽然reward signal 表明什么是<strong>即时</strong>意义的好，但value function指定了从<strong>长远</strong>来看什么是好的</li><li>虽然reward决定了环境状态的直接，内在可取性，但在考虑了可能遵循的这些状态和这些状态中可用奖励后，values表明了状态的长期可取性</li><li>从某种意义上说，reward是主要的，而作为对reward的预测，value是次要的</li><li>我们寻求带来<strong>最高value状态而非最高reward</strong>的行动，因为从长远来看，这些行动会为我们带来最大的reward</li><li>一个状态可能总是产生<strong>较低的即时奖励，但仍然具有很高的价值</strong>，因为它经常被其他产生高奖励的状态跟随，反之亦然。</li><li>确定value比确定reward要困难得多</li></ul><h3 id="Exploit-VS-Explore">Exploit VS Explore</h3><p>探索常用即贪婪搜索，即完全随机选择动作，以寻找到更多可能的情况<br><img src="https://img-blog.csdnimg.cn/20210628144759700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><img src="https://img-blog.csdnimg.cn/20210628144947936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="马尔科夫过程MP">马尔科夫过程MP</h3><p><strong>定义：</strong><br>马尔可夫过程是一个二元组（S，P），且满足：S是有限状态集合，P是状态转移概率：<br><img src="https://img-blog.csdnimg.cn/20200303103916957.png" alt="1.png"><br>马尔科夫过程也称为马尔科夫链：由一些具有马尔科夫性的量随机组成的记忆链，这些量之间有转移概率，如具有马尔科夫性质的stat可以组成马尔科夫链<br><strong>状态转移矩阵：</strong><br>描述当前状态转移到可达的多个状态的概率值（一行），行和都为1<br><img src="https://img-blog.csdnimg.cn/20200303104120445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt="1.png"><br>实例：<br>在马尔科夫链中，假如学生在上class 1，那么结束class 1后有0.5的概率继续上class 2，也有0.5的概率会去刷facebook，那么class1对应行的值为【0，0.5， 0， 0， 0， 0.5， 0】<br><img src="https://img-blog.csdnimg.cn/20200303104447841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><img src="https://img-blog.csdnimg.cn/20200303105149956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt="1.png"></p><p>求得完整的马尔可夫状态转移矩阵</p><h3 id="马尔科夫奖励过程MRP">马尔科夫奖励过程MRP</h3><p>仅仅有上面的MP还不足以做出决策，RL本质上是一个基于reward的过程，我们需要引入reward，在马尔可夫链中可以表示为下图所示效果，比如进入Facebook状态时reward=-1</p><p><img src="https://img-blog.csdnimg.cn/20210628151509755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>MRP值函数：</strong><br>在一个episode中，我们每完成一个状态就给一个奖励，回合结束时将奖励累积起来就是最终的回报(return)，在这也就是MRP值函数，定义如下，其中r是衰减discount，不明白的可以看上面介绍Discount部分。<br><img src="https://img-blog.csdnimg.cn/20200303105727741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>计算MRP值函数（设衰减r=0.5）：</strong><br>C1 C2 C3 Pass Sleep：  $v = -2 - 2 * 0.5 - 2 * 0.5 ^2 +10 * 0.5^3 + 0 * 0.5^4 = -2.25$</p><p>C1 FB FB C1 C2 Sleep:   $v = -2 - 1 * 0.5 - 1 * 0.5 ^2 - 2 * 0.5^3 - 2*0.5^4 + 0 * 0.5^4 = -3.125$</p><blockquote><p>就是将该路径上的权值采用上图的方法来进行处理</p></blockquote><h3 id="贝尔曼方程Bellman-Equation">贝尔曼方程Bellman Equation</h3><p>从上面的计算可以看出不同情况下，每个状态的v值时不同的，而我们value function计算的是期望值，此时就需要贝尔曼方程来计算每个状态的value期望值，</p><p>即当前状态的value值 = 当前状态的奖励R + 衰减 * 下一步各状态的v值 * 转移概率</p><p><img src="https://img-blog.csdnimg.cn/20210628153124305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p>举个例子：</p><p>下图中C3下一步可选状态有两个，其v值分别为10和0.8，设衰减为1</p><p>$4.3 = - 2 + 1 *（ 0.6 *10 +0.4 *0.8） $</p><p><img src="https://img-blog.csdnimg.cn/20200303112603372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""></p><p>如果把r设为0.9：</p><p>$4.1 = - 2 + 0. 9 *（ 0.6 * 10 +0.4 *1.9 ）$</p><p><img src="https://img-blog.csdnimg.cn/20210628153928184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p>此时会产生一个问题，这里的10 和 1.9是哪来的呢?我们需要从终止状态Sleep算起，终止状态Sleep的V值就等于他的R值，一步步反向推到，或者是建方程组求解所有的V值，具体计算过程这里不讨论（主要是考试不考），上面的计算其实就只是验证了一下计算的正确性。</p><h3 id="马尔科夫决策过程MDP">马尔科夫决策过程MDP</h3><p>有了MP和MRP，要完成RL的决策目标就需要最后加入一个action形成一个完整的决策过程<br><strong>MDP值函数：</strong><br>主要分为状态-值函数（v值）和动作-值函数（q值），一个基于状态，一个基于动作和状态，如下：<br><img src="https://img-blog.csdnimg.cn/20200303130209971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200303130209971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""><br>q值与v值的关系如下：<br><img src="https://img-blog.csdnimg.cn/20200303131350591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""><br><strong>也就是说，v值是采取不同动作产生q值概率加权而来的</strong><br><strong>q值公式：</strong><br><img src="https://img-blog.csdnimg.cn/20210628171858154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>如果采取某一动作后只进入一个状态，那q值其实就等于采取动作的R值+下一状态v值*衰减即：</p><p>q = R +  rV，若r=1，那么q = R + v</p><p>简单来说就是q等于R加上下一状态的V值，如果采取动作可能进入多个状态，那就状态加个权</p><p>计算示例：</p><p>注意此图中的R值是采取动作的R值，不同于上面的进入某状态的R值，注意观察R的位置</p><p>在下图中，圆圈里的值代表每一个状态的V值，对于7.4的状态，下一步有两个动作选择，所以我们先来计算两个动作的q值，都记r=1</p><p>第一个动作选择Study进入终止状态，R=10，但是终止状态后没有后续选择，于是公式后半部分为0，此时q值就为R=10；</p><p>第二个动作选择Pub，R=-2，但执行次动作进入的状态不确定，可能还会进入三种状态，此时累加衰减<em>概率</em>下一步V值，最后加上R即为当前动作的q值</p><p>最后用两个q值乘上对于概率就求导了当前状态的v值7.4<br><img src="https://img-blog.csdnimg.cn/20210628172447366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>寻找最优策略</strong><br>一个简单的最优策略可以通过找到每步最大的q值得出，如下图</p><p>从左上开始，每步选择q值最大的动作，最终红线就是最优化策略</p><p><img src="https://img-blog.csdnimg.cn/20200303143859306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="贝尔曼最优等式">贝尔曼最优等式</h3><p><img src="https://img-blog.csdnimg.cn/20210628184445289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>需要注意的是贝尔曼最优等式是非线性的，因此没有一个通解，常用的解决方法如下：<br><img src="https://img-blog.csdnimg.cn/20210628184523792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="互联网情景下的智能交互">互联网情景下的智能交互</h2><h3 id="公开竞价拍卖">公开竞价拍卖</h3><p><strong>升价拍卖</strong><br>英式拍卖，加价获胜者支付自己的最终出价<br><strong>降价拍卖</strong><br>荷兰式拍卖，价格一直降低，直到有人接受</p><h3 id="密封出价拍卖">密封出价拍卖</h3><p><strong>一价拍卖</strong><br>出价最高者得，支付最高价格<br><strong>二价拍卖</strong><br>出价最高者得，支付第二高得价格</p><h3 id="HA匹配问题">HA匹配问题</h3><h4 id="定义">定义</h4><p>这是一个具有<strong>单边偏好</strong>的<strong>多一、二部</strong>匹配问题，存在单边偏好（或者我们主要关心一方的偏好）</p><ul><li>学生在校园里挑选住房</li><li>学生选择新生研讨会</li></ul><p>HA的一个实例包括</p><ul><li>一个申请人的集合 $$A = {a_1,a_2,…,a_{n1}} $$</li><li>一个房子集合 $$H= {h_1,h_2,…  ,h_{n2}} $$</li></ul><p>每个申请人对一套房子都有一定的偏好。</p><h4 id="最优匹配">最优匹配</h4><p>什么是“好”结果？</p><ul><li>帕累托最优匹配</li></ul><blockquote><p>直观地说，如果没有申请人能在不要求另一个申请人使自己过得更差，那么匹配是帕累托最优的</p></blockquote><ul><li>流行匹配</li><li>基于配置文件的最优匹配</li></ul><h4 id="帕累托最优匹配">帕累托最优匹配</h4><p>求帕累托最优匹配的算法</p><ul><li>（随机）系列独裁机制(SDM)<ul><li>每个学生都有一个优先权（可能是在住房抽签中随机分配的）</li><li>学生们按他们的优先级的顺序选择房子</li></ul></li><li>处理申请人的顺序将会影响申请结果</li><li>所得到的帕累托最优匹配是不同的大小的</li><li>定理:连续独裁是有效的（即之后没有相互同意的交易）和战略证明的。</li></ul><h4 id="证明-2">证明</h4><p>策略证明</p><ul><li>有第一选择的人会得到她最喜欢的房子，所以显然没有撒谎的动机</li><li>有第二选择的人在剩下的房子中得到她喜欢的房子，所以同样没有理由撒谎。</li><li>等等<br>效率</li><li>有优先权的个人并不想进行交易。</li><li>考虑到她出局了，有第二优先级的人不想交易</li><li>等等…。<br><img src="https://cdn.acwing.com/media/article/image/2022/05/27/99310_5b1a0368dd-1.png" alt="1.png"></li></ul><h4 id="变体">变体</h4><p>初始捐赠</p><ul><li>在每个申请人最初拥有一件商品的情况下，这被称为房屋市场(HM)问题</li><li>亚伯拉罕给出了一个个体理性的算法，它确保每个最初拥有一个房子的申请人最终都拥有相同或更好的房子。</li><li>缩短申请人的优先名单，取消所有比最初捐赠更好的房屋。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 计算智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计量经济学复习</title>
      <link href="/2022/05/20/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/20/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-回归分析概述">第一章 回归分析概述</h2><p><strong>计量经济学研究路线</strong></p><ul><li><strong>建立</strong>理论模型</li><li><strong>确立</strong>计量经济学模型</li><li><strong>搜集</strong>检查并整理<code>数据</code></li><li><strong>估计</strong>计量经济学模型</li><li><strong>评价</strong>计量经济学模型</li><li><strong>应用</strong>计量经济学模型</li></ul><p><strong>回归分析的现代含义</strong></p><blockquote><p>回归分析是关于研究一个叫做因变量的变量（Y）对另一个或多个叫做自变量的变量（X）的依赖关系</p></blockquote><blockquote><p>其用意在于通过自变量在重复抽样中的已知或设定值，去估计或预测因变量的总体均值</p></blockquote><p>确定关系：确定变量之间的函数关系</p><p>统计关系：随机变量之间的依赖关系</p><p><code>计量经济学关注的是统计关系</code></p><p><strong>线性的含义</strong><br>有两种线性，变量线性和参数线性</p><p>线性回归是指对估计参数为线性的一种回归（即估计参数只以一次方出现），对自变量X则可以是或不是线性的</p><p>判断下列方程是不是线性回归？</p><p>$E(Y|X_i)=\beta_0+\beta_1^2 X_i$ 不是线性回归<br>$E(Y|X_i)=\beta_0+\beta_1 X_1 X_2$ 是线性回归</p><p>随机干扰项 $\varepsilon_i=Y_i-E(Y_i|X_i)$</p><p>残差 $\hat{\varepsilon_i}=e_i=Y_i-\hat{Y_i}$</p><h3 id="小结">小结</h3><ol><li>计量经济学，从字面意思来上讲，叫&quot;经济度量&quot;，属于经济学的一个分支学科，主要致力于量化理论关系。回归分析虽然仅仅是计量经济学分析方法的一种，确实目前最常用的一种方法。</li><li>计量经济学最主要的用途为：描述经济关系、假设检验和预测。根据研究的需要，特定的计量经济学方法会有所不同。</li><li>尽管回归分析设定被解释变量是一个或者多个解释变量的函数，但回归分析本身并不能证明或隐含因果关系。</li><li>回归方程中必须加入随机误差项，用于度量被解释变量没有完全被解释变量解释而形成的误差。随机误差项的组成部分有：①遗漏或者省略变量；② 数据的测量误差；③隐含理论的函数形式与回归方程不同； ④纯随机误差或不可预知的事件。</li><li>估计出的回归方程式真实回归方程的近似代替，是从包含X和Y的样本数据中计算出来的。由于真实回归方程不可知，所以，计量经济分析注重的是估计出的回归方程和回归参数的参数估计值。被解释的变量的特定观测值与其估计值之差成为残差。</li></ol><h3 id="例题-4">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d2511414d9-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d4572aacd9-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d6c6d98ed9-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d81d9d6ed9-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_db0f4b34d9-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_dcccbbc2d9-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_0d33f34ed9-7.png" alt="7.png"></p><h2 id="第二章-最小二乘法">第二章 最小二乘法</h2><p><strong>偏回归系数</strong>：当其他变量相同（保持其他变量不变）时，特定变量对被解释变量的边际影响（贡献）</p><p>n为样本量，k为待估计参数数量，通常情况下$n \geq 5*k$</p><p>最小二乘法估计量$ \hat{\beta} $是确定性变量还是随机变量？为什么？</p><p>$\hat{\beta}$是由Y计算来的，Y是一个随机变量，随机性来自随机干扰项 $\varepsilon$,$\varepsilon$影响Y，Y影响$\hat{\beta}$，所以$\hat{\beta}$是一个随机变量，同时如果Y服从<strong>正态分布</strong>，那么$ \hat{\beta} $也服从<strong>正态分布</strong></p><p>判断估计量优劣的标准是什么？</p><ul><li>估计值的均值是否等于真实值：无偏性</li><li>估计量的方差是否足够小：有效性</li><li>估计量的极限是否趋于真实值：一致性</li></ul><p><strong>控制变量的选择</strong><br>去什么，加什么，因为我们的被解释变量受到多个因素的影响，仅仅用一元线性回归是不够的，以餐厅收入案例为例，虽然我们关心的是居民收入对于餐厅收入的影响，但我们考虑到竞争对手的数量还有人口密度等等会影响餐厅收入，如果不把这两个影响因素去掉，可能得不到真实的回归结果，为了去除这两个因素的影响，我们要把这两个变量加入道方程中去。</p><p><strong>古典假设</strong>：</p><ol><li>回归模型是线性的，模型设定无误且含有误差项。</li><li>误差项的总体均值为0。</li><li>所有解释变量与误差项都不相关</li><li>误差项观测值互不相关（不存在序列相关性）</li><li>误差项具有同方差（不存在异方差性）</li><li>任何一个解释变量都不是其他解释变量的完全线性函数（不存在多重共线性）</li><li>误差项服从正态分布（该假设是选择性的，但通常被采用）</li></ol><p><strong>古典假设小结</strong></p><ol><li>7个古典假设表述为：回归模型是线性的且含有一个均值为0且与解释变量不相关的误差项；各误差项观测值之间不想管；误差项观测值之间互补相关；误差项的方差相同，服从正态分布（不要求）；另外，解释变量之间一定不能相互存在完全的线性函数关系。</li><li>估计量的两个最重要的性质是无偏性和最小方差性。无偏估计量是指被估计参数的期望与真实值相等的估计量。在给定的一类估计量中（例如无偏估计量），茹估计值分布的方差在所有估计量中最小时，则满足最小方差性。</li><li>在古典假设下，普通最小二乘估计量被证明具有最小方差性，线性，无偏性（或称BLUE，即最优线性无偏估计量），即高斯——马尔科夫定理。当一个或多个古典假设不成立时（正态分布假设除外），在某些时候，尽管普通最小二乘法仍然能够提供比随后章节中所讨论的其他可供选择估计的方法得到的更好的估计量，但普通最小二乘估计量不再是BLUE的。</li><li>因为$\hat{\beta_k}$的普通最小二乘估计量的抽样分布是BLUE的，所以$\hat{\beta_k}$具有令人满意的性质。另外，随着被观测样本数量的增加，$\hat{\beta_k}$的抽样分布中的方差（或离散程度）减小。</li><li>计量经济学中有一套标准的记述符号，如下表所示</li></ol><table><thead><tr><th style="text-align:center">总体参数</th><th style="text-align:center">（真实值，但不能观测）</th></tr></thead><tbody><tr><td style="text-align:center">回归参数</td><td style="text-align:center">$\beta_k$</td></tr><tr><td style="text-align:center">参数估计量的期望</td><td style="text-align:center">$E(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">误差项的方差</td><td style="text-align:center">$\sigma^2 或 VAR(\varepsilon_i)$</td></tr><tr><td style="text-align:center">误差项标准差</td><td style="text-align:center">$\sigma$</td></tr><tr><td style="text-align:center">参数估计量的方差</td><td style="text-align:center">$\sigma^2(\hat{\beta_k})$ 或 $VAR(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">参数估计量的标准差</td><td style="text-align:center">$\sigma_{\hat{\beta_k}}$ 或 $\sigma(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">误差项或随机干扰项</td><td style="text-align:center">$\varepsilon_i$</td></tr></tbody></table><table><thead><tr><th style="text-align:center">估计值</th><th style="text-align:center">（由样本观测得到）</th></tr></thead><tbody><tr><td style="text-align:center">回归参数估计值</td><td style="text-align:center">$\hat{\beta_k}$</td></tr><tr><td style="text-align:center">误差项的方差的估计值</td><td style="text-align:center">$s^2 或 VAR(\sigma^2)$</td></tr><tr><td style="text-align:center">误差项标准差的估计值</td><td style="text-align:center">$s$ 或 $SE$</td></tr><tr><td style="text-align:center">参数估计量的方差估计值</td><td style="text-align:center">$s^2(\hat{\beta_k})$ 或 $\widehat{VAR}(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">参数估计量的标准差估计值</td><td style="text-align:center">$\hat{\sigma_{\hat{\beta_k}}}$ 或 $SE(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">残差项</td><td style="text-align:center">$e_i$</td></tr></tbody></table><p><strong>拟合优度</strong><br>OLS估计量是BLUE（最小方差性[有效性]，线性，无偏性），但采用OLS不一定能够得到满意的结果</p><p>从几何意义上说，拟合优度是指样本回归线对样本数据拟合得多好</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_31504084da-9.png" alt="9.png"></p><p><strong>判定系数$(R^2)$</strong><br>$$R^2=\frac{回归平方和}{总平方和}=\frac{ESS}{TSS}=1-\frac{RSS}{TSS} &lt; 1$$</p><p>一般来说，$(R^2)$的值越接近1，表明拟合优度越好；相反，越接近0，意味着回归估计方程不能比样本均值$\bar{Y}$更好的解释$Y_i$的值</p><p>判定系数$(R^2)$是解释变量个数的非减函数，即增加解释变量，$(R^2)$会增加或不变</p><p>$(R^2)$不是越大模型越好</p><ul><li>增加无关的解释变量，使模型失去经济含义</li><li>降低<code>自由度</code>，降低参数估计量的可靠性</li></ul><blockquote><p>自由度：观测样本数    减去待估参数的个数</p></blockquote><p><strong>调整的判定系数</strong></p><blockquote><p>对参数（包括截距项）的个数k进行惩罚，在模型拟合优度（好）与其复杂性（不好）之间进行权衡</p></blockquote><p>$$\bar{R^2}=1-\frac{\sum e_i^2/(n-k)}{\sum y_i^2/(n-1)}=1-(1-R^2)\frac{n-1}{n-k}$$</p><blockquote><p>当模型中新增解释变量时，$\bar{R^2}$变化的方向（上升、下降或者不变）依赖于新变量对回归拟合的贡献是否超过对损失一个额外自由度所作修正的补偿</p></blockquote><ul><li>拟合优度仅是衡量回归总体质量的指标之一</li><li>参数估计值符合经济理论的程度、研究者对参数预期比拟合优度更加重要</li></ul><h3 id="小结-2">小结</h3><ol><li>普通最小二乘法是利用一组数据求的回归参数估计值的最常用的方法。普通最小二乘法使得一个特定样本的残差平方和（$\sum e_   i^2$）最小。</li><li>调整的判定系数$\bar{R^2}$是经过自由度调整后的判定系数，他衡量了Y与他的均值被特定回归方程解释的比例。方程中新增加一个变量时，只有拟合有毒提高的程度超过了自由度下降的损失，调整的判定系数$\bar{R^2}$才会更大，所以，多数研究者在评价回归方程的拟合优度时，都自然地使用调整地判定系数$\bar{R^2}$</li><li>切记，估计方程地拟合有毒只是一个衡量回归整体质量地指标之一。许多其他的标准，包括参数估计值与经济理论地一致性，以及与预期（研究者在搜集数据前做出地预期）的一致性，都比调整的判定系数$\bar{R^2}$更重要。</li></ol><h3 id="例题-5">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_bce57b9cda-11.png" alt="11.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c0eb49a7da-12.png" alt="12.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c375484ada-13.png" alt="13.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c5b58d86da-14.png" alt="14.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_003ac9f1da-18.png" alt="18.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c8449c40da-15.png" alt="15.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_ca7936cbda-16.png" alt="16.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_ce0d5917da-17.png" alt="17.png"></p><h2 id="第三章-假设检验">第三章 假设检验</h2><h3 id="假设检验的基本原理">假设检验的基本原理</h3><p>我们用样本的信息来检验总体的信息</p><p><strong>假设检验</strong>：先对总体的特征作出某种假设，然后通过<strong>抽样研究的统计推理</strong>，对此假设应该拒绝还是被接受做出推断</p><p>基本思想：<strong>小概率原理、反证法</strong></p><p>原假设（$H_0$） 备择假设($H_A$)</p><p>因为拒绝假设比较简单，我们只需要举出一个反例，而接受一个假设相对比较困难，因为我们可能需要穷举所有的情况</p><p>因此我们就可以根据研究者预期来设计假设，我们将希望出现的结果作为备择假设，将不希望出现的结果作为原假设</p><p>如果回归分析希望出现一个正的参数$\beta$,原假设和备择假设应该为：<br>$$H_0:\beta \leq 0; H_A: \beta &gt; 0$$</p><blockquote><p>单侧检验：具有明显的预期</p></blockquote><p>如果回归分析希望参数$\beta$不为零，原假设和备择假设应该设为：<br>$$H_0: \beta = 0; H_A: \beta \ne 0$$</p><blockquote><p>双侧检验： 预期不确定</p></blockquote><p>假设检验是要确定一个标准（判定准则），以便决定<strong>拒绝</strong>或<strong>不拒绝</strong>某个原假设$H_0$</p><p>当拒绝原假设时，通常表述为<strong>统计上显著</strong>;反之，<strong>统计上不显著</strong></p><p><strong>两类错误</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$H_0$为真</th><th style="text-align:center">$H_0$不为真</th></tr></thead><tbody><tr><td style="text-align:center">拒绝$H_0$</td><td style="text-align:center">第一类错误（弃真）</td><td style="text-align:center">正确</td></tr><tr><td style="text-align:center">不拒绝$H_0$</td><td style="text-align:center">正确</td><td style="text-align:center">第二类错误（纳伪）</td></tr></tbody></table><p>犯第一类错误的概率：$P(H_A|H_0)=\alpha$</p><p>犯第二类错误的概率：$P(H_0|H_A)=\beta$</p><blockquote><p>$\alpha$ 越大 $\beta$越小,我们主要关注第一类错误出现的概率$\alpha$</p></blockquote><p><strong>假设检验的判定准则</strong></p><ul><li>判定准则是比较样本统计量与预先设定的临界值之间的大小</li><li>参数估计值范围分为两个区域：<strong>拒绝域</strong>和“<strong>接受域</strong>”</li></ul><h3 id="假设检验的方法">假设检验的方法</h3><p><strong>置信区间法</strong><br>根据参数估计量的分布，在给定的<strong>置信水平</strong>（如95%）下，构造一个随机<strong>置信区间</strong>；若该随机区间覆盖原假设值，则不拒绝原假设，否则拒绝原假设<br><strong>置信区间的构造</strong><br>首先设定<strong>显著性水平</strong>（第一类错误的概率）$\alpha$,然后确定一个正数 $\delta$,使得随机区间$(\hat{\beta}- \delta, \hat{\beta}+ \delta)$包括参数真实值$\beta$的概率为$1-\alpha$(置信水平)<br>$$P(\hat{\beta}- \delta \leq \beta \leq \hat{\beta}+ \delta)=1-\alpha$$</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_969ce206da-20.png" alt="20.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_b46c86c6da-21.png" alt="21.png"></p><p><strong>显著性假设法</strong><br>显著性检验法直接比较参数估计值和原假设之间的差异大小。若&quot;差异&quot;  较大，则拒绝原假设；反之，不拒绝原假设</p><p><strong>怎样判断差异的大小</strong><br>判断$\hat{\beta}-\beta_0$是否显著异于0的关键在于构造一个函数f($\hat{\beta}-\beta_0$)(称为统计量),该统计量具有确定的分布规律；比较该统计量的值与分布临界值来判断差异是否显著</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_1bd35f12da-22.png" alt="22.png"></p><p>如果得到的P值小于我们要求的显著性水平（5%）的话，我们就拒绝原假设，反之，不拒绝。</p><h3 id="t检验-2">t检验</h3><p>检验单个变量对被解释变量是否由解释力</p><p>$$t=\frac{\hat{\beta}-\beta_0}{se(\hat{\beta})}$$</p><p><strong>单侧T检验的判定方法</strong></p><ul><li>根据<strong>t值</strong>判断，如果$|t_k|&gt;t_c$,<strong>并且</strong>$\beta_k$的符号与$H_A$隐含的符号相同（符合预期），则拒绝$H_0$</li><li>根据<strong>P值</strong>判断：如果P值小于研究所要求的显著性水平，且$\beta_k$的符号与$H_A$隐含的符号相同（符合预期），则拒绝$H_0$</li></ul><blockquote><p>计量经济学分析中，大多数情况采用单侧检验</p></blockquote><blockquote><p>采用双侧检验的情况：估计值得符号没有明确得预期或者是否显著性于某个特定的值</p></blockquote><p><strong>永远牢记：不要把t检验得出的统计显著性等同于理论的有效性</strong></p><p>在回归分析中，t检验不能检验相应变量的相对“重要性”，检验数字特征要用到统计检验，后面会提到<br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_e82d7ec7da-23.png" alt="23.png"></p><p><strong>t检验的陷阱</strong>：随着样本容量的增大，t值会越来越大的原因在于：标准误会随着样本数量增加而减小，标准误越小t统计量就会越大</p><p>对于一个超大规模的样本而言，t检验没有任何意义，因为你几乎可以拒绝任何原假设</p><p>综上所述，<strong>t检验的局限性</strong></p><ul><li>t检验不能检验理论有效性</li><li>t检验不能检验“重要性”</li><li>t检验不是针对总体的检验</li></ul><h3 id="F检验-2">F检验</h3><p>$$F=\frac{(RSS_R-RSS_{UR})/J}{RSS_{UR}/(n-k)}$$<br>其中J为约束条件个数，K为估计的参数个数（包括$\beta_0$）</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_3cc9369fda-24.png" alt="24.png"></p><p>对多个假设的联合检验<strong>或</strong>对线性约束的假设检验不能用t检验，只能用<strong>F检验</strong></p><p><strong>一种检验思路</strong></p><ul><li>将线性约束（原假设）代入线性回归方程，可得<strong>约束最小二乘估计量</strong></li><li>约束最小二乘的拟合将劣于无约束最小二乘的拟合，即<strong>约束导致拟合的损失</strong></li><li>约束最小二乘的RSS将大于无约束最小二乘的RSS，可据此构建统计量</li></ul><p><strong>检验回归模型的总体显著性</strong><br>RSS为残差平方和<br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_b0de6097da-25.png" alt="25.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_e20bbb72da-26.png" alt="26.png"><br><strong>检验某个偏回归系数等于某个特定值</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_5819e71dda-1.png" alt="1.png"></p><p><strong>检验规模报酬不变</strong></p><p><strong>邹检验</strong><br>结构变化：时间序列回归中，模型的参数在整个样本期间内可能发生变化</p><ul><li>邹检验的假定：两个子时期回归的误差项是独立且具有同方差的正态分布变量</li><li>邹检验只告诉我们不同时期的回归方程是否有差别，并没有告诉我们差别来自截距，斜率还是二者兼有</li><li>邹检验假定我们知道结构转折点</li></ul><h3 id="正态性检验">正态性检验</h3><p>采用JB检验（雅克-贝拉检验）</p><h3 id="小结-3">小结</h3><ol><li>通常，确定被解释变量后，应用回归分析采用六个步骤：<br>a. 查阅文献，建立理论模型<br>b. 确定模型：选择解释变量及函数形式<br>c. 对参数的符号做出假设<br>d. 搜集、检查和整理数据<br>e. 估计和评价方程<br>f. 报告结果</li><li>虚拟变量只能取值0或1，这取决与是否满足某些特定状态条件。虚拟变量的例子就是当为女性时X等于1，为男性时X等于0</li></ol><h3 id="例题-6">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_66fb7a8fda-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_5ddb70aeda-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6980e992da-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6a8abdefda-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6cefa212da-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6ffd8581da-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_7286f40eda-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_754d6c6eda-8.png" alt="8.png"></p><h2 id="第四章-模型设定">第四章 模型设定</h2><p><strong>正确的方程</strong></p><ul><li>正确的解释变量</li><li>正确的函数形式</li><li>正确的随机误差项</li></ul><p><strong>如何正确的选择解释变量</strong></p><ul><li>最重要的选择依据：（经济理论判断）</li><li>若理论上不明确，则可采用统计方法来判断<ul><li>遗漏变量</li><li>不相干变量</li></ul></li></ul><p><strong>遗漏变量的后果</strong></p><blockquote><p>设定偏误：参数估计量<strong>有偏</strong>且非一致，方差变小</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_05ed6799da-9.png" alt="9.png"></p><p><strong>加入不相干变量的后果</strong></p><blockquote><p>参数估计量<strong>无偏</strong>但非有效（方差变大），t检验失效</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_7c5108f8da-10.png" alt="10.png"></p><p><strong>模型选择准则</strong></p><ul><li>判定系数<br>$$R^2=1-\frac{RSS}{TSS}$$<br>$$\bar{R^2}=1-\frac{\sum e_i^2/(n-k)}{\sum y_i^2/(n-1)}=1-(1-R^2)\frac{n-1}{n-k}$$</li><li>赤池信息准则（AIC）和施瓦茨信息准则（SC）<br>$AIC=\frac{2k}{n}+ln{\frac{RSS}{n}}$ 如果你加入一个新的解释变量那么AIC会增大 $\frac{2}{n}$<br>$SC=\frac{k}{n}lnn+ln{\frac{RSS}{n}}$ 如果加入一个新的解释变量那么SC会增大 $\frac{lnn}{n}$</li></ul><blockquote><p>AIC和SC准则对增加解释变量加大了惩罚，其中SC的惩罚比AIC更严厉。相对而言，AIC和SC的值越低的模型越好。</p></blockquote><p>看下面的例子，可以发现中间的AIC和SC值是最小的，该模型也确实更好<br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_ea8040c5da-1.png" alt="1.png"></p><p><strong>模型设定的四个重要准则</strong></p><ol><li>理论：变量在方程中的含义是不是模糊不清的，从理论上看是不是合理的？</li><li>t检验：变量的待估参数在预期假设下是否显著？</li></ol><blockquote><p>不能简单地将一个t值不显著的变量从方程中排除，要结合理论与实际</p></blockquote><ol start="3"><li>调整的判定系数$\bar{R^2}$或AIC和SC：在变量加入后，方程的整体拟合优度（自由度调整后）是否得到了改善</li><li>偏误：变量加入方程后，其他变量的参数值是否发生了显著性改变？</li></ol><p><strong>模型设定搜索</strong></p><ul><li>数据挖掘<ul><li>适当的数据挖掘也许有助于揭示经济学理论尚未说明的经验规律</li><li>不适当的数据挖掘，比什么都不做更坏：如果你对数据严刑拷打，它就会屈打成招</li></ul></li><li>敏感性分析：稳健性分析<ul><li>几乎所有学术论文的必备步骤和分析内容</li><li>稳健的含义：某种结果对于各种模型设定，变量定义，数据子集都是显著的（或不显著的）</li></ul></li></ul><h3 id="解释变量选择小结">解释变量选择小结</h3><ol><li>由于遗漏变量在某种程度上都与已包含变量之间有相关性，因此，遗漏变量会导致方程中剩余变量的参数估计值产生偏误。</li><li>由遗漏变量所引起的偏误等于遗漏变量的参数乘以已包含变量和未包含变量的简单相关系数的函数。</li><li>方程中包含一个真正的不相关变量并不会因此偏误，但会增加已包含变量参数估计值的方差，因此会使t统计量和调整的判定系数$\bar{R^2}$都降低。</li><li>方程中包含一个变量的四个有用准则：<br>a. 理论<br>b. t检验<br>c. 调整的判定系数$\bar{R^2}$<br>d. 偏误</li><li>回归方程中包含一个变量的最重要的准则是理论，而不是统计上的显著性，否则存在产生错误或不可信结果的风险</li></ol><p><strong>错误函数形式的后果</strong></p><ul><li>影响解释变量的显著性</li><li>解释变量可能有非预期的符号</li><li>严重影响模型解释和变量预测</li></ul><p><strong>函数的选择形式</strong><br><strong>不含常数项的回归</strong><br>$$Y_i=\beta_i X_i+\epsilon_i$$<br>可以证明：</p><ul><li>残差均值不一定为0</li><li>拟合优度的判定系数可能出现负值</li></ul><blockquote><p>除非有非常强的先验预期，否则还是采取含有常数项的模型为好；<strong>即使先验预期为无常数项模型，仍可使用含常数项的模型，再检验其常数项在统计上等于0即可</strong></p></blockquote><p><strong>可线性化</strong>的非线性函数形式</p><ul><li>指数函数</li><li>对数函数</li><li>反函数形式</li><li>多项式形式</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c05791f3da-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c206fb53da-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_fc20ea32da-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_fecb0efeda-5.png" alt="5.png"></p><p><strong>如何选择函数形式</strong></p><ul><li>选择经济理论给出的特定函数形式</li><li>所选模型的参数应满足一定的先验预期</li><li>当多个模型能很好地拟合数据时，研究者往往选择调的判断系数较高或者AIC和SC较低的模型。<strong>然而，当被解释变量Y被替换时，这些指标不能比较</strong></li></ul><h3 id="函数形式选择小结">函数形式选择小结</h3><ol><li>即使理论上常数项可以等于零，也不能剔除常数项。另外，尽管常数项的估计值在理论上是显著的，也不能对常数项进行推理</li><li>函数形式的选择必须基于潜在的经济理论，也就是说要根据理论上的曲线形状去选择相应的函数形式。除非有特别要求需要选择其他形式，模型中变量的函数形式通常都是选用变量是线性的方程。</li><li>变量是非线性的函数形式包括双对数形式，半对数形式以及多项式形式。双对数形式特别适用于弹性是固定的模型中。半对数形式能用于哪些随着解释变量的增加，解释变量对于被解释变量的影响逐渐变小的模型中。多项式形式通常用于斜率符号会随着解释变量的不断变化而改变的模型中。</li><li>斜率虚拟变量是由一般解释变量和虚拟变量的成绩构成的。其中，这个一般解释变量于被解释变量之间的斜率会因为虚拟变量的设定状态是否被满足有所不同。</li><li>使用非线性函数形式存在一系列的潜在问题。特别地，如果解释变量Y的函数形式不同，则各个模型的调整的判定系数$\bar{R^2}$不能进行比较；此外，如果选择了错误的函数形式对样本范围外进行预测，那么，预测结果的残差可能会非常大。</li></ol><h3 id="例题-7">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_258f61eeda-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_1e5c6bfeda-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_20e2de13da-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_2925f4a1da-4.png" alt="4.png"></p><h2 id="第五章-多重共线性">第五章 多重共线性</h2><p><strong>多重共线性定义</strong><br>回归模型中的一些或者全部解释变量之间存在一种完全或不完全的线性关系。</p><p>完全多重共线性：<br>$\lambda_1X_1+\lambda_2X_2+…+\lambda_kX_k =0$</p><p>不完全多重共线性：<br>$\lambda_1X_1+\lambda_2X_2+…+\lambda_kX_k + v_i=0$</p><p>只要不是完全多重共线性，用OLS仍可以得到参数的估计值及其标准误，并且仍是无偏，尽管无偏，但估计量的标准误非常大，即估计的精度很小。</p><p>多重共线性可能会导致估计量的标准误偏大，同时可能导致参数的估计值的符号与预期符号不符。</p><p>若总体中各解释变量X之间<strong>没有</strong>线性关系，样本中各解释变量X之间<strong>也可能</strong>存在线性关系。</p><blockquote><p>多重共线性本质上是一种样本现象。</p></blockquote><p><strong>不完全多重共线性的特征</strong></p><ul><li>偏回归系数的t值会降低，倾向于统计上的不显著;</li><li>估计量（偏回归系数）对模型设定的变化非常敏感，估计系数可能出现<strong>非预期的符号或难以置信的数值</strong>;</li><li>虽然系数不显著，但总的拟合优度$R^2$<strong>却可能</strong>非常高</li><li>可能出现每个偏回归系数的t值都不显著，但回归方程的F值却很显著。</li></ul><p><strong>不完全多重共线性对预测的影响</strong></p><ul><li>如果回归分析的唯一目的是预测，并且如果不完全共线性的结构在样本和未来都保持一致，那么不完全多重共线性不是一个严重的问题</li><li>如果不完全共线性的结构在未来发生变化，则预测是冒险的</li></ul><p><strong>多重共线性的来源</strong></p><ul><li>经济变量之间具有共同变化的趋势<blockquote><p>如经济繁荣时期，基本经济变量都趋于增长；衰退时期又同时趋于下降</p></blockquote></li><li>模型中包含滞后变量<blockquote><p>考察当期收入和前期收入对消费的影响，两期收入间有较强的线性相关性</p></blockquote></li><li>横截面数据之间存在相关性<blockquote><p>生产函数中资本投入与劳动力投入往往出现高度相关的情况，大企业二者都大，小企业都小</p></blockquote></li></ul><p><strong>多重共线性的诊断</strong></p><ul><li>解释变量之间的相关系数 如果有多个变量，采用偏相关系数的方法</li><li>回归模型估计结果 $R^2$F统计量显著，但是单个变量不显著，并且有些变量参数符号不符合预期 经验做法</li><li>方差膨胀因子(VIF)</li></ul><p><strong>多重共线性的补救措施</strong></p><ul><li>剔除支配变量<blockquote><p>支配变量：与被解释变量高度相关，以致于完全掩盖了方程中其他解释变量的影响（如销售量与销售额）</p></blockquote></li><li>增加样本容量<blockquote><p>样本越大，估计越精准</p></blockquote></li><li>剔除多余变量<blockquote><p>潜在的理论假设作为剔除的主要依据</p></blockquote></li><li>变换解释变量<ul><li>一阶差分</li><li>两个变量相除</li><li>构造一个多重共线性的组合<ul><li>主成分分析法</li><li>因子分析法</li></ul></li></ul></li><li>什么都不做</li></ul><h3 id="小结-4">小结</h3><ol><li>完全多重共线性违背了一个解释变量不能是其他或多个解释变量的完全线性函数的古典假设。完全多重共线性会导致回归参数估计值的不确定性，并使得这些估计值具有巨大的标准差，从而使得普通最小二乘法不再适用</li><li>使用“多重共线性”一词时，通常指的是不完全多重共线性。不完全多重共线性指的是两个或多个解释变量之间存在较强的线性关系，以至于能够显著地影响方程中解释变量的参数估计。多重共线性问题既是一种样本现象，同时也是一种理论现象。不同的样本可能存在不同程度的多重共线性。</li><li>严重的多重共线性产生的主要结果是增大了回归参数估计量的方差，同时使得这些参数估计值的t统计量变小，扩大了置信区间。多重共线性不会导致参数估计值有偏，它对于回归方程的整体显著性或者任何一个不是多重共线性的解释变量的参数估计值都几乎没有多少影响。</li><li>由于在不同数据集中多重共线性的程度会有显著的不同，所以，在诊断多重共线性时需要注意的问题就是：在一个特定的样本当中，多重共线性究竟有多严重。</li><li>用来诊断严重多重共线性的两种有用的方法是：<br>a. 解释变量之间的简单相关系数是否很高？ 一般来看，相关系数的绝对值如果大于0.80，则认为很高。<br>b. 方差膨胀因子是否很高？一般来看当 $VIF(\hat{\beta_i}) &gt; 5$,则存在严重的多重共线性。<blockquote><p>如果两个答案中任意一个是“是”，则多重共线性确实存在，但是当答案同时为“否”时，也可能存在多重共线性问题。</p></blockquote></li><li>针对多重共线性有如下三种最为常用的补救措施：<br>a. 什么都不做（这样可以避免方程设定偏误）<br>b. 去除多余的变量<br>c. 增大样本容量</li><li>对于多重共线性的问题，什么都不做往往是最好的补救措施。假如多重共线性没有使t统计量减少到不显著的程度，那么就不需要对多重共线性采取任何补救措施。即使t统计量不显著，针对多重共线性所采取的补救措施也必须谨慎，因为补救所带来的估计成本，可能比从方程中消除多重共线性所获得潜在收益还要大。</li></ol><h3 id="例题-8">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2a52cea6db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2d8e6892db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2f98a836db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_3243fae4db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_3469286edb-5.png" alt="5.png"></p><h2 id="第六章-序列相关性">第六章 序列相关性</h2><p><strong>序列相关性的形式</strong></p><ul><li>一阶序列相关<blockquote><p>干扰项只与其滞后一期值相关 $\varepsilon_t=f(\varepsilon_{t-1})$</p></blockquote></li><li>高阶序列相关<blockquote><p>干扰项与其滞后多期值相关 $\varepsilon_t=f(\varepsilon_{t-1},\varepsilon_{t-2},…)$</p></blockquote></li></ul><p>序列相关通常假定为线性序列相关，最常见的形式为一阶序列相关<br>$$\varepsilon_t=\rho\varepsilon_{t-1}+u_t$$</p><blockquote><p>其中，$\rho$为一阶自相关系数，且$|\rho|&lt;1$;$u_t$为白噪声序列，满足$E(u_t)=0,Var(u_t)= \sigma_u^2,Cov(u_t,u_t+s)=0,s \ne 0$</p></blockquote><p><strong>根据自相关系数$\rho$，序列相关可分类如下</strong></p><ul><li>$\rho &gt; 0 \to $ 正序列相关</li><li>$\rho &lt; 0 \to $ 负序列相关</li><li>$\rho = 0 \to $ 无序列相关</li></ul><p><strong>序列相关类型</strong></p><ul><li>非纯序列相关<ul><li>由<strong>设定偏误</strong>导致，如遗漏变量、不正确的函数形式等</li></ul></li><li>纯序列相关<ul><li>时间序列数据：对同一总体的连续的观测很可能表现出某种系统的相关性，特别是连续观测时间间隔很短，如一周，一天，甚至同一天多次观测</li></ul></li></ul><p><strong>序列相关的后果</strong><br>在纯序列相关性的情形下</p><ul><li>OLS估计量仍是<strong>无偏的</strong></li><li>OLS估计的假设检验<strong>不可靠</strong></li><li>OLS估计量<strong>不再是有效</strong>的（即最小方差估计量）</li><li>标准误的OLS估计是<strong>有偏的</strong>，且偏差通常是负的，意味着OLS通常会高估参数的t值，导致原本不显著的变量可能变得显著</li></ul><p><strong>序列相关的检验</strong><br>检验思路：<strong>检验序列相关，也就是检验随机误差项之间的相关性及“形式”</strong></p><p>因随机误差项的样本对应物是OLS的残差，因此所有的检验都基于<strong>残差</strong></p><p><strong>常用检验方法</strong></p><ul><li>图解法</li><li>杜宾——沃森（DW）检验</li><li>BG检验</li></ul><p><strong>图解法</strong><br>将残差对时间描点，以发现残差在时间上的特定关联</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_99b5c3a7db-1.png" alt="1.png"></p><p><strong>杜宾——沃森（DW）检验</strong><br>利用方程的残差构成统计量，推断误差项是否存在一阶序列相关</p><p>基本假定</p><ul><li><p>回归模型包含截距项</p></li><li><p>序列相关是<strong>一阶</strong>序列相关</p></li><li><p>回归模型不能把<strong>滞后被解释变量</strong>作为解释变量</p></li><li><p>d检验值为0，意味着序列存在完全正相关</p></li><li><p>d值为2意味着不存在序列相关性</p></li><li><p>d值为4意味着序列存在完全负相关。</p></li><li><p>$0 &lt; d &lt; 2 \to 0 &lt; \rho &lt; 1$</p></li><li><p>$2 &lt; d &lt; 4 \to -1 &lt; \rho &lt; 0$</p></li></ul><p><strong>d统计量的检验</strong></p><ul><li>由于d统计量依赖于残差，而残差又依赖于X，故无法推导出d统计量的准确分布</li><li>D-W根据样本容量n和待估参数k，在给定显著性水平下，给出了d统计量上，下两个临界值$d_U和d_L$</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f0c1f0badb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_26faf637db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_29614da7db-4.png" alt="4.png"></p><p><strong>DW检验的缺陷</strong></p><ul><li>当d统计量落在两个不确定区域时，无法判断是否存在序列相关</li><li>当滞后因变量作为解释变量，检验无效</li><li>只能检验一阶序列相关，不适用于高阶序列相关</li><li>若误差项不是IID正态分布，d检验也不可靠</li></ul><p><strong>BG检验</strong></p><p>这里$\varepsilon_t$没有常数项是因为其期望值为0</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_d1e77c77db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_56814ba8db-6.png" alt="6.png"></p><p><strong>序列相关的补救措施</strong><br>非纯序列相关</p><ul><li>正确的模型设定，特别是出现负的序列相关<br>纯序列相关</li><li>广义最小二乘法：广义差分法<br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c55a4c5fdb-1.png" alt="1.png"></li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_30533aaddb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_328db523db-3.png" alt="3.png"></p><blockquote><p>实际中，有时只要迭代两次，就可得到较满意的结果。两次迭代过程也被称为**科克伦-奥科特两步法 **</p></blockquote><p><strong>几点说明</strong></p><ol><li>GLS的DW检验值和调整的$R^2$不能与OLS进行比较</li><li>GLS的估计值通常与OLS的估计值不同</li><li>在小样本中，因相关系数的估计可能有偏，GLS估计的系数可能也是有偏的</li></ol><ul><li><p>AR方法</p></li><li><p>Newey——West方法</p><ul><li>只修正标准误而不会改变系数的估计值</li><li>在大样本估计中，效果更好</li><li>绝大多数学术论文采用此种方法</li></ul></li></ul><h3 id="小结-5">小结</h3><ol><li>序列相关，也叫自相关，违背了古典假设四（即误差项的值彼此不相关）。通常，计量经济学家更多关注的是1阶序列自相关，即误差项当前值是前1期值和序列不相关的误差项u的函数：<br>$$\varepsilon_t=\rho\varepsilon_{t-4}+u_t, -1&lt;\rho&lt;1$$</li><li>纯序列相关是正确设定的回归方程中误差项的相关函数。非纯序列相关是由遗漏了变量或选择了不正确的函数形式等错误设定引起的，可以为正相关（$0&lt;\rho&lt;1$）,也可以为负相关（$-1&lt;\rho&lt;0$）。在经济和商业环境下，纯序列相关几乎都是正相关。</li><li>序列相关性的主要后果是采用普通最小二乘法估计的SE $(\hat{\beta})$是有偏的，导致假设检验不可靠。纯序列相关不会造成参数$\beta$的有偏估计。</li><li>诊断1阶序列相关性最常用得到方法是杜宾——沃森d检验。它用回归估计的残差检验误差项是否存在序列相关性。d检验值为0，意味着序列存在完全正相关，d值为2意味着不存在序列相关性，d值为4意味着序列存在完全负相关。</li><li>消除方程序列相关性的第1步时检查可能存在的设定错误，只有当非纯序列相关存在的可能性很小时，才能考虑修正纯序列相关性。</li><li>广义最小二乘法（GLS）是通过变换方程以消除纯1阶序列相关的方法。运用广义最小二乘法时需要 $\rho$的估计值。</li><li>Newey-West标准差时另一种修正序列相关性的方法。这种方法在考察序列相关性时，在不改变估计量值 $\hat{\beta}$的情况下，调整普通最小二乘估计的标准差SE $(\hat{\beta})$</li></ol><h3 id="例题-9">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_65781cbcdb-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_67b8314adb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_69770554db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_6ca77114db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_6db91db6db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_700c3b04db-6.png" alt="6.png"></p><h2 id="第七章-异方差性">第七章 异方差性</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f7a988dadb-1.png" alt="1.png"></p><p><strong>异方差类型</strong><br>非纯异方差</p><ul><li>由<strong>设定偏误</strong>导致，如遗漏变量</li><li>函数设定形式不当一般不会导致非纯异方差</li></ul><p><strong>纯异方差</strong></p><ul><li><strong>横截面数据</strong>：被解释变量取值差异较大</li><li>时间序列数据：学习效应，数据采集技术的变化</li></ul><p><strong>纯异方差的后果</strong></p><ul><li>OLS估计量仍然是<strong>无偏</strong>的</li><li>OLS估计量<strong>不再是有效</strong>的（即最小方差估计量）</li><li>标准误的OLS估计量是<strong>有偏</strong>的，且偏差<strong>通常</strong>是负的，意味着OLS通常会高估参数的t值，导致原本不显著的变量可能变得显著</li></ul><blockquote><p>若存在异方差，OSL估计的假设检验不可靠</p></blockquote><p><strong>异方差的检验</strong><br>检验思路：检验异方差，也就是检验随机误差项的方差与比例因子Z或解释变量X之间的相关性及其“形式”</p><p>因随机误差项<strong>方差</strong>的样本对应物是OLS的残差<strong>平方</strong>，因此所有的检验方法都基于<strong>残差平方</strong></p><p><strong>图解法</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_5028b5c5db-2.png" alt="2.png"></p><p><strong>帕克检验</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_52410ba7db-3.png" alt="3.png"></p><p>*<strong>white（怀特）检验</strong><br>基本思想：异方差来源于解释变量及其高次方<br>$$Y_i=\beta_0+\beta_1X_{1i}+\beta_2X_{2i}+\varepsilon_i$$</p><p>步骤1：假设同方差，OLS估计获得残差<br>步骤2：做辅助回归并得到拟合优度$R^2$<br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_6599c024db-4.png" alt="4.png"></p><p>步骤3：在无异方差的假设下有<br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_94218bfcdb-5.png" alt="5.png"></p><p>步骤4：若计算的$nR^2$超过选定显著性水平的临界值，则拒绝同方差假设。</p><blockquote><p>有一个经验判断，如果white检验中不包含交叉项，则主要针对异方差性的检验，如果包含交叉项的话，这个检验就是针对模型设定偏误和异方差性的联合检验</p></blockquote><p><strong>异方差的补救措施</strong></p><ul><li>非纯异方差<ul><li>正确的模型设定</li></ul></li><li>纯异方差<ul><li>广义最小二乘法：加权最小二乘（WLS）<ul><li>使用WLS的前提是知道比例因子Z及其与误差项方差之间的关系，即权重向量P</li></ul></li><li>修正异方差的标准误：White方法<ul><li>只修正标准误而不会改变系数的估计值</li><li>在大样本估计中，效果更好</li><li>绝大多数学术论文采用此种方法</li></ul></li><li>重新定义新变量<ul><li>将某些变量，特别是被解释变量取对数</li><li>根据经济理论，对某些变量进行“规模调整”</li></ul></li></ul></li></ul><h3 id="小结-6">小结</h3><ol><li>古典假定5要求误差项应服从相同方差的分布，而异方差性正是对此假定的违背。同方差的误差项的观测值的分布是，对于所有观测值而言都具有相同的方差；异方差性的误差项观测值的分布是，对于不同观测值而言，方差不完全相同。界面是数据模型中，最常产生异方差性。</li><li>异方差性误差项的方差不等于常数 $\sigma^2$,而等于 $\sigma_i^2$（其中下标表明方差随观测值的不同而变化）。异方差性有许多种，但是最常用的异方差性模型是将方差看成某个其他变量（比例因子Z）的函数<br>$$VAR(\varepsilon_i)=\sigma^2Z_i^2$$<br>比例因子通常是跟被解释变量的规模或者精确度相关联的一个变量</li><li>纯异方差性是指异方差性是由误差项的一个函数所表示的，而该误差项是设定正确的方程回归得到的。纯异方差性是由方程设定偏误（比如遗漏变量）导致的。</li><li>异方差性的主要后果是：最小二乘法的SE$(\hat{\beta})$有偏，从而导致假设检验的结果不可信。纯异方差性并不导致$\beta$本身的偏误。</li><li>检验异方差性的主要方法是BP检验和White检验，他们都是通过分析原方程的残差平方可以被辅助方程解释的程度来检验异方差性的。</li><li>修正异方差性的第一步是检查异方差性是否因为遗漏变量而引起的非纯异方差性。如果方程设定正确，那么，就可以考虑采用HC标准差，重新定义变量等措施对异方差性进行补救。</li></ol><h3 id="例题-10">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b375e682db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b4a997c0db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b70b1d06db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b96c7fb5db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_bc63d7fedb-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_be261426db-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c14e4c42db-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c381ba78db-8.png" alt="8.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c54e5b0edb-9.png" alt="9.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c90f48bddb-10.png" alt="10.png"></p><h2 id="第八章-虚拟变量模型">第八章 虚拟变量模型</h2><p><strong>经济变量</strong><br>- 可以度量的变量：商品需求量，价格，收入，产量等<br>- 无法定量度量；职业，性别，战争，自然灾害等<br><strong>虚拟变量</strong>：定性变量</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2b391e39db-1.png" alt="1.png"><br>解答：因为如果加入东部，那么三个虚拟变量相加等于1，就会存在多重共线性</p><p><strong>虚拟变量的设置原则</strong></p><ul><li>每一定性变量所需的虚拟变量个数要比该定性变量的类别少1，即如果有m个定性变量，只能在模型中引入m-1个虚拟变量</li><li>在同一方程中，可以引入多个虚拟变量来考察多种定性因素的影响</li></ul><p><strong>虚拟变量的引入</strong></p><ul><li>加法形式：考察<strong>截距的不同</strong><br>$$Y_i=\beta_0+\beta_1X_i+\beta_2D_i+\mu_i$$</li><li>乘法形式：考察<strong>斜率的不同</strong><br>$$C_t=\beta_0+\beta_1X_t+\beta_2D_tX_t+\mu_t$$</li><li>混合形式： <strong>截距和斜率同时发生变化</strong><br>$$Y_i=\beta_0+\beta_1X_i+\beta_3D_i+\beta_4(D_iX_i)+\mu_i$$</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0de0a155db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_48d8fbf7db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_4b258a20db-4.png" alt="4.png"></p><p><strong>计量经济学中的实验方法</strong><br><strong>随机分配实验</strong></p><ul><li>处理组：参与实验人员</li><li>对照组或控制组：未参与实验人员<br><strong>自然实验</strong></li><li>观测值自然产生，由外生事件引起</li><li>自然时间，政策变动</li></ul><h3 id="例题-11">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f7a84806db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f9c6cf69db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_ffd4b727db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_01b79418db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_04a20d2edb-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0667430adb-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_08d57cd8db-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0b295e6edb-8.png" alt="8.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0d7f931edb-9.png" alt="9.png"></p><h2 id="第九章-虚拟应变量模型">第九章 虚拟应变量模型</h2><p><strong>虚拟应变量的概念</strong></p><ul><li>虚拟变量既可以作为解释变量，又可以作为被解释变量（应变量）</li><li>虚拟应变量模型又称为概率模型，离散选择模型<ul><li>二元选择模型</li><li>多元选择模型</li></ul></li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b32092f5db-1.png" alt="1.png"></p><p>LPM模型存在的问题：</p><ul><li>$\hat{D_i}$的取值可能不在0和1之间</li><li>调整的判定系数$\bar{R^2}$不能准确度量方程的拟合优度</li><li>随机干扰项不服从正态分布，且存在异方差</li></ul><p><strong>Logit模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_5b687c48db-2.png" alt="2.png"></p><p><strong>Probit模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_aee3d9ecdb-4.png" alt="4.png"></p><blockquote><p>采用<strong>极大似然估计法</strong>来估计Logit模型和Probit模型</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e7e2c668db-9.png" alt="9.png"></p><p>因为这两种方法的分布函数不同，会得到不同的结果，这两组系数不能直接比较，但是二者系数存在一定的关系</p><p>标准正态分布的方差为1，而标准逻辑分布的方差为$\pi^2/3$，因此将Probit系数乘以$\pi/ \sqrt 3$（约1.81)，就会近似得到Logit系数（约为0.55）</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_4f38b362db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_52c9d7b3db-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_55dfdc04db-7.png" alt="7.png"></p><p><strong>其它虚拟应变量模型</strong></p><ul><li>多元Logit模型<ul><li>被解释变量存在<strong>多种</strong>离散且<strong>无序</strong>的选择</li><li>如择业的选择，交通工具的选择</li><li>采用极大似然估计</li></ul></li><li>序次Logit模型<ul><li>被解释变量存在<strong>多种</strong>离散且<strong>有序</strong>的选择</li><li>如债券的评级，舆论调查结果</li><li>采用极大似然估计</li></ul></li></ul><p><strong>补充</strong></p><ul><li>当被解释变量是虚拟变量时，不能采用线性概率模型（OLS估计方法）</li><li>Logit和Probit模型可用于估计被解释变量是二分应变量（二元选择）的问题</li><li>在解释变量是多元选择问题中，可以采用多元Logit模型或次序Logit模型</li></ul><h3 id="小结-7">小结</h3><ol><li>线性概率模型是用来解释虚拟变量$(D_i)$的参数线性方程，$\hat{D_i}$是$D_i$等于1的概率</li><li>采用普通最小二乘法估计线性概率模型会出现三个主要问题：<br>a. 调整的判定系数$\bar{R^2}$不能准确度量模型的整体拟合优度<br>b. $\hat{D_i}$的期望值不是以0和1为界<br>c. 误差项既不是同方差的，也不是正态分布的</li><li>在度量虚拟被解释变量的整体拟合优度时，可以采用样本观测值被模型正确解释的百分比$\bar{R_P^2}$来代替判定系数$\bar{R^2}$</li><li>二元logit模型是一种采用累积logistic函数的变形来回避线性概率模型无界性问题的虚拟被解释变量模型估计方法。模型形式为：<br>$$L:Pr(D_i=1)=ln(\frac{P_i}{[1-P_i]})=\beta_0+\beta_1X_{1i}+\beta_2X_{2i}$$</li><li>二元logit模型最好在大样本条件下采用最大似然法估计，logit模型的斜率参数表示：在其他解释变量保持不变的情况下，特定解释变量每增加1单位对给定选择的概率的对数的影响。</li><li>二元probit模型是一种利用累计正态分布函数的变形来规避线性概率模型无界性问题的虚拟被解释变量模型估计方法。二元probit模型与二元logit模型的特征非常相似</li></ol><h3 id="例题-12">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d0eea739db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d2a28cf5db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d46bff4fdb-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d53957ccdb-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d6d954b7db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d843d4addb-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_da2da811db-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_dbb8b170db-8.png" alt="8.png"></p><h2 id="第十章-预测">第十章 预测</h2><p><strong>预测共性</strong></p><ul><li>被预测的变量的都是未知的（样本外）</li><li>仅能预测变量的期望值（随机性）</li></ul><blockquote><p>预测是对被解释样本外的观测值的期望值的估计</p></blockquote><p><strong>计量模型的预测步骤</strong></p><ol><li>搜集相关数据，建立回归模型</li><li>估计模型</li><li>将预测期解释变量的值代入模型，进行预测</li><li>评价预测效果</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_a6827a05db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_db77c7bcdb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_0ff4f299db-3.png" alt="3.png"></p><p><strong>时间序列模型预测</strong><br>时间序列分析：“让数据自己说话”</p><ul><li>传统计量模型以理论为基础，而社会经济现象往往受多种因素影响且这些因素存在错综复杂的联系，使得根据理论建模较为困难</li><li>依据经济变量自身的历史资料，采用一定的统计方法，建立起能反映变量自身规律性的动态模型，以此对经济变量进行分析和预测</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_fe29e0b1db-4.png" alt="4.png"></p><p>平稳性检验：<strong>单位根检验</strong></p><ul><li>存在单位根的时间序列的一阶差分为平稳序列</li><li>常用方法为DF检验，ADF检验</li><li>检验的原假设为：时间序列存在单位根</li></ul><p><strong>时间序列模型预测（平稳）</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_81013502db-5.png" alt="5.png"></p><p><strong>时间序列模型预测（非平稳）</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_c6e785e3db-6.png" alt="6.png"></p><p><strong>预测方法</strong></p><ul><li>动态预测：从预测样本的第一期开始计算<strong>多步预测</strong></li><li>静态预测：利用滞后项被解释变量的实际值计算<strong>1步</strong>预测</li></ul><blockquote><p>静态预测效果更好</p></blockquote><blockquote><p>复杂模型的预测能力不一定强于简单模型</p></blockquote><blockquote><p>预测仅仅是计量经济学的用途之一，不要过分相信计量经济学模型的预测能力！</p></blockquote><h3 id="小结-8">小结</h3><ol><li>预测就是根据样本范围外的观测值来估计被解释变量的期望值。基本方法是将想要预测的变量作为被解释变量估计一个方程，然后将各个解释变量（需预测的观察结果）的值带入方程中计算出预测值。</li><li>一个预测方程在样本范围内拟合得很好，并不能保证也可以对样本范围外得观测值进行准确的预测。</li><li>确切地知道每一个解释变量的值的预测叫做无条件预测，但如果有一个或多个解释变量的值要通过预测得到，那么这种预测叫做条件预测。条件预测所得到的Y的预测值是无偏的（只要X的预测值是无偏的），但是一定会使误差方差变大。</li><li>如果方程的参数是用广义最小二乘法估计得出的（为了修正纯1阶序列相关），那么预测方程为：<br>$$\hat{Y_{T+1}}=\hat{\rho}Y_T+\hat{\beta_0}(1-\hat{\rho})+\hat{\beta_1}({\hat{X_{T+1}}-\hat{\rho}X_T})$$<br>式中，$\rho$代表自相关系数</li><li>如果同时计算出置信区间，预测结果将会更加有意义。置信区间是指被解释变量的真实值落入该区间的次数为某固定百分比（置信水平）的某个区间。计算如下：<br>$$\hat{Y_{T+1}}\pm S_Ft_c$$<br>式中，$S_F$为预测的估计标准差，$t_c$为某置信水平下双侧检验的t的临界值</li><li>ARIMA是一种高度精炼的曲线拟合方法，能用被解释变量（仅仅是被解释变量）的过去值和现在值来精确地预测该变量短期内的值，首先通过d阶差使序列变平稳，差分后的变量其均值和方差固定不变的。ARIMA(p,d,q)表示该模型是由p阶自回归过程（含有$\theta_1 Y_{t-1}$）和q阶的平均移动过程（含有$\phi_1\varepsilon_{t-1}$）来表示d阶差分的被解释变量</li></ol><h3 id="例题-13">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e068a6f7db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e1e076a9db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e3c3db68db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e520f2f4db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e7ab0f96db-5.png" alt="5.png"></p><h2 id="第十一章-时间序列模型">第十一章 时间序列模型</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b353f8bbdc-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b64aa6a7dc-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b8a666afdc-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_bb0123cfdc-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_bc69586adc-5.png" alt="5.png"></p><p><strong>有限滞后模型（FDL）模型的估计</strong><br>$$Y_t= \alpha_0+\beta_0X_t+\beta_1X_{t-1}+…+\beta_{p}X_{t-q}+\varepsilon_{t} $$<br>存在的问题</p><ul><li>X的各期滞后项之间可能存在严重的多重共线性</li><li>参数估计值未必会符合经济理论具有平滑递减的特征</li></ul><p><strong>FDL模型估计的假设</strong></p><ol><li>参数是线性的</li><li>解释变量和误差项不存在完全共线性</li><li>零条件均值 <strong>（严格外生）</strong><blockquote><p>$E(\varepsilon_{t}|X)=0$</p></blockquote></li><li>同方差性</li><li>无序列相关</li><li>正态性</li></ol><p><strong>FDL模型的特点</strong></p><ol><li>OLS的无偏性</li><li>OLS的样本方差<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_aed943f4dc-6.png" alt="6.png"></li><li>$\sigma^2$的无偏估计<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_07c099d6dc-7.png" alt="7.png"></li><li>高斯-马尔科夫定理<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_0acded4edc-8.png" alt="8.png"></li><li>正态抽样分布<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_43d2d2fadc-9.png" alt="9.png"></li></ol><p><strong>例子</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_82f01e81dc-10.png" alt="10.png"></p><p><strong>无限期分布滞后（IDL）模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d4081d01dc-1.png" alt="1.png"></p><p><strong>考伊克模型的特点</strong></p><ul><li>以滞后被解释变量代替了大量被解释变量的滞后项，节省了自由度</li><li>滞后被解释变量与解释变量的相关度较低，缓解了多重共线性<br><strong>考伊克模型的问题</strong></li><li>随机干扰项存在序列相关性</li><li>滞后被解释变量与随机干扰项<strong>不独立</strong></li></ul><blockquote><p>该问题属于内生性问题，导致OLS估计量有偏</p></blockquote><ul><li><p>外生解释变量和内生解释变量</p><ul><li>解释变量X与误差项$\varepsilon$不相关，则称x为<strong>外生解释变量</strong></li><li>解释变量X与误差项$\varepsilon$相关，则称x为<strong>内生解释变量</strong></li></ul></li><li><p>解决内生性问题</p><ul><li>在回归模型中增加遗漏变量进行控制</li><li>工具变量（IV检验），代理变量</li></ul></li></ul><p>简单的回归模型：$y=\beta_0+\beta_1x+\varepsilon$<br>$$Cov(x,\varepsilon) \ne 0 or E(\varepsilon|x) \ne 0$$</p><p>为了得到参数的一致估计，需要额外的信息。假设有一个可观测变量z，它满足两个条件：</p><ol><li>z和 $\varepsilon$不相关，即$Cov(z,\varepsilon)=0$</li><li>z和x相关，即$Cov(z, \varepsilon) \ne 0$<br>则称z是x的工具变量。</li></ol><blockquote><p>普通最小二乘估计是工具二乘估计（IV检验）的特殊形式</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_f6e0164bdc-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_f9e552fbdc-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_fbaed7dddc-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_ff9e488ddc-4.png" alt="4.png"></p><blockquote><p>两组非平稳时间序列进行回归，会产生<strong>虚假的回归现象</strong></p></blockquote><h3 id="小结-9">小结</h3><ol><li>分布滞后项反应Y的当期值是X的当期值和过去值的函数，于是，将X的影响分布于滞后的若干期中。无约束分布滞后模型（特设分布滞后模型）的普通最小二乘估计会产生多重共线性问题，自由度问题和参数随时间的非连续变化问题。</li><li>动态模型通过假设滞后解释变量的参数随滞后项的加长而呈集合呈几何级数衰减回避了分布滞后模型面临的问题。给定这一假设，动态模型可以表述为：<br>$$Y_t=\alpha_0+\beta_0 X_t+\lambda Y_{t-1}+u_t$$<br>式中，$Y_{t-1}$代表滞后被解释变量且$0&lt;\lambda&lt;1$.</li><li>在小样本条件下，动态模型的普通最小二乘估计存在偏误且假设检验不可靠。即使在大样本条件下，如果误差项存在序列相关性，普通最小二乘法在估计动态模型参数时仍会产生偏误。</li><li>在动态模型中，杜宾-沃森d检验有时不能检验出序列相关性，因为d偏向于2。另一种最常用的检测方法是拉格朗日乘数检验。</li><li>Granger因果关系，也称前定关系，描述的是这样一种情形，即若某时间序列变量变动，另一个时间序列变量会发生一致的可预测的变化。即便一个变量前定（Greanger导致）另外一个变量，也不能认为第一变量的变动引起了另一个变量的变动。</li><li>非平稳序列是随时间发生显著变化（例如，均值和方差）的序列。如果被解释变量和至少一个解释变量是非平稳的，回归结果可能产生谬误相关，使得调整的判定系数$\bar{R^2}$和非平稳解释变量的t统计量偏大。</li><li>DF检验可以检验出非平稳性，如果变量是非平稳的（存在单位根），那么，就应该采用DF检验检验方程残差的平稳性，进而检验方差的协整性。如果变量存在单位根但并不协整，那么，把模型的函数形式转换为1阶差分，再估计方程。如果变量存在单位根并且是协整的，那么，以变量的原始形式估计方程。</li></ol><h2 id="第十二章-面板数据模型">第十二章 面板数据模型</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_2abc28eadc-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_444b15a5dc-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_460a3463dc-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_4a0e3594dc-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_4f0d27eedc-5.png" alt="5.png"></p><h3 id="小结-10">小结</h3><ol><li>随机分配实验被认为是证明一个实验（处理）因素与出现的结果间存在因果关系的黄金准则。随机选择的处理组暴露在实验（处理）下，对照组不受实验因素作用。我们检验组的结果是否有显著性差异。不幸的是，这种实验在经济学的许多领域都不可行。</li><li>如果一个自然发生的时间（如政策的改变）能够被看作模仿了一个随机分配实验过程，则该自然实验能够为经济学中的因果关系提供证据。如果该事件让处理组结果的均值比对照组的均值发生了更显著的变化，则我们有证据表明实验（处理）是使结果发生改变的原因。</li><li>涉及自然实验数据的方程可以用差异中的差分模型来估计，该模型比较了处理组和对照组结果改变量之间的差异。</li><li>面板数据（也称纵向数据）通过在两个或两个以上时间段采集的相同截面样本的相同变量的观测值的方法，结合了时间序列数据和截面数据。面板数据常常是由多年的大规模调查项目得来的，为计量经济学分析提供了丰富的数据资源。</li><li>涉及面板数据的方程可以用固定效应模型或者更先进的随机效应模型进行估计。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由数据范围反推算法复杂度以及算法内容</title>
      <link href="/2022/05/16/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
      <url>/2022/05/16/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制为1秒或2秒</p><p>在这种情况下，C++代码操作次数一般控制在$10^7 - 10^8$</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择</p><ol><li>$n \leq 30$, 指数级别， dfs+剪枝，状态压缩DP</li><li>$n \leq 100 \to O(n^3)$ floyed, dp, 高斯消元</li><li>$n \leq 1000 \to O(n^2), O(n^2logn)$ dp, 二分， 朴素版dijkstra，朴素版Prim，Bellman-Ford</li><li>$n \leq  10000\to O(n * \sqrt n)$ 块状链表、分块、莫队</li><li>$n \leq 100000 \to O(nlogn)$ 各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，Kruskal，spfa，求凸包，求半平面交，二分，CDQ分治，整体二分，后缀数组，树链剖分，动态树</li><li>$n \leq 1000000 \to O(n)$, 以及常数较小的$O(nlogn)$算法单调队列，hash，双指针扫描，并查集，kmp，AC自动机，常数比较小的$O(nlogn)$做法sort、树状数组、heap、dijkstra、spfa</li><li>$n \leq 10000000 \to O(n)$ 双指针扫描，kmp，AC自动机，线性筛素数</li><li>$n \leq 10^9 \to O(\sqrt n)$,判断素数</li><li>$n \leq 10^{18} \to O(logn)$,最大公约数，快速幂，数位DP</li><li>$n \leq 10^{1000} \to O((logn)^2)$ 高精度加减乘除</li><li>$n \leq 10^{100000} \to O(logk*loglogk)$  , k表示位数，高精度加减，FFT/NTT</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing周赛</title>
      <link href="/2022/05/14/AcWing%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/05/14/AcWing%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="第56场周赛">第56场周赛</h2><h3 id="寻找">寻找</h3><h4 id="题意分析">题意分析</h4><p>出现1直接输出</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长子序列">最长子序列</h3><h4 id="题意分析-2">题意分析</h4><p>找出规律发现是直接串到自己二倍还是自己，求最大值即可</p><h4 id="代码-2">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x != b[x]) b[x] = <span class="hljs-built_in">find</span>(b[x]);<br>    <span class="hljs-keyword">return</span> b[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (a[mid] &lt;= <span class="hljs-number">2</span> * a[i]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        b[i] = l;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        res = <span class="hljs-built_in">max</span>(res, (<span class="hljs-built_in">find</span>(i) - i + <span class="hljs-number">1</span>));<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="染色">染色</h3><h4 id="题意分析-3">题意分析</h4><p>直接从上到下染色，结果就是答案</p><h4 id="代码-3">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> p[N], c[N], col[N];<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> n, res;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>    col[u] = color;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-built_in">paint</span>(j , color);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (col[u] != c[u])<br>    &#123;<br>        res ++ ;<br>        <span class="hljs-built_in">paint</span>(u, c[u]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p[i]);<br>        <span class="hljs-built_in">add</span>(p[i], i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i]);<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第51场周赛">第51场周赛</h2><h3 id="上车"><a href="https://www.acwing.com/problem/content/4422/">上车</a></h3><h4 id="题意分析-4">题意分析</h4><p>只要每辆车差值大于等于2答案加一</p><h4 id="代码-4">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (y - x &gt;= <span class="hljs-number">2</span>) res ++ ;<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连通分量"><a href="https://www.acwing.com/problem/content/4423/">连通分量</a></h3><h4 id="题意分析-5">题意分析</h4><p>我们以障碍物为操作对象，我们发现障碍物有周围4个格子，我们可以看一下上下左右四个一共有多少连通块，我们将当前的障碍物变成空地之后，我们就可以让上下左右方向上的空地连通起来，我们本质上是求将上下左右的连通块合并完之后，新的连通块的大小</p><p>求连通块有三种方法，分别是dfs，bfs或者并查集</p><p>我们对于当前四个方向上的格子一共有几个连通块，每一个集合用根节点表示，对于空地来说，如果有abcd四个空地，我们可以求一下每一个区域的代表元素a’b’c’d’，将属于同一个区域里面的连通块去掉，将不同的连通块的大小加上1得到新的连通块的大小</p><h4 id="代码-5">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> p[N * N], s[N * N];<br><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x * m + y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * m; i ++ ) p[i] = i, s[i] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>            <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k ++ )<br>                &#123;<br>                    <span class="hljs-type">int</span> x = i + dx[k], y = j + dy[k];<br>                    <span class="hljs-keyword">if</span> (x &lt; n &amp;&amp; x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">get</span>(x, y)), b = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">get</span>(i, j));<br>                        <span class="hljs-keyword">if</span> (a != b)<br>                        &#123;<br>                            s[b] += s[a];<br>                            p[a] = b;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>            <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> fathers[<span class="hljs-number">4</span>], cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k ++ )<br>                &#123;<br>                    <span class="hljs-type">int</span> x = i + dx[k], y = j + dy[k];<br>                    <span class="hljs-keyword">if</span> (x &lt; n &amp;&amp; x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    fathers[cnt ++ ] = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">get</span>(x, y));<br>                &#125;<br>                <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt)<br>                &#123;<br>                    <span class="hljs-built_in">sort</span>(fathers, fathers + cnt);<br>                    cnt = <span class="hljs-built_in">unique</span>(fathers, fathers + cnt) - fathers;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cnt; k ++ )<br>                        sum += s[fathers[k]];<br>                &#125;<br>                cout &lt;&lt; sum % <span class="hljs-number">10</span>;<br>            &#125;<br>            <br>        cout &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="https://www.acwing.com/problem/content/4424/">信号</a></h3><h4 id="题意分析-6">题意分析</h4><p>如果第 $p$ 号房子内装有信号发射器，则所有房间编号在 $[p−r+1,p+r−1]$ 范围内的房子均可被其发出的无线信号覆盖，而其余房子则不会被其发出的无线信号覆盖。</p><p>至少开启多少个无线信号发射器，才能保证所有房子都被无线信号覆盖到,如果无解输出-1</p><p>时间复杂度只要控制在$O(n^2)$</p><p>本题采用贪心的方法来做，直觉上想如果最左边的区域可以由两个信号发射器覆盖，我们选择更靠右的方案一定是更优的，同理如果一个点可以由多个点覆盖那么一定是更靠右的效果更好</p><h4 id="代码-6">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, r;<br><span class="hljs-type">int</span> q[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-keyword">if</span> (a) q[cnt ++ ] = i;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (last &gt;= n) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (q[i] - r &gt; last)<br>        &#123;<br>            res = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; cnt &amp;&amp; q[j + <span class="hljs-number">1</span>] - r &lt;= last) j ++ ;<br>        last = q[j] + r - <span class="hljs-number">1</span>;<br>        res ++ ;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (last &lt; n) res = <span class="hljs-number">-1</span>;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stata使用笔记</title>
      <link href="/2022/05/12/stata%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/12/stata%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="b站教学视频"><a href="https://space.bilibili.com/19985250/search/video?keyword=stata">b站教学视频</a></h2><h2 id="导入数据">导入数据</h2><p>use</p><h2 id="画散点图">画散点图</h2><p>scatter 纵坐标变量 横坐标变量</p><p>scatter y x1 x2 …</p><h2 id="回归分析">回归分析</h2><p>reg y x1 x2 x3 …</p><h2 id="假设检验">假设检验</h2><h3 id="正态分布">正态分布</h3><ul><li>正态分布检验指令 sktset + 变量</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_96103944d1-1.png" alt="1.png"></p><blockquote><p>Obs 样本值 Pr（skewness）是对偏度的正态分布检测值 Pr（kurtosis）是对其峰度的正态分布检验，chi（2）是对总体的正态分布检验，我们主要观看的是P值（Prob）如果P值大于0.05我们就认为其符合正态分布，否则不符合</p></blockquote><ul><li>寻找变量正态化的方法 ladder+变量</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_9ac04f1ed1-2.png" alt="2.png"></p><blockquote><p>Formula对数据的处理方法，主要看p值如果P值大于0.05我们就认为其符合正态分布，否则不符合</p></blockquote><ul><li>画出变量进行正态话处理后的图像 gladder+变量</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_9c9332acd1-3.png" alt="3.png"></p><h3 id="t检验">t检验</h3><ul><li>单一样本T检验 ttest + 变量名 = 数值</li></ul><blockquote><p>通过单一样本T检验，我们可以实现样本均值与总体均值的比较。也就是说，是用来比较一组数据的平均值和一个数值有无差异</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_9f913caad1-4.png" alt="4.png"></p><blockquote><p>Mean是平均值，std.err为标准误，std.dev是标准差 95% conf.interval是95%水平的置信区间范围 自由度为观测样本数-1 t为t值 主要看P值如果小于0.05那么这组数据的平均值与给定的数据平均值有显著性差异，如果大于0.05那么则无显著性差异</p></blockquote><ul><li>单一样本T检验修改置信水平 ttest + 变量名 = 数值，level(99)</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_a2afad70d1-5.png" alt="5.png"></p><blockquote><p>数据指标与上图一致，只是置信水平发生变化</p></blockquote><ul><li>独立样本T检验修改置信区间值 ttest 变量名=变量名，unpaired</li></ul><blockquote><p>通过独立样本T检验，我们可以实现两个独立样本的均值检验</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_a612a332d1-6.png" alt="6.png"></p><blockquote><p>其他表项与上述表项类似，主要看P值如果小于0.05那么两组数据有显著性差异，如果大于0.05那么则无显著性差异</p></blockquote><ul><li>独立样本T检验修改置信区间值 ttest 变量名=变量名，unpaired level(数值)</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_a88d39fcd1-7.png" alt="7.png"></p><ul><li><p>独立样本T检验两样本方差不同 ttest 变量名=变量名，unpaired unequal</p></li><li><p>配对样本T检验 ttest 变量名=变量名</p></li></ul><blockquote><p>通过配对样本T检验，我们可以实现对成对数据样本均值的比较，其与独立样本T检验的区别是：两个样本来自同一总体，而且数据的顺序不能调换。</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_aadaa1d2d1-8.png" alt="8.png"></p><blockquote><p>主要看P值分析与上面一致</p></blockquote><h3 id="F检验">F检验</h3><blockquote><p>F检验又叫方差齐性检验。从两研究总体中随机抽取样本，要对这两个&gt;样本进行比较的时候，首先要判断两总体方差是否相同，即方差齐性。若两总体方差相等，则直接用t检验，若不等，可采用t’检验或变量变换或秩和检验等方法。<br>从两研究总体中随机抽取样本，要对这两个样本进行比较的时候，首先要判断两总体方差是否相同，即方差齐性。若两总体方差相等，则直接用t检验，若不等，可采用t’检验或变量变换或秩和检验等方法。其中要判断两总体方差是否相等，就可以用F检验。</p></blockquote><p>reg y x1 x2 x3 x4</p><p>test x1 x2 x4</p><p>test x2=0.3</p><p>注意除了y其他都能用test检验</p><h2 id="邹检验">邹检验</h2><h3 id="例题">例题</h3><p>建立鸡肉消费量Y对鸡肉价格PC、人均可支配收入YD的回归模型，采用1974-2002的数据估计参数(变量YEAR)，检验1993年是否存在结构变化(邹检验)，请写出相应的Stata的程序或命令(数据use CHICK6.dta)。</p><h3 id="方法1">方法1</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> CHICK6.dta<br><span class="hljs-keyword">reg</span> Y PC YD<br><span class="hljs-keyword">scalar</span> ssr = <span class="hljs-built_in">e</span>(rss)<br><span class="hljs-keyword">reg</span> Y PC YD <span class="hljs-keyword">if</span> year &lt; 1993<br><span class="hljs-keyword">scalar</span> srr1 = <span class="hljs-built_in">e</span>(rss)<br><span class="hljs-keyword">reg</span> Y PC YD <span class="hljs-keyword">if</span> year &gt;= 1993<br><span class="hljs-keyword">scalar</span> srr2 = <span class="hljs-built_in">e</span>(rss)<br><span class="hljs-keyword">gene</span> f = ((ssr - ssr1 - ssr2) / 3) / (srr1 + srr2) / (29 -  6)<br></code></pre></td></tr></table></figure><h3 id="方法2">方法2</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> CHICK6.dta<br><span class="hljs-keyword">reg</span> Y PC YD<br><span class="hljs-keyword">estat</span> sbknown,<span class="hljs-keyword">break</span>(1993)<br></code></pre></td></tr></table></figure><h2 id="循环结构举例">循环结构举例</h2><p><a href="https://blog.csdn.net/Hedy_mail/article/details/108351037">参考博客</a></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">scaler j = 1<br><span class="hljs-keyword">while</span> j &lt;= num&#123;<br>    <span class="hljs-keyword">matrix</span> pvalue[j, 1] = 2*(1-t(<span class="hljs-built_in">rowsof</span>(x)-<span class="hljs-built_in">colsof</span>(X), <span class="hljs-built_in">abs</span>(tvalue[j, 1])))<br>    <span class="hljs-keyword">scalar</span> j = j + 1 <span class="hljs-comment">// 更新时也用scalar</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正态性JB检验：-jb6-X">正态性JB检验： jb6 X</h2><blockquote><p>需要提前安装 ssc install jb6</p></blockquote><ul><li>输出的第二个数大于0.05则可认为数据符合正态分布</li></ul><h2 id="多重共线性检验之VIF判断">多重共线性检验之VIF判断</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">estat</span> <span class="hljs-keyword">vif</span><br></code></pre></td></tr></table></figure><blockquote><p>先回归再检测，如果vif大于5认为存在严重的多重共线性</p></blockquote><h2 id="序列相关性">序列相关性</h2><h3 id="序列相关性检验">序列相关性检验</h3><blockquote><p>先回归再检验</p></blockquote><ul><li><p>DW检验:estat dwatson</p></li><li><p>(简写) estat dwa<br><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_3c9c8bdbd1-1.png" alt="1.png"></p></li><li><p>BG/LM检验 (拉格朗日乘数检验)</p><blockquote><p>DW检验有许多限制，只能用于阶序列相关性的检验，方程包含一个常数，而且方程不含滞后被解释变量，还有DW检验会随着被解释变量的个数增加，不确定区域也会扩大</p></blockquote><ul><li>estat bgo</li><li>estat bgo, lags(1/2)</li><li>estat bgo, small lags(1/2)</li><li>lags用来设置自相关系数</li><li>Prob&lt;0.05时拒绝原假设，认为存在自相关</li><li>small specifies that the p-values of the test statistics be obtained using the F or t distribution instead of the default chi-squared or normal distribution.</li></ul></li></ul><h3 id="自相关图和bg检验">自相关图和bg检验</h3><p>estat bgodfrey, lags( p ) nomiss()</p><p>以上为BG检验原始语句，lags( p )用来指定BG检验的滞后阶数p，默认为lags(1),选择项nomiss()表示进行不添加0的BG检验，默认是以0代替缺失值，即DM方法</p><p>关于如何确认滞后阶数，简单的方法是看自相关图，画图自相关图后，阴影部分时95%的置信区间，点落在95%的置信区间之外或者附近，表明显著不为0，也就是有自相关</p><h3 id="序列相关的补救之GLS方法">序列相关的补救之GLS方法</h3><blockquote><p>自动估计相关系数和阶数，两条命令代表相关系数的两种迭代方法<br>- prais Y X1 X2 X3<br>- prais Y X1 X2 X3, corc</p></blockquote><h3 id="序列相关的补救之NW方法">序列相关的补救之NW方法</h3><blockquote><p>lag(3)代表最高自相关阶数为3<br>newey Y PC PB YD, lag(3)</p></blockquote><h2 id="异方差检验">异方差检验</h2><p><a href="https://blog.csdn.net/Clytie_Lion/article/details/120510724">参考博客</a></p><h3 id="异方差的怀特检验">异方差的怀特检验</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> VOL TOT SAT <span class="hljs-comment">// 先回归</span><br><span class="hljs-keyword">estat</span> <span class="hljs-keyword">imtest</span>, white<br></code></pre></td></tr></table></figure><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_3fab8ef2d1-2.png" alt="2.png"></p><h3 id="异方差的补救">异方差的补救</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//补救措施1 怀特调整</span><br><span class="hljs-keyword">reg</span> PCON <span class="hljs-keyword">REG</span> PRICE, robust<br><span class="hljs-comment">//补救措施2 变换方程形式(双对数)</span><br><span class="hljs-keyword">gen</span> lnPCON = <span class="hljs-built_in">ln</span>(PCON)<br><span class="hljs-keyword">gen</span> lnREG = <span class="hljs-built_in">ln</span>(<span class="hljs-keyword">REG</span>)<br><span class="hljs-keyword">gen</span> lnPRICE = <span class="hljs-built_in">ln</span>(PRICE)<br><span class="hljs-keyword">reg</span> lnPCON lnREG lnPRICE<br><span class="hljs-comment">//补救措施3 重新定义定义变量</span><br><span class="hljs-keyword">gen</span> PCON1 = PCON / POP<br><span class="hljs-keyword">gen</span> REG1 = <span class="hljs-keyword">REG</span> / POP<br><span class="hljs-keyword">reg</span> PCON1 REG1 PRICE<br></code></pre></td></tr></table></figure><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_42398d09d1-3.png" alt="3.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_4590028cd1-4.png" alt="4.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_485e9575d1-5.png" alt="5.png"></p><h3 id="例题-2">例题</h3><p>建立图书馆藏书量VOL对师生人数TOT，学生高考成绩SAT的回归模型，请写出线性回归模型的stata命令，采用white法检验异方差命令，采用White调整异方差的命令</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> VOL TOT SAT<br><span class="hljs-keyword">estat</span> <span class="hljs-keyword">imtest</span>, white<br><span class="hljs-keyword">reg</span> VOL TOT SAT, robust<br></code></pre></td></tr></table></figure><p>结果如下：</p><blockquote><p>这个结果用的是CHICK6.dta的数据，但意思大同小异</p></blockquote><p>怀特检验，我们主要H0是同方差假设，HA是异方差假设，看P值，如果P值&lt;0.05说明我们要拒绝原假设，即原序列有着异方差性</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_de5e842ad2-1.png" alt="1.png"></p><p>怀特检验修正</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_e1e7d20ad2-2.png" alt="2.png"></p><blockquote><p>画自相关图<br>ac e1</p></blockquote><h2 id="8A-SAT互动练习">8A SAT互动练习</h2><p>简单来说，本次练习就是寻找最合适的解释变量，来解释被解释变量。</p><p>首先肯定要选择GPA，APMATH以及APENG为我们的解释变量，然后AP因为APMATH以及APENG已经可以解释所以不用，然后看ESL和RACE因为样本中不是亚洲人就是白种人，如果英语不是母语，很大概率是亚洲人，并且在相关系数表中，ESL和RACE的相关系数为0.8461&gt;0.8太大了，因此ESL和RACE只用选一个就可以了，在考试中我认为ESL个具有代表性，因为如果你不是母语者那么你学习过程中肯定有一定的困难，所以采用ESL作为解释变量，而GENDER和PEPR在我看来都有充足的解释力，而且前文也提到了性别对于SAT成绩的巨大影响。</p><p>综上所述，我们先用 GPA APMATH APENG ESL GENDER PEPR进行回归分析</p><p>预测符号</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">GPA</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">APMATH</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">APENG</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">ESL</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">GEND</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">PREP</td><td style="text-align:center">+</td></tr></tbody></table><p>开始回归</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_eee6f902d2-1.png" alt="1.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_f09be2efd2-2.png" alt="2.png"></p><p>我们首先看系数与我们的设想一不一致，然后看p值，在t检验中，p值如果&lt;0.05则说明该解释变量有显著的解释力，反之则没有。<br>我们发现PREP与我们的预期不符。表面上看，变量PREP是一个有影响力的变量，因为几乎可 以肯定PREP课程可以提高修读了该课程学生的SAT测试成绩。问题是学生修读PREP课程的 决定与他以前的（或者预期的）SAT测试成绩有关。我们相信那些感觉自己需要修读PREP课 程的学生会做出正确的判断，同时，我们认为这些课程会使他们的成绩达到与那些没有选修 PREP课程的学生的成绩不相上下。因而，该变量对SAT成绩没有显著的影响。<br>所以去除PREP</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_f541fe6ed2-3.png" alt="3.png"></p><p>发现一个问题，其他变量p值都挺好的，但到了ESL就拉了，从感性角度出发，但是ESL有充分理由留在这里，这启发我们，数据统计出来的只是一个参考，具体问题，要结合具体的情况分析。</p><h2 id="stata命令">stata命令</h2><ul><li>导入数据<ul><li>命令行 ——use “路径”<ul><li>例：use “D:\stata\auto.dta”</li></ul></li><li>标签——文件——打开——选择文件</li></ul></li><li>计算函数<ul><li>exp()</li><li>log()</li><li>log10()</li><li>sqrt()</li><li>abs()</li></ul></li><li>数据操作<ul><li>导入数据<ul><li>命令行——use “路径”<ul><li>例：use “D:\stata\auto.dta”</li></ul></li><li>标签——文件——打开——选择文件</li></ul></li><li>删除数据行<ul><li>drop in 1/n //删除前n行</li><li>drop in n 删除n行</li><li>duplicates drop //删除重复行</li></ul></li><li>导出dta文件为excel<ul><li>save name.dta, replace \ export excel using name</li></ul></li></ul></li><li>变量操作<ul><li>新建变量<ul><li>命令行——generate 新变量名=新变量产生方法<ul><li>例: generate newprice = price + 4(price是已有变量)</li></ul></li></ul></li><li>删除变量<ul><li>命令行——clear</li></ul></li><li>变量值排序<ul><li>命令行——sort预排序变量<ul><li>默认从小到大</li><li>例:sort price</li></ul></li></ul></li><li>查看变量值分布<ul><li>命令行——tabulate 变量</li></ul></li><li>变量的分组<ul><li>命令行——generate 新变量 = autocode(旧变量，分类数，下界，上界)</li><li>举例<ul><li>generate newmpg = autocode(mpg, 3, 10, 40)</li><li>结果:新变量newmpg将只取20，30，40中的值</li></ul></li></ul></li></ul></li><li>矩阵操作<ul><li>设置系统能容纳的矩阵大小<ul><li>命令行: set matsize 数值</li></ul></li><li>创建矩阵A<ul><li>创建单位矩阵<ul><li>matrix define A = l(n) // 创建n维单位矩阵</li></ul></li></ul></li><li>手动输入值构造<ul><li>Mat A=[1,2,3\4,5,6]</li></ul></li><li>创建每个值相等的矩阵<ul><li>matrix A = J(行数，列数，每个元素的值)</li></ul></li><li>通过变量构造<ul><li>mkmat 变量1 变量2 变量3，matrix(A) //会将三个变量作为矩阵的三列</li></ul></li><li>通过矩阵构造<ul><li>matrix A = []//类似输入值构造，只不过换成了矩阵，注意行列对齐</li><li>matrix A = 矩阵运算式</li><li>matrix A = invsym(B)// B是一个可逆矩阵，A得到其逆矩阵</li><li>matrix diag = vecdiag(A)//提取A的对角元素得到列向量diag</li><li>matrix R = cholesky(A) // S = RR’，对S进行分解</li></ul></li><li>创建对角矩阵<ul><li>mat D = diag(v) // 其中v是n * 1或 1 * n矩阵</li></ul></li><li>显示矩阵A<ul><li>mat list A</li></ul></li><li>提取矩阵某行某列<ul><li>X[1…2, 3…4]得到X第1、2行和第3、4列形成的矩阵</li><li>X[1…, 3…]得到第1行到最后一行，第3列到最后一列</li></ul></li><li>矩阵运算<ul><li>取逆：invsym(A)</li><li>转置：A’</li></ul></li><li>设计矩阵列名<ul><li>matrix colnames A = 第一列名 第二列名 第三列名</li></ul></li><li>其他矩阵相关函数<ul><li>scalar m = rowsof(A)//返回矩阵A的行数给标量m</li><li>scalar n = colsof(A)//返回矩阵A的列数给标量n</li></ul></li></ul></li><li>绘图<ul><li>散点图<ul><li>Twoway scatter y x</li></ul></li><li>折线图<ul><li>Twoway line y x</li></ul></li><li>带数据点标记折线图<ul><li>twoway connected y x</li></ul></li><li>垂直线图<ul><li>twoway dropline y x</li></ul></li><li>lowess图<ul><li>twoway lowess y x</li></ul></li><li>脉冲图<ul><li>twoway spike y x</li></ul></li></ul></li><li>循环结构<ul><li>见文档</li></ul></li><li>得到data集中的所有行数<ul><li>scalar n = _N</li></ul></li><li>单词表<ul><li>Obs(objects)有效观测样本</li><li>Std.Dev(Standard deviation)标准差</li><li>Wgt(Weight)权重</li><li>Varlance方差</li><li>Skewness偏度<ul><li>用来衡量数据的不对称性</li><li>&lt;0时，概率分布左偏，有一个向左的尾</li><li><blockquote><p>0时，概率分布右偏，有一个向右的尾</p></blockquote></li><li>=0时，数据相对均匀地排布在平均值两侧</li></ul></li><li>Kurtosis峰度<ul><li>用来衡量数据的集中性</li><li>取值范围&gt;=1，峰度值越大概率分布图越高尖</li><li>完全服从正态分布的数据峰度为3</li></ul></li></ul></li><li>统计、假设检验<ul><li>查看变量的统计指标值<ul><li>命令行——summarize [变量1 变量2 …][,detail]<ul><li>后面不加变量名：输出所有变量的统计指标值</li><li>后面加变量名，变量名之间空格隔开：输出所选变量的统计指标值<ul><li>例：summarize price mpg</li></ul></li><li>后面加,detail：显示更多的统计指标值<ul><li>例：summarize price mpg,detail</li></ul></li></ul></li><li>命令行——tabstat 变量1 [变量2 …],stats(指标1 [指标2 …])</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计量经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春季每日一题2022</title>
      <link href="/2022/05/09/%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022/"/>
      <url>/2022/05/09/%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022/</url>
      
        <content type="html"><![CDATA[<p>之前的有时间补先按照顺序做吧</p><h2 id="DAY-5-09">DAY 5-09</h2><h3 id="更多奇怪的照片"><a href="https://www.acwing.com/problem/content/3362/">更多奇怪的照片</a></h3><h3 id="题意分析-9">题意分析</h3><p>给定一个序列n，每个点只能选一次，要全部选完，然后组成偶奇交替的序列</p><p>可以记录奇数和偶数出现的次数，因为要求最大分组，用奇数+偶数=奇数 奇数+奇数=偶数来构造，每用一个在数目上减去。</p><p>可以证明按照这种处理方法如果还剩下若干个偶数，或者若干个奇数没有办法配对，那么可以把偶数加到前面的偶数组中，奇数只能剩下1个，否则的话，2个奇数能够凑成偶数，能够继续构造，因此这种方法一定有解，并且一定是最优解,如果奇数只剩下1个，那么答案要减一，因为如果只剩下1个奇数没法配对，那么当前一定是匹配偶数，前一个一定是奇数，现在剩下一个没法配对成功，那么就要把前一个分组删除，把它和最后一个奇数合并，构成一个偶数，因此答案减一，本题就做完了。</p><h3 id="代码-12">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> odd, even;<br><span class="hljs-type">int</span> n, res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span>) odd ++ ;<br>        <span class="hljs-keyword">else</span> even ++ ;<br>    &#125;<br>    <br>    <span class="hljs-comment">//  cout &lt;&lt; odd &lt;&lt; &quot; &quot; &lt;&lt; even &lt;&lt; endl;</span><br>    <br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (even) even -- , res ++ ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (odd &gt;= <span class="hljs-number">2</span>) odd -= <span class="hljs-number">2</span>, res ++ ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (odd) odd -- , res ++ ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout &lt;&lt; odd &lt;&lt; endl;</span><br>        i ++ ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (odd == <span class="hljs-number">1</span>) res -- ;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DAY-05-10">DAY 05-10</h2><h3 id="舒适的奶牛"><a href="https://www.acwing.com/problem/content/3374/">舒适的奶牛</a></h3><h3 id="题意分析-10">题意分析</h3><p>题目要求的是每次加入奶牛后舒服的奶牛数量，那么我们当读入一个奶牛时，我们发现它只会改变它周围四个点的性质，那么我们检查下该点和其周围的奶牛就可以了，用st[i][j]表示这个位置有没有算过答案，如果算过答案–</p><p>时间复杂度为$O(n)$</p><h3 id="代码-13">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (g[a][b]) cnt ++ ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">3</span>) st[x][y] = <span class="hljs-literal">true</span>, res ++ ;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">4</span> &amp;&amp; st[x][y]) res -- ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>        g[x][y] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-built_in">check</span>(x, y);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = x + dx[j], b = y + dy[j];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n) <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-keyword">if</span> (g[a][b]) <span class="hljs-built_in">check</span>(a, b);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DAY-05-11">DAY 05-11</h2><h3 id="牛的学术圈-II"><a href="https://www.acwing.com/problem/content/3749/">牛的学术圈 II</a></h3><h3 id="题意分析-11">题意分析</h3>]]></content>
      
      
      <categories>
          
          <category> 自律 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训动态规划题解</title>
      <link href="/2022/05/08/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/08/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A题">A题</h2><h3 id="题意分析-12">题意分析</h3><p>首先讲解一下最长上升子序列<br>集合表示：f[i][j]f[i][j]表示a的前i个字母，和b的前j个字母的最长公共子序列长度</p><p>集合划分：以a[i]a[i],b[j]b[j]是否包含在子序列当中为依据，因此可以分成四类：</p><p>①a[i]a[i]不在，b[j]b[j]不在</p><p>max=f[i−1][j−1]max=f[i−1][j−1]<br>②a[i]a[i]不在，b[j]b[j]在</p><p>看似是max=f[i−1][j]max=f[i−1][j] , 实际上无法用f[i−1][j]f[i−1][j]表示，因为f[i−1][j]f[i−1][j]表示的是在a的前i-1个字母中出现，并且在b的前j个字母中出现,此时b[j]b[j]不一定出现，这与条件不完全相等，条件给定是a[i]a[i]一定不在子序列中，b[j]b[j]一定在子序列当中，但仍可以用f[i−1][j]f[i−1][j]来表示，原因就在于条件给定的情况被包含在f[i−1][j]f[i−1][j]中，即条件的情况是f[i−1][j]f[i−1][j]的子集，而求的是max，所以对结果不影响。</p><p>例如：要求a，b，c的最大值可以这样求：max(max(a,b),max(b,c))max(max(a,b),max(b,c))虽然b被重复使用，但仍能求出max，求max只要保证不漏即可。</p><p>③a[i]a[i]在，b[j]b[j]不在原理同②</p><p>④a[i]a[i]在，b[j]b[j]在 max=f[i−1][j−1]+1max=f[i−1][j−1]+1;</p><p>实际上，在计算时，①包含在②和③的情况中，所以①不用考虑</p><p>然后考虑本题</p><p>设dp(i,j)表示第一个字符串A的前i位和第二个字符串B的前j位的答案，且A[i],B[j]分别 属于a,b(换句话说，dp(i,表示的情况是以A[i,B[]作为a,b的结尾时的最大的f(a,b)</p><p><strong>状态转移方程</strong><br>if (a[i - 1] != b[j - 1])<br>f[i][j] = max(f[i - 1][j] - y, max(f[i][j - 1] - z, - y - z));<br>else<br>f[i][j] = max(max(f[i - 1][j] - y, f[i][j - 1] - z), max(x - y - z, f[i - 1][j - 1] + x - y - z));</p><h3 id="代码-14">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-type">int</span> n, m, x, y, z;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">char</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y, &amp;z);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a, b);<br>    <br>    <span class="hljs-comment">// cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;</span><br>    <span class="hljs-comment">// cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] != b[j - <span class="hljs-number">1</span>])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j] - y, <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>] - z, - y - z));<br>            <span class="hljs-keyword">else</span><br>                f[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j] - y, f[i][j - <span class="hljs-number">1</span>] - z), <span class="hljs-built_in">max</span>(x - y - z, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + x - y - z));<br>                <br>            res = <span class="hljs-built_in">max</span>(res, f[i][j]);<br>        &#125;<br>        <br>        <br>    <span class="hljs-comment">// for (int i = 1; i &lt;= n; i ++ )</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for (int j = 1; j &lt;= m; j ++ )</span><br>    <span class="hljs-comment">//         cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;;</span><br>            <br>    <span class="hljs-comment">//     cout &lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D">D</h2><h3 id="题意分析-13">题意分析</h3><p>一个环被m个点均分，有3根指针指向这些点，需要依次拨动某一个指针使其指向第a1，a2，…，an个点，不能连续两次拨动同一个指针（拨动距离为0也算拨动）。求拨动的最小总距离。</p><p>dp[i][x][y][z]表示处理完ai之后，且三根指针此时分别指向x、y、z的情况下，拨动所需最少距离</p><p>我们可以发现以下性质：</p><ul><li>一定有一个指针指向$a_i$</li><li>从i=2开始，一定有一个指针指向$a_{i-1}$</li></ul><p>dp[i][j]（i≥2）表示处理完$a_i$后，三个指针一个指向$a_i$，一个指向$a_{i-1}$，一个指向j的情况下，拨动所需的最小距离。</p><p>状态转移：<br>因为不能连续转动同一个指针，所以我们只能转j和$a_{i-1}$的指针</p><p>初始化的时候直接初始化好i=2的数组，其他点初始化零</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">f[i + <span class="hljs-number">1</span>][j] = <span class="hljs-built_in">min</span>(f[i][j] + <span class="hljs-built_in">dis</span>(a[i - <span class="hljs-number">1</span>], a[i + <span class="hljs-number">1</span>]), f[i + <span class="hljs-number">1</span>][j]);<br>f[i + <span class="hljs-number">1</span>][a[i - <span class="hljs-number">1</span>]] = <span class="hljs-built_in">min</span>(f[i][j] + <span class="hljs-built_in">dis</span>(j, a[i + <span class="hljs-number">1</span>]), f[i + <span class="hljs-number">1</span>][a[i - <span class="hljs-number">1</span>]]);<br></code></pre></td></tr></table></figure><p>初始化代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>   a[<span class="hljs-number">0</span>] = <span class="hljs-number">0x3f3f3f3f</span>;<br>   <span class="hljs-type">int</span> i1 = <span class="hljs-built_in">dis</span>(x, a[<span class="hljs-number">1</span>]), j1 = <span class="hljs-built_in">dis</span>(y, a[<span class="hljs-number">1</span>]), k1 = <span class="hljs-built_in">dis</span>(z, a[<span class="hljs-number">1</span>]);<br>   <span class="hljs-type">int</span> i2 = <span class="hljs-built_in">dis</span>(x, a[<span class="hljs-number">2</span>]), j2 = <span class="hljs-built_in">dis</span>(y, a[<span class="hljs-number">2</span>]), k2 = <span class="hljs-built_in">dis</span>(z, a[<span class="hljs-number">2</span>]);<br>   <br>   f[<span class="hljs-number">2</span>][x] = <span class="hljs-built_in">min</span>(j1 + k2, j2 + k1);<br>   f[<span class="hljs-number">2</span>][y] = <span class="hljs-built_in">min</span>(i1 + k2, i2 + k1);<br>   f[<span class="hljs-number">2</span>][z] = <span class="hljs-built_in">min</span>(i1 + j2, i2 + j1);<br></code></pre></td></tr></table></figure><h3 id="代码-15">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> x, y, z;<br><span class="hljs-type">int</span> f[N][N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; y) <span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(x - y, y + m - x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-type">int</span> i1 = <span class="hljs-built_in">dis</span>(x, a[<span class="hljs-number">1</span>]), j1 = <span class="hljs-built_in">dis</span>(y, a[<span class="hljs-number">1</span>]), k1 = <span class="hljs-built_in">dis</span>(z, a[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> i2 = <span class="hljs-built_in">dis</span>(x, a[<span class="hljs-number">2</span>]), j2 = <span class="hljs-built_in">dis</span>(y, a[<span class="hljs-number">2</span>]), k2 = <span class="hljs-built_in">dis</span>(z, a[<span class="hljs-number">2</span>]);<br>    <br>    f[<span class="hljs-number">2</span>][x] = <span class="hljs-built_in">min</span>(j1 + k2, j2 + k1);<br>    f[<span class="hljs-number">2</span>][y] = <span class="hljs-built_in">min</span>(i1 + k2, i2 + k1);<br>    f[<span class="hljs-number">2</span>][z] = <span class="hljs-built_in">min</span>(i1 + j2, i2 + j1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-built_in">init</span>();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            f[i + <span class="hljs-number">1</span>][j] = <span class="hljs-built_in">min</span>(f[i][j] + <span class="hljs-built_in">dis</span>(a[i - <span class="hljs-number">1</span>], a[i + <span class="hljs-number">1</span>]), f[i + <span class="hljs-number">1</span>][j]);<br>            f[i + <span class="hljs-number">1</span>][a[i - <span class="hljs-number">1</span>]] = <span class="hljs-built_in">min</span>(f[i][j] + <span class="hljs-built_in">dis</span>(j, a[i + <span class="hljs-number">1</span>]), f[i + <span class="hljs-number">1</span>][a[i - <span class="hljs-number">1</span>]]);<br>        &#125;<br>        <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ ) res = <span class="hljs-built_in">min</span>(res, f[n][i]);<br>    <br>    <span class="hljs-comment">//  for (int i = 1; i &lt;= n; i ++ )</span><br>    <span class="hljs-comment">//  &#123;</span><br>    <span class="hljs-comment">//     for (int j = 1; j &lt;= m; j ++ )</span><br>    <span class="hljs-comment">//         cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; endl;</span><br>    <span class="hljs-comment">//  &#125;</span><br>        <br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="H">H</h2><h3 id="题意分析-14">题意分析</h3><p>一棵树上有权值为1或-1的节点，求包含树上某个(1~n)节点的连通块的最大权值和</p><p>dp[u]=c[u]+ ∑(所有大于0的dp[v])</p><p>遍历这棵树，从根节点出发，在回溯的时候用上式更新dp[u]的值就可以求出根节点的最大权值和</p><p>此时根节点被解决了，但是以每个点为根都来一次上述算法时间复杂度为O(n^2)，需要考虑更快的算法</p><p>可以发现，每次换根的思路只有，旧儿子有没有给旧父亲贡献，如果有则减掉。旧父亲先更新为新儿子，新儿子dp值大于0，则可以为新父亲贡献</p><p>我们可以递归地处理该树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//cout &lt;&lt; u &lt;&lt; &quot;: &quot; &lt;&lt; dp[u] &lt;&lt; &quot; &quot; &lt;&lt; dp[max(father, 0)] &lt;&lt; endl;</span><br>    res[u] = dp[u];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-type">int</span> t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (dp[j] &gt; <span class="hljs-number">0</span>) dp[u] -= dp[j], t1 = dp[j];<br>        <span class="hljs-keyword">if</span> (dp[u] &gt; <span class="hljs-number">0</span>) dp[j] += dp[u], t2 = dp[u];<br>        <span class="hljs-built_in">work</span>(j, u);<br>        <span class="hljs-keyword">if</span> (t1) dp[u] += t1;<br>        <span class="hljs-keyword">if</span> (t2) dp[j] -= t2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码-16">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dp[N], p[N], a[N], res[N];<br><span class="hljs-type">int</span> h[N], ne[M], e[M], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    dp[u] = a[u];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(j, u);<br>        <span class="hljs-keyword">if</span> (dp[j] &gt;= <span class="hljs-number">0</span>) dp[u] += dp[j];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//cout &lt;&lt; u &lt;&lt; &quot;: &quot; &lt;&lt; dp[u] &lt;&lt; &quot; &quot; &lt;&lt; dp[max(father, 0)] &lt;&lt; endl;</span><br>    res[u] = dp[u];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-type">int</span> t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (dp[j] &gt; <span class="hljs-number">0</span>) dp[u] -= dp[j], t1 = dp[j];<br>        <span class="hljs-keyword">if</span> (dp[u] &gt; <span class="hljs-number">0</span>) dp[j] += dp[u], t2 = dp[u];<br>        <span class="hljs-built_in">work</span>(j, u);<br>        <span class="hljs-keyword">if</span> (t1) dp[u] += t1;<br>        <span class="hljs-keyword">if</span> (t2) dp[j] -= t2;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">if</span> (x) a[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> a[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>        <span class="hljs-built_in">add</span>(x, y), <span class="hljs-built_in">add</span>(y, x);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, res[i]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I">I</h2><h3 id="题意分析-15">题意分析</h3><p>区间DP板题</p><p>异或的性质如下</p><ol><li>A^B=B^A</li><li>A^(B^C)=(A^B)^C</li><li>A^A=0</li><li>A^0=A</li><li>A^B^B=A^0=A</li></ol><p>我们用b(i, j) 代表区间的异或和 则有</p><p>b[i][j]=b[i][j-1]^b[i+1][j]</p><p>我们可以采用区间DP的方法来处理该问题</p><p>状态转移方程如下：（f初始化为上面提到的b）</p><p>f[l][r] = max(f[l][r], max(f[l + 1][r], f[l][r - 1]));</p><h3 id="代码-17">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-type">int</span> n, q;<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;f[i][i]);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt; n; len ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len &lt;= n; l ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len;<br>            f[l][r] = f[l + <span class="hljs-number">1</span>][r] ^ f[l][r - <span class="hljs-number">1</span>];<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt; n; len ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len &lt;= n; l ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len;<br>            f[l][r] = <span class="hljs-built_in">max</span>(f[l][r], <span class="hljs-built_in">max</span>(f[l + <span class="hljs-number">1</span>][r], f[l][r - <span class="hljs-number">1</span>]));<br>        &#125;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);<br>    <span class="hljs-keyword">while</span> (q -- )<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[l][r]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="L">L</h2><h3 id="题意分析-16">题意分析</h3><p>转换一下就是求最长上升子序列 然后n-答案乘以w就是要求的东西</p><p>f[i] 用来存储长度为 i+1 的最长上升子序列结尾的最小值，可证明 f 是单调递增的，即对于长度为 x 的最长上升子序列的结尾最小值 w 和 长度为 y 的最长上升子序列的结尾最小值 v，如果 x &lt; y 则必然存在 w &lt; v。证明见<br>g[i] 用于存储以当前数 a[i] 结尾的最长上升子序列的长度。<br>cnt：表示最长上升子序列的长度，初始值为 0<br>算法步骤：</p><p>始终要记得 f 数组和 g 数组的含义</p><p>初始化 f<a href="f%5B0%5D">cnt ++ </a> = a[0], g[0] = 1</p><p>下标从 1 开始遍历数组 a<br>如果当前数大于目前上升子序列结尾的最小值即 a[i] &gt; f[cnt - 1] 时，直接把 a[i] 加入到 f 数组中，长度 + 1（cnt + 1），并作为当前最长上升子序列新的结尾，同时更新 g[i] = cnt。<br>否则 a[i] &lt;= f[cnt - 1]，此时需要从 f 数组中找到第一个大于等于 a[i] 的数，假设它的下标为 k，那么以下标 kk 结尾的最长上升子序列的长度为 k+1，更新长度为 k+1 的最长上升子序列的结尾最小值为 a[i]。<br>由于 ff 数组是单调的，所以可以使用二分在 O(long)O(long) 的时间内找到 kk 然后更新最小值，即f[k] = a[i]，同时更新 g[i] = k + 1;<br>最后要输出序列，只需从后往前扫描 gg 数组，如果 g[i] == cnt 则将其加入到答案中，且 cnt --。</p><p>时间复杂度 $O(nlogn)$</p><h3 id="代码-18">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> w;<br><span class="hljs-type">int</span> a[N], f[N], q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lld&quot;</span>, &amp;n, &amp;w);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]), a[i] -= i;<br><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &lt;= a[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);<br>        q[r + <span class="hljs-number">1</span>] = a[i];<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = (n - len) * w;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="M">M</h2><h3 id="题意分析-17">题意分析</h3><p>我们把比相邻位置大的叫山峰，小的叫山谷。</p><p>如果我们设f[i][j]表示长度为i的序列(1~i的排列)，第一个是山峰且值为j的的方案数.g[i][j]为第一个是山谷的方案数</p><p>那么f[i][j]=$\sum_{k&lt;j}$ g[i-1][k]<br>意义：只需要在第一个为值&lt; j 的山谷前加一个j就能变成第一个是山峰</p><p>前缀和优化， f[i][j]表示第一个值为[1,j]的方案数</p><p>f[i][j]=f[i][j-1]+g[i-1][j-1]</p><p>由于对称性 f[i][j]=g[i][i-j+1]</p><h3 id="代码-19">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4510</span>;<br><br><span class="hljs-type">int</span> n, mod;<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;mod);<br>    <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i;  j ++ )<br>            f[i][j] = (f[i][j - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][i - j]) % mod;<br>            <br>    <span class="hljs-comment">// for (int i = 1; i &lt;= n; i ++ )</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for (int j = 1; j &lt;= i; j ++ )</span><br>    <span class="hljs-comment">//         cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;;</span><br>            <br>    <span class="hljs-comment">//     cout &lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (f[n][n] * <span class="hljs-number">2</span>) % mod);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="O">O</h2><h3 id="题意分析-18">题意分析</h3><p>在完全背包中,通过两个状态转移方程：<br>f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w , f[i-1,j-2v]+2w , f[i-1,j-3v]+3w, …)<br>f[i , j-v]= max( f[i-1,j-v] , f[i-1,j-2v] + w, f[i-1,j-2v]+2w , …)</p><p>通过上述比较，可以得到 f[ i ][ j ] = max(f[ i - 1 ][ j ],f[ i ][ j - v ] + w)。</p><p>再来看下多重背包,<br>f[i , j ] = max( f[i-1,j] ,f[i-1,j-v]+w ,f[i-1,j-2v]+2w ,… f[i-1,j-Sv]+Sw, )<br>f[i , j-v]= max( f[i-1,j-v] ,f[i-1,j-2v]+w, … f[i-1,j-Sv]+(S-1)w, f[i-1,j-(S+1)v]+Sw )</p><p>怎么比完全背包方程比较就多出了一项?<br>其实，一般从实际含义出发来考虑即可，这里是在分析f[i,j-w]这个状态的表达式，首先这个状态的含义是 从前i个物品中选，且总体积不超过j-w的最大价值， 我们现在最多只能选s个物品，因此如果我们选s个第i个物品，那么体积上就要减去 s * v,价值上就要加上s * w，那更新到状态中去就是 f[i - 1, j - v - s * v] + s * w。</p><p>那为什么完全背包不会有最后一项？<br>完全背包由于对每种物品没有选择个数的限制，所以只要体积够用就可以一直选，没有最后一项。</p><p>我们首先确认三点：</p><p>（1）我们知道转化成01背包的基本思路就是：判断每件物品我是取了你好呢还是不取你好。</p><p>（2）我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。</p><p>（3）这里多重背包问的就是每件物品取多少件可以获得最大价值。</p><p>分析：</p><p>如果直接遍历转化为01背包问题，是每次都拿一个来问，取了好还是不取好。那么根据数据范围，这样的时间复杂度是O(n^3),也就是1e+9，这样是毫无疑问是会TLE的。</p><p>假如10个取7个好，那么在实际的遍历过程中在第7个以后经过状态转移方程其实已经是选择“不取”好了。现在，用二进制思想将其分堆，分成k+1个分别有2^k个的堆，然后拿这一堆一堆去问，我是取了好呢，还是不取好呢，经过dp选择之后，结果和拿一个一个来问的结果是完全一样的，因为dp选择的是最优结果，而根据第二点任意一个实数都可以用二进制来表示，如果最终选出来10个取7个是最优的在分堆的选择过程中分成了2^0=1,2^1=2,2^2=4,10 - 7 = 3 这四堆，然后去问四次，也就是拿去走dp状态转移方程，走的结果是第一堆1个，取了比不取好，第二堆2个，取了比不取好，第三堆四个，取了比不取好，第四堆8个，取了还不如不取，最后依旧是取了1+2+4=7个。</p><p>如果仍然不是很能理解的话，取这样一个例子:要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次</p><p>二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,…512分到10个箱子里，那么由于任何一个数字x ∈[1,1024]<br>都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 。</p><p>这样利用二进制优化，时间复杂度就从O(n^3)降到O(n^2logS),从4<em>10^9降到了2</em>10^7。</p><h3 id="代码-20">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>LL f[N], w[N], v[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        LL a, b, s;<br>        cin &gt;&gt; b &gt;&gt; a &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br>    n = cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="X">X</h2><h3 id="题意分析-19">题意分析</h3><p>修改边权使得根节点到每个叶节点的时间一样</p><p>修改时间，一定要离根节点越近越好</p><p>我们设 f[x] 表示从当前点到它的后代里的最长距离，那么对于每一条边，需要增加的距离就是</p><p>f[x]-f[e [i]]-w[i]</p><h3 id="代码-21">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-type">int</span> n, root;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> d = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>;<br>        d = <span class="hljs-built_in">max</span>(d, <span class="hljs-built_in">dfs</span>(j, u) + w[i]);<br>        f[u] = <span class="hljs-built_in">max</span>(f[u], d);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// cout &lt;&lt; u &lt;&lt; &quot; -&gt; &quot; &lt;&lt; j &lt;&lt; &quot;: &quot; &lt;&lt; f[u] - f[j] - w[i] &lt;&lt; endl;</span><br>        <span class="hljs-built_in">work</span>(j, u);<br>        res += (f[u] - f[j] - w[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;root);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-built_in">work</span>(root, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-comment">// for (int i = 1; i &lt;= n; i ++ )</span><br>    <span class="hljs-comment">//     cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Z">Z</h2><h3 id="题意分析-20">题意分析</h3><p>01 背包问题板题</p><p>1）状态f[i][j]定义：前 ii 个物品，背包容量 jj 下的最优解（最大价值）：</p><p>当前的状态依赖于之前的状态，可以理解为从初始状态f[0][0] = 0开始决策，有 NN 件物品，则需要 NN 次决 策，每一次对第 ii 件物品的决策，状态f[i][j]不断由之前的状态更新而来。<br>（2）当前背包容量不够（j &lt; v[i]），没得选，因此前 ii 个物品最优解即为前 i−1i−1 个物品最优解：</p><p>对应代码：f[i][j] = f[i - 1][j]。<br>（3）当前背包容量够，可以选，因此需要决策选与不选第 ii 个物品：</p><p>选：f[i][j] = f[i - 1][j - v[i]] + w[i]。<br>不选：f[i][j] = f[i - 1][j] 。<br>我们的决策是如何取到最大价值，因此以上两种情况取 max() 。</p><p>将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。</p><p>为什么可以这样变形呢？我们定义的状态f[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。</p><p>（1）状态f[j]定义：NN 件物品，背包容量j下的最优解。</p><p>（2）注意枚举背包容量j必须从m开始。</p><p>（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。</p><p>（4）例如，一维状态第i轮对体积为 33 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1][4]，但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i][4]。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1][4]。</p><p>（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</p><p>状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i]</p><h3 id="代码-22">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">50010</span>, N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> f[M], w[N], v[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[m]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018年提高组题解</title>
      <link href="/2022/05/08/NOIP2018%E5%B9%B4%E6%8F%90%E9%AB%98%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/08/NOIP2018%E5%B9%B4%E6%8F%90%E9%AB%98%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.4与课后课程笔记</title>
      <link href="/2022/05/08/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1-4%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/05/08/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1-4%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成电讲坛观后感</title>
      <link href="/2022/05/08/%E6%88%90%E7%94%B5%E8%AE%B2%E5%9D%9B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2022/05/08/%E6%88%90%E7%94%B5%E8%AE%B2%E5%9D%9B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1>成电讲坛观后感</h1><p>在成电讲坛中，我开阔了我的视野，在社会各界的大咖身上获得了宝贵的知识和经验，受益终身。</p><p>杨教练为大家播放了世界顶级冲浪运动员的冲浪视频，冲浪运动的力量与美感，人类与浪花的博弈与共生令同学们沉醉。冲浪运动同滑板和滑雪有许多共同之处——最显著的地方即是三个运动都需要一块木板。冲浪运动在夏威夷真正起源，作为一项严肃的运动保有其独特的宗教意义，而古老的文化作为竞技运动和生活方式影响着现代人。接着，杨教练介绍了中国冲浪项目的起源和发展。上世纪六十年代冲浪运动传入亚洲，七十年代传入中国。中国的冲浪项目起步虽晚，但是后劲十足。2010年我国就举办了第一届国际冲浪赛；2017年中国冲浪国家队成立，国家队培训基地揭牌；21年国家管理体系建立，冲浪运动在我国的发展如火如荼。最后，杨教练介绍了国家冲浪体系。体系分为教练员体系和学员体系。</p><p>周文彰教授在社会主义的经典构想和新中国的初期探索，社会主义初级阶段和党的基本路线，中国特色社会主义一创立就成为党的旗帜，中国特色社会主义在实践中不断发展，习近平新时代中国特色社会主义思想和中国特色社会主义新时代以及做中国特色社会主义得到奋斗者六个方面生动的诠释了中国特色社会主义的发展历程，讲座高屋建瓴，从一定高度和深度对中国特色社会主义的历史脉络进行了细致的分析和讲解，我从中收益匪浅。</p><p>尧教授讲到，智力主要分为流体智力与晶体智力。流体智力主要来源于遗传，25岁左右就会逐渐降低；而晶体智力主要通过学习获得，直到65岁左右才会下降。因此“学习改变人生”也不是没有道理，同时尧教授也希望同学们“活到老，学到老”。脑智是可以调控的，尧教授也为同学们分享了几个调控脑智的方法，包括音乐、学习、药物和物理干预。随后尧教授总结道：“生物智能的核心原理是大脑可塑性，而大脑是一个复杂的系统，我们可以通过多样的、内在的、外部的、局部的、全面的综合干预来调控脑智。但这样的干预离不开科学的把控，需要建立在评估的基础上，趋利避害，辩证统一。”</p><p>“收藏其实很简单”，樊馆长从人生中第一个藏品——自己幼儿园时期的成绩单讲起，围绕收藏的张张老照片，生动地向同学们介绍了自己波折、丰富又充满趣味的人生经历，以及最终是如何走向收藏、走向博物馆建设的道路。樊馆长回顾自己的人生经历时讲到，相比于“不想当将军的兵不是好兵”而言，他更倾向“不想当副班长的兵不是好兵”。他认为人确实要有“将军”的梦想，但更要有层次的设定目标，一步一个目标才能走得更成功。</p><p>“未来10年，将是世界经济新旧动能转换的关键10年”，于施洋教授以习近平总书记的讲话为引，提出了国家建设全国一体化的国家大数据中心的伟大目标。“东数西算”，正是在数据要素参与分配的大环境下，为促进东西部算力资源优势互补和数据资源汇聚流通而提出的大工程。于施洋用详实的数据，分析了算力在国家经济发展、企业运作中的重要作用，并提出数据、算力的大爆炸促进5G时代分布式人工智能体系发展的智能大爆炸的展望。</p><p>我们跟随谢云宁校友一起探索星海处的快捷星门，人类仰望太空之时，就注定我们将不再平凡，科幻是科学的翅膀，借助于它，我们平凡人也可以挣脱地心引力，在讲座的最后，谢云宁勉励同学们可以多读些科幻作品，多看点科幻电影，像哆啦A梦一般打开科幻世界的大门。同时他也希望科幻作品可以帮助同学们开阔视野，也为我们留下一个永远的心灵的慰藉。</p><p>最后希望自己也能像讲座的大咖一样，努力学习知识，将来好好报效祖国，回馈社会。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训图论题解</title>
      <link href="/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>把之前写的题解上传到博客上</p><h1><a href="http://121.48.165.90/contest/170/problem/A">A题</a></h1><h2 id="题意分析-32">题意分析</h2><p>求全局最小割</p><h2 id="解题思路">解题思路</h2><p>Stoer_Wagner板题<br>Stoer_Wagner<br>每次在当前的无向图 G( V , E ) 中不断维护一个点集 A ,开始点集 A 包含一个任选的点 a . 当 A ≠ V 时选取属于V但不属于A且最大的点 v 加入点集 A ，直到 A=V 时结束。 此时令倒数第二次加入A的点为 s ，最后一次加入的点为 t ，则s-t最小割为割 ( A-{t} , {t} ) ，此时的全局最小割即为操作中的 s-t 最小割的最小值。 总的复杂度为$O((E+V)logV)$</p><h2 id="代码-34">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">550</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> edge[N][N], dist[N];<br><span class="hljs-type">bool</span> vis[N], bin[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">contract</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;s, <span class="hljs-type">int</span> &amp;t)</span>                        </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <br>    <span class="hljs-type">int</span> i, j, k, mincut, maxc;<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        k = <span class="hljs-number">-1</span>; maxc = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<span class="hljs-keyword">if</span>(!bin[j] &amp;&amp; !vis[j] &amp;&amp; dist[j] &gt; maxc)<br>        &#123;<br>            k = j;  maxc = dist[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> mincut;<br>        s = t;  t = k;<br>                mincut = maxc;<br>        vis[k] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-keyword">if</span>(!bin[j] &amp;&amp; !vis[j])<br>            dist[j] += edge[k][j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> mincut;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Stoer_Wagner</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mincut, i, j, s, t, ans;<br>    <span class="hljs-keyword">for</span>(mincut = inf, i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>    &#123;<br>        ans = <span class="hljs-built_in">contract</span>(s, t);<br>                bin[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(mincut &gt; ans)mincut = ans;<br>        <span class="hljs-keyword">if</span>(mincut == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-keyword">if</span>(!bin[j])<br>            edge[s][j] = (edge[j][s] += edge[j][t]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mincut;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(edge, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(edge));<br>    <span class="hljs-built_in">memset</span>(bin, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(bin));<br>    <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>        <span class="hljs-keyword">while</span> (m --)<br>        &#123;<br>            <span class="hljs-type">int</span> a, b, c;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>            edge[a][b] += c, edge[b][a] += c;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">Stoer_Wagner</span>());<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/C">C题</a></h1><p>双端队列+广度优先搜索<br>首先把电路板上每一个格子点(交叉点)看作无向图中的节点,我们认为两个节点x和y是某个小方格的两个对角,那么如果说x和y的线段’',那么我们可以认为边权为0,反之如果x和y线段是’/’,那么我们的边权视为1,说明要旋转一次才能够连上.<br>现在我们得到了一张完美的边权0或1的无向图,那么和普通广搜一样,我们唯一的改变就是,如果说当前新状态的边权为0,那么我们就放到队头先走,因为我们要满足两端性和单调性,而为了这个单调性,如果说当前新状态边权为1,那么我们就只能压入到队尾.<br>具体小细节就看代码吧.hh</p><h2 id="代码-35">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br><br>    <span class="hljs-type">char</span> cs[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;\\/\\/&quot;</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> ix[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, iy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop_front</span>();<br><br>        <span class="hljs-keyword">if</span> (t.x == n &amp;&amp; t.y == m) <span class="hljs-keyword">return</span> d[n][m];<br><br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>            <span class="hljs-type">int</span> ca = t.x + ix[i], cb = t.y + iy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt; n || b &lt; <span class="hljs-number">0</span> || b &gt; m) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> w = g[ca][cb] != cs[i];<br>            <span class="hljs-type">int</span> dist = d[t.x][t.y] + w;<br>            <span class="hljs-keyword">if</span> (dist &lt; d[a][b])<br>            &#123;<br>                d[a][b] = dist;<br>                <span class="hljs-keyword">if</span> (!w) q.<span class="hljs-built_in">push_front</span>(&#123;a, b&#125;);<br>                <span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);<br><br>        <span class="hljs-keyword">if</span> (n + m &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO SOLUTION\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">bfs</span>());<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/E">E题</a></h1><h2 id="题意分析-33">题意分析</h2><p>多次询问从1号节点到给定终点的简单路径上的最小点权</p><h2 id="求解思路">求解思路</h2><p>首先考虑如果图就是一棵树，显然此时路径唯一，因此只需dfs一遍即可。  然后我们可以发现，每个点到根的简单路径可能经过的点只可能是路径上点双上的点。因此我们可以考虑用tarjan算法求解点双，显然，在求完点双后，如果用点来代替点双，那么图就可以转化成树  因此我们可以离线询问，在转化后的树上直接dfs一遍即可求解。</p><h2 id="代码-36">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m, q, cnt;<br><span class="hljs-type">int</span> w[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> dfn[N * <span class="hljs-number">2</span>], low[N], ts, stk[N], tp;<br><span class="hljs-type">int</span> idf[N * <span class="hljs-number">2</span>], f[N * <span class="hljs-number">2</span>], siz[N * <span class="hljs-number">2</span>], dep[N * <span class="hljs-number">2</span>], son[N * <span class="hljs-number">2</span>], top[N * <span class="hljs-number">2</span>], ans[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> st[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; G[N], T[N * <span class="hljs-number">2</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    low[u] = dfn[u] = ++ ts;<br>    stk[++ tp] = u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!dfn[v])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(v);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>            <br>            <span class="hljs-keyword">if</span> (low[v] == dfn[u])<br>            &#123;<br>                cnt ++ ;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x != v; -- tp)<br>                &#123;<br>                    x = stk[tp];<br>                    T[cnt].<span class="hljs-built_in">push_back</span>(x);<br>                    T[x].<span class="hljs-built_in">push_back</span>(cnt);<br>                   <span class="hljs-comment">// printf(&quot;    BCC #%d has vertex #%d\n&quot;, cnt - n, x);</span><br>                &#125;<br>                T[u].<span class="hljs-built_in">push_back</span>(cnt);<br>                T[cnt].<span class="hljs-built_in">push_back</span>(u);<br>                <span class="hljs-comment">//printf(&quot;    BCC #%d has vertex #%d\n&quot;, cnt - n, u);</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    ans[u] = <span class="hljs-built_in">min</span>(w[u], ans[fa]);<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;u:&quot; &lt;&lt; u &lt;&lt; endl;</span><br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (u &gt; n)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : T[u])<br>            ans[u] = <span class="hljs-built_in">min</span>(w[x], ans[u]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : T[u])<br>        <span class="hljs-keyword">if</span> (!st[x])<br>            <span class="hljs-built_in">dfs</span>(x, u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> w);<br>    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> ans);<br>    <br>     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>     <br>     cnt = n;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>     &#123;<br>         <span class="hljs-type">int</span> a, b;<br>         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>         <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> || b &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>         a = -a, b = -b;<br>         G[a].<span class="hljs-built_in">push_back</span>(b);<br>         G[b].<span class="hljs-built_in">push_back</span>(a);<br>     &#125;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>     <br>     <span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>);<br>     <br>    <span class="hljs-comment">//  for (int i = 1; i &lt;= cnt; i ++ )</span><br>    <span class="hljs-comment">//     cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; w[i] &lt;&lt; endl;</span><br>     <br>     <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>     <br>    <span class="hljs-comment">//   for (int i = 1; i &lt;= cnt; i ++ )</span><br>    <span class="hljs-comment">//     cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; ans[i] &lt;&lt; endl;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[x]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/F">F题</a></h1><h2 id="题意分析-34">题意分析</h2><p>本题是一个差分约束的简单题<br>差分约束<br>形如$x_i \leq x_j + c_k$的不等式组，假设我们存在 $j \xrightarrow{c} i$ 如果求得是最短路一定存在$dist_i \leq dist_j + c$, 我们在这个图上随便找一个起点，然后求一下每个点到起点的最短距离，每一个差分约束问题都等价于一个单源最短路问题，<br>差分约束：<br>步骤：<br>[1]首先将每个不等式$x_i \leq x_j + c_k$, 转换成一条从$x_j$走到$x_i$，长度为$c_k$的一条边<br>[2]找到一个超级源点，使得该源点一定可以遍历到所有边<br>[3]从源点求一遍单源最短路,注意如果在图中存在负环，说明方程矛盾,也就是不等式无解，等价于图中有负环<br>有负环，则方程无解，无负环则$dist_i$是方程组的一个解<br>如果是最长路,原方程$x_i \leq x_j + c_k$不等号方向改变变为$x_j \geq x_i - c_k$，$i \xrightarrow{-c} j$ 正环表示无解.</p><ol><li>可以求不等式组的可行解 源点需要满足的条件：从源点出发，一定可以走到所有的边</li><li>如何求最大值或者最小值<br>结论1：如果求的是最小值，则应该求最长路，如果求的是最大值，则应该求最短路。<br>求最值的时候一定会告诉我们一个绝对值<br>问题1：如何转化 $x_i \leq c$,其中c是一个常数，这类不等式<br>方法：建立一个超级源点，0，然后建立$0\xrightarrow{c} i$的边即可<br>以求$x_i$的最大值为例，所有从$x_i$出发构成的不等式链$x_i\leq x_j+c_1\leq x_k+c_1+c_2… \leq x_0(c_0)+c_1+c_2 … $所计算出的上界，最终$x_i$的最大值应该等于所有上界的最小值。我们可以发现每一条这样的不等式就是从$0 \to i$走过的最短路径</li></ol><h2 id="解题思路-2">解题思路</h2><p>构造不等式<br>$a_u\leq a_v+w$也就是形成$v\xRightarrow{w} u$边<br>$a_i\leq a_0(0)+w$<br>有前面的分析知，采用最短路，如果存在负环，则说明无解。</p><h2 id="代码-37">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e3</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e4</span> +<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> dist[N], cnt[N], q[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">1</span>;<br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (hh != tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[ -- tt];<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    q[tt ++ ] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;b, &amp;a, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/I">I题</a></h1><h2 id="题意分析-35">题意分析</h2><p>本题是2-SAT算法的板题<br>2-SAT算法思想<br>一般的SAT算法为NP完全问题，但是对于2-SAT算法有比较好的解决方法。<br>我们采用图论的方法解决2-SAT问题，我们用$x_i$表示$x_i=1$ 用$\neg x_i$表示$x_i=0$<br>我们可以发现$a\to b \Leftrightarrow \neg a∪$b<br>所以我们可以将所有的条件表示为$ a∪b \Leftrightarrow \neg a\to b $我们将这些所有的推导关系，对应到我们图论中的边<br>对于每个命题，他会对应两个点我们会建立$x 和 \neg x$</p><p>因此我们可以建立一个有向图，有向图里面的一个路径就代表我们的一个传递关系<br>下面我们讨论下何时无解，我们如果说从一个取值开始，如果$x_1\to … \to \neg x_1$ 并且$\neg x_1\to … \to x_1$,存在矛盾，此时一定无解。即如果$x_i与 \neg x_i$在同一个强连通分量中，则代表无解。<br>若任何一个上述条件不成立，是否一定有解，首先我们先来看一下如何判断第一个条件，我们可以用tarjan算法来做，然后看第二个问题，答案是一定有解，构造解的方式如下，我们可以枚举所有$x_i \neg x_i$,我们缩完点后，按照拓扑排序，我们直接看一下$x_i与 \neg x_i$在tarjan中的编号，谁更靠后，我们取哪个条件，这样的话就可以给出来一组解。</p><p>下面我们来证明一下这个构造方式的正确性</p><ol><li>我们给出的解每一个$x_i$只有一种值</li><li>对于每一个连通分量来说，如果我们选择了这个分量中的某个点，那必须选择该分量中的所有条件，如果我们选择了一个块，那么一定存在一个块与它里面的条件完全相反，因为$a\to b \Leftrightarrow \neg b \to \neg a$,原命题和逆否命题等价，我们不妨设一个块更靠后</li><li>a∪b一定成立，假设$\neg a $<br>意味着$\neg a$在后面一定取到b<br>所以一定满足</li></ol><h2 id="代码-38">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dfn[N], low[N], ts, stk[N], top;<br><span class="hljs-type">int</span> id[N], cnt;<br><span class="hljs-type">bool</span> ins[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[u] = low[u] = ++ ts;<br>    stk[ ++ top] = u, ins[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ins[j])<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (low[u] == dfn[u])<br>    &#123;<br>        cnt ++ ;<br>        <span class="hljs-type">int</span> y;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            y = stk[top -- ], id[y] = cnt, ins[y] = <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">while</span> (y != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> i, j, a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;i, &amp;a, &amp;j, &amp;b);<br>        i -- , j -- ;<br>        <span class="hljs-built_in">add</span>(i * <span class="hljs-number">2</span> + !a, j * <span class="hljs-number">2</span> + b);<br>        <span class="hljs-built_in">add</span>(j * <span class="hljs-number">2</span> + !b, i * <span class="hljs-number">2</span> + a);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i ++ )<br>        <span class="hljs-keyword">if</span> (!dfn[i])<br>            <span class="hljs-built_in">tarjan</span>(i);<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">if</span> (id[i * <span class="hljs-number">2</span>] == id[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>])<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/J">J题</a></h1><h2 id="题意分析-36">题意分析</h2><p>tarjan板题<br>tarjan思想<br>Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p><ul><li>定义:<br>o DFN(u)为节点u 搜索的次序编号(时间戳);<br>o LOW(u)为u 或 u的子树能够追溯到的最早的栈中节点的次序号;<br>由定义可以得出，当 DFN(u)=LOW(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</li><li>算法：</li></ul><ol><li>当首次搜索到点u时DFN[u]=LOW[u]=time;</li><li>每当搜索到一个点，把该点压入栈顶;</li><li>当u和v有边相连时:<br>1）如果v不在栈中（树枝边），DFS(v)，并且LOW[u] = min{LOW(u),LOW(v)};<br>2）如果v在栈中（前向边/后向边），此时LOW[u] = min{LOW[u],DFN[v]}</li><li>当DFN[u]=LOW[u]时，将它以及在它之上的元素弹出栈，此时，弹出栈的结点构成一个强连通分量;</li><li>继续搜索，知道图被遍历完毕。<br>由于在这个过程中每个点只被访问一次，每条边也只被访问一次，所以Tarjan算法的时间复杂度是O(n+m).<br>2.2. 算法伪代码</li></ol><h2 id="本题具体步骤">本题具体步骤</h2><ol><li>建图。</li><li>dfs过程中按dfs序（时间戳）更新dfn数组，同时初始的low数组为dfn.</li><li>当前dfs对象为a，枚举与a相连的点b。   如果b已经搜索过则更新low[a]为low[a]和dfn[b]里面的小值。   如果b未搜索过，则搜索b,然后更新low[a]为low[a]和low[b]里面的小值。同时判断当前点是否为割点（low[b]&gt;=dfn[a]），当前边是否为桥（low[b]&gt;dfn[a]）。</li><li>维护一个栈，当扫描到割点时将栈中点弹出至b，并将这些点加入答案（割点不出栈但是统计至答案中）。</li><li>则极大点双连通分量数量可由4统计出。</li><li>极大点双连通分量包含边数的最大值则由每个极大点双统计。对于每个分量，枚举其中的点如果两点间有一条边则边数加1。 （注意，如果根节点只有一个儿子则不为割点）</li></ol><h2 id="代码-39">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> dfn[N], low[N], timestamp, stk[N], top;<br><span class="hljs-type">bool</span> cut[N], is_bridge[M];<br><span class="hljs-type">int</span> dcc_cnt, bridge_cnt, cut_cnt;<br>vector&lt;<span class="hljs-type">int</span>&gt; dcc[N];<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> g[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> from)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> son = <span class="hljs-number">0</span>;<br>    low[u] = dfn[u] = ++ timestamp;<br>    stk[ ++ top] = u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (i == (from ^ <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!dfn[j])<br>        &#123;<br>            son ++ ;<br>            <span class="hljs-built_in">tarjan</span>(j, i);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span> (low[j] &gt; dfn[u]) is_bridge[i] = <span class="hljs-literal">true</span>, is_bridge[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (low[j] &gt;= dfn[u])<br>            &#123;<br>                dcc_cnt ++ ;<br>                <span class="hljs-type">int</span> y;<br>                <span class="hljs-keyword">do</span><br>                &#123;<br>                    y = stk[top -- ];<br>                    dcc[dcc_cnt].<span class="hljs-built_in">push_back</span>(y);<br>                &#125;<span class="hljs-keyword">while</span> (y != j);<br>                dcc[dcc_cnt].<span class="hljs-built_in">push_back</span>(u);<br>                <br>                <span class="hljs-keyword">if</span> ((u == root &amp;&amp; son &gt; <span class="hljs-number">1</span>) || (u != root &amp;&amp; low[j] &gt;= low[u]))<br>                    cut[u] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != e[from])<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>        g[a][b] ++ ; g[b][a] ++ ;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> (root = <span class="hljs-number">1</span>; root &lt;= n; root ++ )<br>        <span class="hljs-keyword">if</span> (!dfn[root])<br>            <span class="hljs-built_in">tarjan</span>(root, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(dfn, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dfn);<br>    timestamp = top = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (cut[i])<br>            cut_cnt ++ ;<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i = i + <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> (is_bridge[i])<br>            bridge_cnt ++ ;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= dcc_cnt; k ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dcc[k].<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; dcc[k].<span class="hljs-built_in">size</span>(); j ++ )<br>                cnt += g[dcc[k][i]][dcc[k][j]];<br>        <br>            res = <span class="hljs-built_in">max</span>(res, cnt);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, cut_cnt, bridge_cnt, dcc_cnt, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/K">K题</a></h1><h2 id="题意分析-37">题意分析</h2><p>题意分析给定n个点，n-1条边，m个询问，询问两个节点之间的距离。</p><h2 id="注意事项">注意事项</h2><ul><li>无向图</li></ul><h2 id="解题思路-3">解题思路</h2><p>因为任意两个节点相互连通，而且有n-1条边，所有该图是一个树，我们将1号点看为根节点，然后求最近公共祖先，答案res = depth[a] + depth[b] - 2 * depth[p]，其中p为最近公共祖先<br>最近公共祖先<br>在一个有根树书里面，每个节点会有好几个祖先，为了一般化，我们把这个节点自己也是自己的祖先<br>向上标记法$O(n)$<br>我们先从一个点开始往上走走到根节点，标记自己走过的点，然后另一个点开始向上走，直到第一个碰到被标记的点，该点即为最近公共祖先<br>倍增法 预处理$O(nlogn)$ 查询O(logn)<br>预处理fa[i,j]，从i开始，向上走$2^j$步所能走到的节点 $0\leq j \leq logn$,可以采用递推的方式来做<br>首先当j=0，f(i,j)=i的父节点<br>当j&gt;0时，先跳$2^{j-1}$步，然后再跳先跳$2^{j-1}$步<br>即f(i,j)=f(f(i, j-1),j -1)<br>depth[i]表示深度，我们可以规定根节点的深度为1，下一层为2，深度为到根节点的距离加一<br>哨兵:如果从i开始跳$2^j$步会跳过根节点，那么fa[i,j]=0,depth[0]=0<br>求最近公共祖先的分两步：<br>[1]先将两个点跳到同一层,基于类似二进制拼凑的方式，假设x比y要深，他们差depth[x]-depth[y],只要我跳$2^k$步能跳到y前面，我就跳，否则就不跳<br>[2]让两个点同时往上跳，一直跳到它们的最近公共祖先的下一层<br>预处理$O(nlogn)$ 查询O(logn)</p><h2 id="代码-40">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-type">int</span> n, m, root = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> depth[N], fa[N][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> depth);<br>    depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[root] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = root;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (depth[j] &gt; depth[t] + <span class="hljs-number">1</span>)<br>            &#123;<br>                depth[j] = depth[t] + <span class="hljs-number">1</span>;<br>                q[ ++ tt] = j;<br>                fa[j][<span class="hljs-number">0</span>] = t;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">19</span>; k ++ )<br>                    fa[j][k] = fa[fa[j][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">19</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])<br>            a = fa[a][k];<br>            <br>    <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> a;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">19</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (fa[a][k] != fa[b][k])<br>        &#123;<br>            a = fa[a][k];<br>            b = fa[b][k];<br>        &#125;<br>        <br>    <span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n- <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-built_in">bfs</span>();<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(a, b);<br>        <span class="hljs-type">int</span> res = depth[a] + depth[b] - <span class="hljs-number">2</span> * depth[p];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/L">L题</a></h1><h2 id="题意分析-38">题意分析</h2><p>比较裸露，求最小生成树计数</p><h2 id="解题思路-4">解题思路</h2><p>我们发现对于所有最小生成树，每种边权的边数是一样的。<br>那就可以首先找到最小生成树，然后枚举每种边权w，把其它边权，在生成树里的边加上，然后求有几种方案选出边权为w的边，把他们加上，使得得到了一棵树。<br>然后乘起来。<br>那么这个方案数就可以用Matrix-Tree定理计算。<br>矩阵求行列式，基本方法就是高斯消元。</p><h2 id="代码-41">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">1005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">10000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P1 = <span class="hljs-number">1000000007</span>;<br><span class="hljs-function">ll <span class="hljs-title">pwr</span><span class="hljs-params">(ll x, ll y)</span></span>&#123;<br>        x %= P1;<br>        y = (y % (P1 - <span class="hljs-number">1</span>) + (P1 - <span class="hljs-number">1</span>)) % (P1 - <span class="hljs-number">1</span>);<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (y)&#123;<br>                <span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) ans = ans * x % P1;<br>                x = x * x % P1;<br>                y &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>&#125; e[MAXM];<br><span class="hljs-type">int</span> p[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fdrt</span><span class="hljs-params">(<span class="hljs-type">int</span> nw)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (p[nw] == nw) <span class="hljs-keyword">return</span> nw;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p[nw] = <span class="hljs-built_in">fdrt</span>(p[nw]);<br>&#125;<br><span class="hljs-type">int</span> a[MAXM * <span class="hljs-number">2</span>], asz;<br><span class="hljs-type">int</span> b[MAXN][MAXN];<br><span class="hljs-type">int</span> pos[MAXN];<br><span class="hljs-function">ll <span class="hljs-title">getdet</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span>&#123;<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= len; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (b[j][i])&#123;<br>                                <span class="hljs-built_in">swap</span>(b[i], b[j]);<br>                                ans = -ans;<br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>                        ll d = <span class="hljs-built_in">pwr</span>(b[i][i], <span class="hljs-number">-1</span>) * b[j][i] % P1;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= len; k++) b[j][k] = (b[j][k] - b[i][k] * d) % P1;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) ans = ans * b[i][i] % P1;<br>        <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;<br>        <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + m + <span class="hljs-number">1</span>, [&amp;](Edge u, Edge v)&#123;<br>                <span class="hljs-keyword">return</span> u.w &lt; v.w;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>                asz = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= m &amp;&amp; e[j].w == e[i].w; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(e[j].u) == <span class="hljs-built_in">fdrt</span>(e[j].v)) <span class="hljs-keyword">continue</span>;<br>                        a[++asz] = <span class="hljs-built_in">fdrt</span>(e[j].u);<br>                        a[++asz] = <span class="hljs-built_in">fdrt</span>(e[j].v);<br>                &#125;<br>                <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>);<br>                asz = <span class="hljs-built_in">unique</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>) - a - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= asz; u++)&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= asz; v++)&#123;<br>                                b[u][v] = <span class="hljs-number">0</span>;<br>                        &#125;<br>                &#125;<br>                <span class="hljs-comment">// cout &lt;&lt; &quot;asz &quot; &lt;&lt; asz &lt;&lt; &#x27;\n&#x27;;</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= m &amp;&amp; e[j].w == e[i].w; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(e[j].u) == <span class="hljs-built_in">fdrt</span>(e[j].v)) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-type">int</span> u1 = <span class="hljs-built_in">lower_bound</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>, <span class="hljs-built_in">fdrt</span>(e[j].u)) - a;<br>                        <span class="hljs-type">int</span> v1 = <span class="hljs-built_in">lower_bound</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>, <span class="hljs-built_in">fdrt</span>(e[j].v)) - a;<br>                        <span class="hljs-built_in">assert</span>(u1 != v1);<br>                        b[u1][u1]++;<br>                        b[v1][v1]++;<br>                        b[u1][v1]--;<br>                        b[v1][u1]--;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= m &amp;&amp; e[j].w == e[i].w; j++)&#123;<br>                        p[<span class="hljs-built_in">fdrt</span>(e[j].u)] = <span class="hljs-built_in">fdrt</span>(e[j].v);<br>                        i = j;<br>                &#125;<br>                <span class="hljs-type">int</span> lst = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= asz; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(a[j]) != a[j]) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (lst != <span class="hljs-number">-1</span>)&#123;<br>                                b[lst][lst]++;<br>                                b[j][j]++;<br>                                b[lst][j]--;<br>                                b[j][lst]--;<br>                        &#125;<br>                        lst = j;<br>                &#125;<br><br>                ll nm = (<span class="hljs-built_in">getdet</span>(asz - <span class="hljs-number">1</span>) % P1 + P1) % P1;<br>                ans = ans * nm % P;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(i) != <span class="hljs-built_in">fdrt</span>(<span class="hljs-number">1</span>)) ans = <span class="hljs-number">0</span>;<br>        cout &lt;&lt; (ans % P + P) % P &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/N">N题</a></h1><h2 id="题意分析-39">题意分析</h2><p>最小直径生成树<br>最小直径生成树<br>求解直径最小生成树，首先需要找到图的绝对中心，图的绝对中心可以存在于一条边上或某个结点上，该中心到所有点的最短距离的最大值最小。 到绝对中心距离最远的结点至少有两个。 令d(i,j)为(i,j)的最短路径长，跑个floyd。 图的绝对中心可能在某条边上，枚举每一条边w=(u,v)，假设图的绝对中心就在这条边上。那么距离 u 的长度为 x ，距离 v 的长度就是 w-x。 对于图中的任意一点 i ，图的绝对中心 c 到 i 的距离为 d(c,i)=min{ d(u,i)+x ,  d(v,i)+(w−x) }<br>随着图的绝对中心 c 在边上的改变会生成一个距离与 c 位置的函数图像。d(c,i)的函数图像是一个两条斜率相同的线段构成的折线段。<br>对于图上的任意一结点，图的绝对中心到最远距离结点的函数就写作  f=max{ d(c,i)}, i∈[1,n] 函数图像如下 并且这些折线交点中的最低点，横坐标就是图的绝对中心的位置。<br>记录 rk(i,j) 表示 i 到其他所有结点中第 j 小的那个结点。 对每条边分别处理 折线中的拐点最多有 n 个 把点按照 d(v,i) 从大到小依次枚举 记录 p 表示已经枚举的点中d(u,i)最大的 接下来枚举能产生新拐点当且仅当  d(u,i)&gt;d(u,p)  （因为已经按d(v,i)排过序了） 每个拐点都更新一次答案就好 总时间O(n^3)</p><h2 id="代码-42">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL INF = <span class="hljs-number">1e16</span>;<br><br><span class="hljs-type">int</span> n, m;<br>LL d[N][N], val[N], rk[N][N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    LL w;<br>&#125;edges[M];<br>LL res = INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> val[a] &lt; val[b];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">floyd</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) <br>    &#123;<br>      rk[i][j] = j;<br>      val[j] = d[i][j];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(rk[i] + <span class="hljs-number">1</span>, rk[i] + <span class="hljs-number">1</span> + n, cmp);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = <span class="hljs-built_in">min</span>(res, d[i][rk[i][n]] * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <br>  &#123;<br>    <span class="hljs-type">int</span> u = edges[i].a, v = edges[i].b;<br>    LL w = edges[i].w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = n, i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i -- ) <br>    &#123;<br>      <span class="hljs-keyword">if</span> (d[v][rk[u][i]] &gt; d[v][rk[u][p]]) <br>      &#123;<br>        res = <span class="hljs-built_in">min</span>(res, d[u][rk[u][i]] + d[v][rk[u][p]] + w);<br>        p = i;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i != j) d[i][j] = INF;<br>            <span class="hljs-keyword">else</span> d[i][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        LL c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        edges[i] = &#123;a, b, c&#125;;<br>        d[a][b] = d[b][a] = c;<br>    &#125;<br>    <br>    <span class="hljs-built_in">solve</span>();<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/O">O题</a></h1><h2 id="题意分析-40">题意分析</h2><p>求起点到其他所有点的最短路</p><h2 id="注意事项-2">注意事项</h2><ul><li>非负权值，有向道路</li></ul><h2 id="解题思路-5">解题思路</h2><p>dijkstra算法板子题，采用堆优化方法$O(nlogm)$</p><h2 id="代码-43">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;LL, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL INF = <span class="hljs-number">1e17</span>;<br><br><span class="hljs-type">int</span> n, m, S;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br>LL w[M];<br>LL dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, LL c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) dist[i] = INF;<br>    dist[S] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);<br>    <br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        PII t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> ver = t.y;<br>        <br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i])<br>            &#123;<br>                dist[j] = dist[ver] + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        LL c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (dist[i] == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dist[i]);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/Q">Q题</a></h1><h2 id="题意分析-41">题意分析</h2><p>有n个点排成一行，在第i,j 个点之间连边的代价为 |i-j| × D+Ai+Aj.求将它们连成一棵树的最小代价。<br>解题思路<br>如果这题的n&lt;=5000，那么我们就可以直接连边，然后跑一遍Prim算法便可获得答案。<br>先引入一个经典的性质：MST不可能包含一个环上的严格最大边。<br>考虑将所有点对半折开，左半部分和右半部分的建边分治处理，只考虑横跨两部分的建边。 若左半部分的点为j，右半部分的点为i。边权就可以转换成：（Ai + i × D) + (Aj - j × D)<br>既然 i 和 j 独立出来，那么只需要选出右半部分 min{Ai + i × D}所对应的i，选出左边半部分min{Aj  - j × D}所对应的j。 将 j与右半部分所有点连边，i同理。 那么这样就只有O(nlogn) 条边，然后用跑一遍最小生成树定理即可。</p><h2 id="代码-44">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">4e6</span> + <span class="hljs-number">10</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL INF = <span class="hljs-number">1e17</span>;<br><br><span class="hljs-type">int</span> n, m, cnt;<br>LL lmin[N], rmin[N], D;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    LL w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge</span>(l, mid); <span class="hljs-built_in">merge</span>(mid + <span class="hljs-number">1</span>, r);<br>    <br>    LL Lmin = INF, Rmin = INF;<br>    <span class="hljs-type">int</span> lid, rid;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= mid; i ++ )<br>        <span class="hljs-keyword">if</span> (Lmin &gt; lmin[i])<br>            Lmin = lmin[i], lid = i;<br>            <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i ++ )<br>        <span class="hljs-keyword">if</span> (Rmin &gt; rmin[i])<br>            Rmin = rmin[i], rid = i;<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= mid; i ++ )<br>        edges[cnt ++ ] = &#123;rid, i, Rmin + lmin[i]&#125;;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i ++ )<br>        edges[cnt ++ ] = &#123;lid, i, Lmin + rmin[i]&#125;;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x != p[x]) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lld&quot;</span>, &amp;n, &amp;D);<br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        LL a;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a);<br>        lmin[i] = (LL)a - i * D;<br>        rmin[i] = (LL)a + i * D;<br>    &#125;<br>    <br>    <span class="hljs-built_in">merge</span>(<span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">sort</span>(edges, edges + cnt);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b;<br>        LL w = edges[i].w;<br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)<br>        &#123;<br>            res += w;<br>            p[a] = b;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/R">R题</a></h1><h2 id="最小有向树形图">最小有向树形图</h2><p>1 无环<br>2 每个点入度为1<br>朱刘算法<br>1 贪心的从每个点的所有入边中找一条权值最小的边<br>2 从选出的边中判断是否存在环<br>2.1 不存在环，结束，把所有边权值加上作为答案<br>2.2 存在环，进入第3步<br>3 将所有环缩点，构造新图G’，缩点前把所有边权值加上<br>3.1 环内的边 2-&gt;3 3-&gt;4 4-&gt;2<br>删去<br>3.2 终点在环内的边 1-&gt;4 1-&gt;2<br>权值 w’ = w - 终点入边权值<br>w[1-&gt;4]’ = w[1-&gt;4] - w[3-&gt;4] = 5 - 1 = 4<br>w[1-&gt;2]’ = w[1-&gt;2] - w[4-&gt;2] = 4 - 2 = 2<br>3.3 其他边 4-&gt;5<br>不变<br>每次缩一次点,点数最少-1,所以总共最多迭代n次算法结束。</p><h2 id="证明：">证明：</h2><p>首先有性质：<br>1 环中的边一定至少要去掉一条边<br>2 ⭐ 一定存在一个最优解，只去一条边<br>假设去了两条环内边，则说明环内有两个点的入边权值变大<br>3 缩点前和缩点后的树形图的最小权值相等–则要求G的最小权和==G’的最小权和<br>任给G中的一个树形图一定能找到一种变换变换到对应的G’<br>任给G’中的一个树形图一定能找到对应的G</p><h2 id="代码-45">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">101</span>, M = <span class="hljs-number">10001</span>, INF = <span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-type">int</span> n, m, s, u[M], v[M], w[M], id[N], pre[N], minw[N], src, idx;<br><span class="hljs-type">int</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">zhuliu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    w[<span class="hljs-number">0</span>] = INF;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(pre));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>            <span class="hljs-keyword">if</span>(u[i] != v[i] &amp;&amp; (!pre[v[i]] || minw[v[i]] &gt; w[i]))<br>            &#123;<br>                pre[v[i]] = u[i];<br>                minw[v[i]] = w[i];<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(i != s &amp;&amp; !pre[i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(id, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(id));<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        vis[s] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(i != s)&#123;<br>                ret += minw[i];<br>                <span class="hljs-type">int</span> j = i;<br>                <span class="hljs-keyword">while</span>(!vis[j])&#123;<br>                    vis[j] = i;<br>                    j = pre[j];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j != s &amp;&amp; vis[j] == i)&#123;<br>                    id[j] = ++idx;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pre[j]; k != j; k = pre[k])<br>                        id[k] = idx;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(idx == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(!id[i])<br>                id[i] = ++idx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (id[u[i]] != id[v[i]])<br>                w[i] -= minw[v[i]];<br>            u[i] = id[u[i]], v[i] = id[v[i]];<br>        &#125;<br>        s = id[s];<br>        n = idx;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">zhuliu</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/S">S题</a></h1><h2 id="题意分析-42">题意分析</h2><p>一般图最大匹配<br>带花树流程<br>我们给所有点黑白染色。假设开始增广的点是黑点。 把所有黑点压进队列中顺次处理。对于一个黑点u，找与他相邻的点v，会出现一下几种情况： 1、u,v已经被缩成一个点了（这两个点在一朵花里），不管他。 2、v是白点，说明已经被匹配了，也不管。 3、v还没有被染色。那就先把这个点染成白的，然后尝试去与他匹配。如果v还没有匹配就匹配上，增广成功，然后一路跳回取反。如果v已经被匹配了，那么匹配他的点就是个黑点，染色，然后压进队列。 4、v也是黑点。这时候染色发生了冲突，说明遇见了奇环。这时候就需要找到两个点的lca，然后把这整个环缩成一个点。美其名曰，开花。</p><ol><li>找x和y的LCA（的根）p。找LCA可以用各种方法 直接朴素也行。</li><li>在pre数组中把x和y接起来（表示它们形成环了！）</li><li>从x、y分别走到p，修改并查集使得它们都变成一家人，同时沿路把pre数组接起来</li></ol><h2 id="代码-46">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> e[N][N];<br><span class="hljs-type">int</span> p[N], pre[N], match[N], col[N];<br><span class="hljs-type">int</span> cnt, st[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) <span class="hljs-keyword">return</span> p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aug</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">while</span> (v) <span class="hljs-comment">// 修改增广路</span><br>    &#123;<br>        t = match[pre[v]];<br>        match[v] = pre[v];<br>        match[pre[v]] = v;<br>        v = t;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cnt ++ ;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">while</span> (st[u] != cnt)<br>    &#123;<br>        st[u] = cnt;<br>        u = <span class="hljs-built_in">find</span>(pre[match[u]]);<br>        <span class="hljs-keyword">if</span> (v) <span class="hljs-built_in">swap</span>(u, v);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">find</span>(u) != r)<br>    &#123;<br>        pre[u] = v;<br>        v = match[u];<br>        <span class="hljs-keyword">if</span> (col[v] == <span class="hljs-number">2</span>)<br>        &#123;<br>            col[v] = <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(u) == u) p[u] = r;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(v) == v) p[v] = r;<br>        u = pre[v];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(col, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> col);<br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> pre);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) q.<span class="hljs-built_in">pop</span>();<br>    col[s] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<br>    <br>    <span class="hljs-type">int</span> u;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v ++ ) <span class="hljs-keyword">if</span> (e[u][v])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!col[v])<br>            &#123;<br>                pre[v] = u;<br>                <span class="hljs-keyword">if</span> (!match[v]) &#123;<span class="hljs-built_in">aug</span>(v);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>                <span class="hljs-keyword">else</span>&#123;col[v] = <span class="hljs-number">2</span>;col[match[v]] = <span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(match[v]);&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (col[v] == <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> r = <span class="hljs-built_in">lca</span>(u, v);<br>                    <span class="hljs-built_in">shrink</span>(u, v, r);<br>                    <span class="hljs-built_in">shrink</span>(v, u, r);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        e[a][b] = e[b][a] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!match[i] &amp;&amp; <span class="hljs-built_in">bfs</span>(i))<br>            res ++ ;<br>            <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/T">T题</a></h1><h2 id="题意分析-43">题意分析</h2><p>给一张有向图，问从图中最少需要选出多少条互不相交的简单路径（不走重点的一条有向链），才能让图中的所有点都被这些路径经过一次？</p><h2 id="解题思路-6">解题思路</h2><p>将本题转换成求二分图的最小路径覆盖<br>最小路径覆盖<br>最小路径覆盖<br>DAG(有向无环图)<br>用最少的互不相交的路径 将所有点覆盖<br>将所有点拆成两个点，出点和入点<br>原图有边i→j<br>则有    i→j’<br>出点 入点<br>原图变为从左边(出点)连向右边(入点)的二分图<br>则最少互不相交的路径=n-m(最大点覆盖数量)</p><p>原图中的每条路径 转化到新图中<br>每个点最多只有一个出度一个入度<br>&lt;=&gt; 新图中的任意两条边之间不相交<br>&lt;=&gt; 新图中的边都是匹配边</p><p>每个路径终点 对应 一个左侧非匹配点(3作为终点 在新图中没出边)<br>&lt;=&gt; 让左侧非匹配点最少 n-m<br>&lt;=&gt; 让左侧匹配点最多 m<br>&lt;=&gt; 找最大匹配边数 m</p><h2 id="代码-47">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">410</span>, M = <span class="hljs-number">6e4</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> match[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b + n);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++ ;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n - res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训数据结构题解</title>
      <link href="/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>还是有点菜，好多题没做，而且有点摆烂，下一个专题好好做，争取进前十</p><h1>B题</h1><h2 id="题意分析-50">题意分析</h2><p>实现一个满足区间加，区间乘和区间求和的数据结构，区间长度最大$10^5$，操作次数最大$10^5$。</p><h2 id="解题思路-7">解题思路</h2><p>这个是一个朴素的线段数模板，要采用懒标记修改。<br>面对这两种操作，可以联想到线段树的一个非常好的功能就是lazytag，只计算出确实需要访问的区间的真实值，其他的保存在lazytag里面，这样可以近似O(NlogN)的运行起来。在尝试着写了只有一个lazetag的程序之后我们发现一个lazytag是不能够解决问题的，那就上两个，分别表示乘法意义上的lazytag和加法意义上的lazytag。紧接着想到pushdown操作之后我们又发现必须在向下传递lazytag的时候人为地为这两个lazytag规定一个先后顺序，排列组合一下只有两种情况：</p><p>①加法优先，即规定好segtree[root<em>2].value=((segtree[root</em>2].value+segtree[root].add)*segtree[root].mul)%p，问题是这样的话非常不容易进行更新操作，假如改变一下add的数值，mul也要联动变成奇奇怪怪的分数小数损失精度，我们内心是很拒绝的；</p><p>②乘法优先，即规定好segtree[root<em>2].value=(segtree[root</em>2].value<em>segtree[root].mul+segtree[root].add</em>(本区间长度))%p，这样的话假如改变add的数值就只改变add，改变mul的时候把add也对应的乘一下就可以了，没有精度损失，看起来很不错。</p><h2 id="代码-54">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>, d = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br>ll a[maxn], t[maxn * <span class="hljs-number">4</span>], add[maxn * <span class="hljs-number">4</span>], mul[maxn * <span class="hljs-number">4</span>];<br>ll n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">1</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span></span>&#123;<br>t[p] = (t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)]) % d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(ll p, ll l, ll r, ll k)</span></span>&#123;<br>t[p] = (t[p] * k) % d;<br>add[p] = (add[p] * k) % d;<br>mul[p] = (mul[p] * k) % d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(ll p, ll l, ll r, ll k)</span></span>&#123;<br>t[p] = (t[p] + k * (r - l + <span class="hljs-number">1</span>)) % d;<br>add[p] = (add[p] + k) % d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll l, ll r)</span></span>&#123;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">f1</span>(<span class="hljs-built_in">ls</span>(p), l, mid, mul[p]);<br><span class="hljs-built_in">f2</span>(<span class="hljs-built_in">ls</span>(p), l, mid, add[p]);<br><span class="hljs-built_in">f1</span>(<span class="hljs-built_in">rs</span>(p), mid + <span class="hljs-number">1</span>, r, mul[p]);<br><span class="hljs-built_in">f2</span>(<span class="hljs-built_in">rs</span>(p), mid + <span class="hljs-number">1</span>, r, add[p]);<br>add[p] = <span class="hljs-number">0</span>;<br>mul[p] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span></span>&#123;<br>add[p] = <span class="hljs-number">0</span>;<br>mul[p] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l == r)&#123;<br>t[p] = a[l];<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(<span class="hljs-built_in">ls</span>(p), l, mid);<br><span class="hljs-built_in">build</span>(<span class="hljs-built_in">rs</span>(p), mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update1</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll p, ll k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;<br><span class="hljs-built_in">f1</span>(p, l, r, k);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">push_down</span>(p, l, r);<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L &lt;= mid) <span class="hljs-built_in">update1</span>(L, R, l, mid, <span class="hljs-built_in">ls</span>(p) , k);<br><span class="hljs-keyword">if</span>(R &gt; mid) <span class="hljs-built_in">update1</span>(L, R, mid + <span class="hljs-number">1</span>, r, <span class="hljs-built_in">rs</span>(p), k);<br><span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update2</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll p, ll k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;<br><span class="hljs-built_in">f2</span>(p, l, r, k);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">push_down</span>(p, l, r);<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L &lt;= mid) <span class="hljs-built_in">update2</span>(L, R, l, mid, <span class="hljs-built_in">ls</span>(p), k);<br><span class="hljs-keyword">if</span>(R &gt; mid) <span class="hljs-built_in">update2</span>(L, R, mid + <span class="hljs-number">1</span>, r, <span class="hljs-built_in">rs</span>(p), k);<br><span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[p];<br><span class="hljs-built_in">push_down</span>(p, l, r);<br>ll res = <span class="hljs-number">0</span>;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L &lt;= mid) res += <span class="hljs-built_in">query</span>(L, R, l, mid, <span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(R &gt; mid) res += <span class="hljs-built_in">query</span>(L, R, mid + <span class="hljs-number">1</span>, r, <span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> res % d;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ll op, x, y, k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;op);<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br><span class="hljs-built_in">update1</span>(x, y, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, k);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br><span class="hljs-built_in">update2</span>(x, y, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, k);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(x, y, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>C题</h1><h2 id="题意分析-51">题意分析</h2><p>待修改的主席树</p><h2 id="解决思路">解决思路</h2><p>思路是，把二分答案的操作和查询小于一个值的数的数量两种操作结合起来。最好的方法是使用 线段树套主席树。</p><p>说是主席树其实不准确，因为并不是对线段树的可持久化，各个线段树之间也没有像主席树各版本之间的强关联性，所以称为动态开点权值线段树更为确切。</p><p>思路类似于线段树套平衡树，即对于线段树所维护的每个区间，建立一个动态开点权值线段树，表示其所维护的区间的值。</p><p>在修改操作进行时，先在线段树上从上往下跳到被修改的点，删除所经过的点所指向的动态开点权值线段树上的原来的值，然后插入新的值，要经过$O(logn)$个线段树上的节点，在动态开点权值线段树上一次修改操作是$O(logn)$的，所以修改操作的时间复杂度为O(log^2n) 。</p><p>在查询答案时，先取出该区间覆盖在线段树上的所有点，然后用类似于静态区间k小值的方法，将这些点一起向左儿子或向右儿子跳。如果所有这些点左儿子存储的值大于等于k，则往左跳，否则往右跳。由于最多只能覆盖$O(logn)$个节点，所以最多一次只有这么多个节点向下跳，时间复杂度为$O(log^2n)$。</p><p>由于线段树的常数较大，在实现中往往使用常数更小且更方便处理前缀和的 树状数组 实现。</p><h2 id="代码-55">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC o &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RC o &lt;&lt; 1 | 1</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> n, m, a[maxn], u[maxn], x[maxn], l[maxn], r[maxn], k[maxn], cur, cur1, cur2,<br>    q1[maxn], q2[maxn], v[maxn];<br><span class="hljs-type">char</span> op[maxn];<br>set&lt;<span class="hljs-type">int</span>&gt; ST;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segment_tree</span>  <span class="hljs-comment">// 封装的动态开点权值线段树</span><br>&#123;<br>  <span class="hljs-type">int</span> cur, rt[maxn * <span class="hljs-number">4</span>], sum[maxn * <span class="hljs-number">60</span>], lc[maxn * <span class="hljs-number">60</span>], rc[maxn * <span class="hljs-number">60</span>];<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; o)</span> </span>&#123; o = ++cur; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (l == r &amp;&amp; sum[o]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, l);<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(lc[o], l, mid);<br>    <span class="hljs-built_in">print</span>(rc[o], mid + <span class="hljs-number">1</span>, r);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; o, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (!o) o = ++cur;<br>    sum[o] += v;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid)<br>      <span class="hljs-built_in">update</span>(lc[o], l, mid, x, v);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">update</span>(rc[o], mid + <span class="hljs-number">1</span>, r, x, v);<br>  &#125;<br>&#125; st;<br><br><span class="hljs-comment">// 树状数组实现</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> o)</span> </span>&#123; <span class="hljs-keyword">return</span> (o &amp; (-o)); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (; o &lt;= n; o += <span class="hljs-built_in">lowbit</span>(o)) st.<span class="hljs-built_in">update</span>(st.rt[o], <span class="hljs-number">1</span>, n, x, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gtv</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span>* A, <span class="hljs-type">int</span>&amp; p)</span> </span><br><span class="hljs-function"></span>&#123;<br>  p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; o; o -= <span class="hljs-built_in">lowbit</span>(o)) A[++p] = st.rt[o];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>  <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, siz = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur1; i++) siz += st.sum[st.lc[q1[i]]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur2; i++) siz -= st.sum[st.lc[q2[i]]];<br>  <span class="hljs-keyword">if</span> (siz &gt;= k) <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur1; i++) q1[i] = st.lc[q1[i]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur2; i++) q2[i] = st.lc[q2[i]];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(l, mid, k);<br>  &#125; <br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur1; i++) q1[i] = st.rc[q1[i]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur2; i++) q2[i] = st.rc[q2[i]];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(mid + <span class="hljs-number">1</span>, r, k - siz);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a + i), ST.<span class="hljs-built_in">insert</span>(a[i]);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <br>  &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, op + i);<br>    <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">&#x27;C&#x27;</span>)<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, u + i, x + i), ST.<span class="hljs-built_in">insert</span>(x[i]);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, l + i, r + i, k + i);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = ST.<span class="hljs-built_in">begin</span>(); it != ST.<span class="hljs-built_in">end</span>(); it++)<br>    mp[*it] = ++cur, v[cur] = *it;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = mp[a[i]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">&#x27;C&#x27;</span>) x[i] = mp[x[i]];<br>  n += m;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">upd</span>(i, a[i], <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <br>  &#123;<br>    <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">&#x27;C&#x27;</span>) <br>    &#123;<br>      <span class="hljs-built_in">upd</span>(u[i], a[u[i]], <span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">upd</span>(u[i], x[i], <span class="hljs-number">1</span>);<br>      a[u[i]] = x[i];<br>    &#125; <br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">gtv</span>(r[i], q1, cur1);<br>      <span class="hljs-built_in">gtv</span>(l[i] - <span class="hljs-number">1</span>, q2, cur2);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, v[<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, n, k[i])]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>D题</h1><h2 id="题意分析-52">题意分析</h2><p>平衡树裸题</p><h2 id="解决思路-2">解决思路</h2><p>众所周知Treap = BST + heap</p><p>堆不多说了。</p><p>说说这个BST，就是说一个根节点p，左儿子一定小于他，右儿子大于它。</p><p>也就是BST的中序遍历是严格单调递增的。</p><p>那么就可以进行一些操作了。</p><p>首先为了维护这个BST我们需要一个左旋zag和右旋zig，分别表示将根节点和左右儿子交换位置，使交换后还满足BST的性质。</p><p>这个相当于一个模拟了，代码放在后面。</p><p>然后就是插入。</p><p>这个可以从根节点开始，看看往左儿子走还是往右儿子走，一直走到空或者和自己相等的节点，然后进行插入。</p><p>删除的话也是一样，从根节点走，走到了这个节点就删除掉，如果走到的节点为空，那就不用管了，因为这个节点不存在。</p><p>还有就是删除的时候如果遇到了叶节点可以直接删除，不会影响BST的性质。</p><p>接着就是几个奇怪的操作。</p><p>先说最大最小，就是一直往左走或者一直往右走。</p><p>然后是查排名和排名对应的数，一样的，排名可以一点点走，然后分类讨论，这个可以看代码注释。</p><p>排名对应的数也是一样，但这个得判断一下个数，所以BST里要有cnt和size两个变量表示节点个数和当前这个节点有多少个。</p><p>最后是前驱和后继，具体定义参见题目描述。</p><p>方法也是一样，前驱就是左边最大的，后继就是右边最小的，可以用递归写，会简单很多。</p><p>但是有的时候BST会退化成一条链，时间复杂度就大大降低了，但是只要BST够随机，期望高度就是log n。</p><p>所以的话就把它和堆集合在了一起，变成了平衡树。</p><h2 id="代码-56">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">1e8</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> key, val;<br>    <span class="hljs-type">int</span> cnt, Size;<br>&#125;tr[N];<br><br><span class="hljs-type">int</span> root, idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[p].Size = tr[tr[p].l].Size + tr[tr[p].r].Size + tr[p].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_node</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[ ++ idx].key = key;<br>    tr[idx].val = <span class="hljs-built_in">rand</span>();<br>    tr[idx].cnt = tr[idx].Size = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> idx;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q = tr[p].l;<br>    tr[p].l = tr[q].r, tr[q].r = p, p = q;<br>    <span class="hljs-built_in">pushup</span>(tr[p].r), <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q = tr[p].r;<br>    tr[p].r = tr[q].l, tr[q].l = p, p = q;<br>    <span class="hljs-built_in">pushup</span>(tr[p].l), <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">get_node</span>(-INF), <span class="hljs-built_in">get_node</span>(INF);<br>    root = <span class="hljs-number">1</span>, tr[root].r = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">pushup</span>(root);<br><br>    <span class="hljs-keyword">if</span> (tr[<span class="hljs-number">1</span>].val &lt; tr[<span class="hljs-number">2</span>].val) <span class="hljs-built_in">zag</span>(root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) p = <span class="hljs-built_in">get_node</span>(key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].key &gt; key)<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(tr[p].l, key);<br>        <span class="hljs-keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) <span class="hljs-built_in">zig</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">insert</span>(tr[p].r, key);<br>        <span class="hljs-keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) <span class="hljs-built_in">zag</span>(p);<br>    &#125;<br><br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (tr[p].key == key)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[p].cnt &gt; <span class="hljs-number">1</span>) tr[p].cnt -- ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].l || tr[p].r)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)<br>            &#123;<br>                <span class="hljs-built_in">zig</span>(p);<br>                <span class="hljs-built_in">remove</span>(tr[p].r, key);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">zag</span>(p);<br>                <span class="hljs-built_in">remove</span>(tr[p].l, key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].key &gt; key) <span class="hljs-built_in">remove</span>(tr[p].l, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(tr[p].r, key);<br><br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank_by_key</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (tr[p].key == key) <span class="hljs-keyword">return</span> tr[tr[p].l].Size + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (tr[p].key &gt; key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_rank_by_key</span>(tr[p].l, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_rank_by_key</span>(tr[p].r, key) + tr[tr[p].l].Size + tr[p].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_key_by_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> rank)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span> (tr[tr[p].l].Size &gt;= rank) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_key_by_rank</span>(tr[p].l, rank);<br>    <span class="hljs-keyword">if</span> (tr[tr[p].l].Size + tr[p].cnt &gt;= rank) <span class="hljs-keyword">return</span> tr[p].key;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_key_by_rank</span>(tr[p].r, rank - tr[tr[p].l].Size - tr[p].cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_prev</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span> (tr[p].key &gt;= key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_prev</span>(tr[p].l, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p].key, <span class="hljs-built_in">get_prev</span>(tr[p].r, key));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">if</span> (tr[p].key &lt;= key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_next</span>(tr[p].r, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(tr[p].key, <span class="hljs-built_in">get_next</span>(tr[p].l, key));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> opt, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;opt, &amp;x);<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) <span class="hljs-built_in">insert</span>(root, x);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) <span class="hljs-built_in">remove</span>(root, x);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_rank_by_key</span>(root, x) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">4</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_key_by_rank</span>(root, x + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">5</span>) <br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">get_prev</span>(root, x);<br>            <span class="hljs-keyword">if</span> (t == -INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_prev</span>(root, x));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">get_next</span>(root, x);<br>            <span class="hljs-keyword">if</span> (t == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_next</span>(root, x));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>E题</h1><h2 id="题意分析-53">题意分析</h2><p>动态求逆序对</p><h2 id="解决思路-3">解决思路</h2><p>可以用CDQ思路解决</p><p>CDQ分治能够快速的找出来三维偏序的问题,也就是对于一个n的序列，每个i有多少个j使得$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$</p><p>假设$a_i$ 不等于$a_j$</p><p>我们首先看一下一维版本我们将所有的元素按照第一关键字排序，对于i来说一共有i-1个j满足条件</p><p>然后看一下二维版本，将所有元素按照双关键字排序，也就是我们以a按照第一关键子排序，以b按照第二关键字排序，我们可以从前往后扫描，当我们扫描第i个元素的时候，所有满足要求的j一定在第i个元素前面，i前面的序列必然满足$a_j \leq a_i$，i的后面必然不满足，我们要做的是在前面i-1个元素中有多少个元素满足$b_j \leq b_i$</p><blockquote><p>双关键字排序的作用是对于i来说，满足要求的j一定是在i的前面，如果我们按照A来排，那么这个性质就不一定会成立。</p></blockquote><ul><li><p>我们可以用树状数组来做，我们可以将b离散化到1-n之间的数，但我们要求前面有多少个数小于等于$b_i$时，相当于求$b_i$的前缀和，然后我们求完后，将第i个元素插入到树状数组里面，将树状数组里面$b_i$这个位置加一。</p></li><li><p>我们也可以用分治做法来做，分治的话类似于归并排序求逆序对，我们现在想求的是对于当前区间，每一个i满足要求的j有多少个，我们可以将所有的i，j对分为3类（i在后，j在前）</p></li></ul><ol><li>i，j都在左侧 $\to$ 递归左边</li><li>i，j都在右侧 $\to$ 递归右边</li><li>i在右侧，j在左侧，因为一定满足第一维性质，所以我们只需要考虑第二维性质，我们需要找出$b_j \leq a_i$的个数，我们每次合并的时候，按照b进行维护序列，可以使用双指针算法，我们i和j从左往右枚举，每次i向后移动一格，j向后移动，找到大于$b_i$的位置<br>算法复杂度$O(nlogn)$</li></ol><p>最后讨论三维问题<br>对于每个i来说，我们都要求满足$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$的j的数目有多少。</p><p>我们的做法是按照三关键字排序，这样做的好处是，所有满足要求的j一定是在i的左侧</p><p>我们可以将所有&lt;i, j&gt; 分成三类 （i在j右边）</p><ol><li>i，j都在左侧</li><li>i，j都在右侧</li><li>i在左，j在右</li></ol><p>对于a条件来说这个限制一定成立，我们不用考虑，我们可以在归并分治的过程中，将区间的所有元素按照b进行排序，我们对于右侧任意一个元素i来说，我们要求的是在左侧有多少个j满足$b_j \leq b_i, c_j \leq c_i$ ,第二维限制我们可以用双指针算法来解决，对于每一个i我们找到第一个$b_j &gt; b_i$的位置（线性复杂度）那么从区间起点到j-1的位置就是满足$b_j \leq b_i$的区间，然后我们需要在这个区间里面找到$c_j \leq c_i$ 的个数，这个可以采用树状数组的方法来解决，我们可以把所有的c离散化，变成从1~n的某个数，我们要想求$c_j \leq c_i$ 的个数相当于求1-$c_i$的总和，即求前缀和，每一次j往后移动一格，相当于在树状数组里面加上$c_j$</p><p>时间复杂度为$O(nlog^2n)$,一共有$logn$层，每层复杂度为$nlogn$</p><p>如果出现$a_j = a_i,$   $b_j  = b_i,$ $c_j = c_i$,我们可以发现排完序后这两个数一定挨在一起，我们对于后面这个元素我们可以正确求解，但对于前面这个元素来讲，它只考虑它前面的元素，没有考虑右侧的部分，那么他就会把和他相等的元素漏掉，对于这样完全相同的元素，我们要进行判重，在序列中去除掉，再记录下每个元素出现了多少次。我们对于同一种元素我们还要更新下答案，如果有k个元素和第i个元素完全相同，那么答案还需要加上k</p><p>首先我们可以发现<br>$p_i$ i的下标</p><p>$A_i$ 元素的值</p><p>$T_i$ 表示元素i被删除的时间，定义删除的时序，如果没有被删我们任意给他分配一个后面的数，为了方便起见，只要有序就可以，我们可以倒着来分配，第一次删除的时候我们的时间戳是n，第二次是n-1，第m次删除的数位n-m+1，剩下的数按照某种顺序分配就可以，那这样的话，每一个数都会有一个唯一的时间戳，至于为什么要倒着分配，是因为你如果倒着来赋值的话，会发现第三维要满足的关系为$T_i \leq T_j$ 这是一个前缀和，如果正着赋值的话，会求一个后缀和，树状数组比较好处理前缀和。</p><p>然后我们考虑下怎么去统计答案，我们要统计的是每一次删除之前有多少个逆序对，因此我们统计的时候应该按照时间来看，我们要按照被删除的时间算答案，对于每一个时间戳$T_j$来说，我们要求和$T_j$可以构成逆序对的数目有多少个，我们把结果存到S[$T_j$]的数组里面，S[i]表示的是和第i个时间被删除的这个元素构成的逆序对的数量（只考虑$T_j$时刻仍然存在的元素）</p><p>我们规定每个数对（i，j），我们看一下那个数更后被删除我们就把这个数对累加到靠后删除的数对，这样不会导致逆序对被多算。</p><p>我们要求的是删除一个元素之前统计整个序列的逆序对数，相当于求两个数都在第i个时刻之后的部分的总数，这些数应该就是$S_1+S_2+…+S_i$也就是$S_i$的前缀和</p><p>现在问题就转换成如何求S[$T_j$]，我们看一下$T_j$的性质</p><ol><li>$T_i &lt; T_j$</li><li>第一种情况 $P_i &lt; P_j, A_i &gt; A_j$ 第二种情况 $P_j &lt; P_i, A_j &gt; A_i$</li></ol><p>因此我们要求两种偏序关系</p><ol><li>$T_i &lt; T_j, P_i &lt; P_j, A_i &gt; A_j$</li><li>$T_i &lt; T_j, P_j &lt; P_i, A_j &gt; A_i$</li></ol><p>然后本题可以把顺序倒过来处理。</p><h2 id="代码-57">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> a, t, res;<br>&#125;q[N], w[N];<br><span class="hljs-type">int</span> tr[N], pos[N];<br>LL ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = mid, j = r;<br>    <span class="hljs-keyword">while</span> (i &gt;= l &amp;&amp; j &gt; mid)<br>        <span class="hljs-keyword">if</span> (q[i].a &gt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i -- ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">while</span> (j &gt; mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt;= mid; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    j = l, i = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid &amp;&amp; i &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i ++ ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = mid + <span class="hljs-number">1</span>; k &lt; i; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) w[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; j ++ , i ++ ) q[i] = w[j]; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    m = n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i].a);<br>        pos[q[i].a] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        q[pos[x]].t = j ++ ;<br>        pos[x] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>            <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) ans[q[i].t] = q[i].res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) ans[i] += ans[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>I题</h1><h2 id="题意分析-54">题意分析</h2><p>并查集裸题</p><h2 id="解决思路-4">解决思路</h2><p>~~ 势能分析没听懂，不管他了 ~~</p><p>要考虑并查集的优化，按秩合并，然后路径压缩就可以解决，比较简单，不再赘述。</p><h2 id="代码-58">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (frS==frT&amp;&amp;(frT=(frS=frBB)+fread(frBB,1,1&lt;&lt;15,stdin),frS==frT)?EOF:*frS++)</span><br><span class="hljs-type">char</span> frBB[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>],*frS=frBB,*frT=frBB;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span></span>&#123;<br>    x=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c))c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c))&#123;x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e6</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> siz[N], p[N];<br><span class="hljs-type">int</span> ans[N], top;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x != p[x]) <span class="hljs-keyword">return</span> p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i, siz[i] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, a, b;<br>        <span class="hljs-built_in">read</span>(op); <span class="hljs-built_in">read</span>(a); <span class="hljs-built_in">read</span>(b);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) <br>        &#123;<br>            a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span> (siz[a] &gt; siz[b]) <span class="hljs-built_in">swap</span>(a, b);<br>            p[a] = b;<br>            siz[b] += siz[a];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b)) ans[ ++ top] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> ans[ ++ top] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>, a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &gt; <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ans[i]) res = (res + a) % mod;<br>        a = (a * <span class="hljs-number">2</span>) % mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>J题</h1><h2 id="题意分析-55">题意分析</h2><p>有n个物品和n张钱，每个物品必须用面值不小于他的钱支付，可以修改k张钱面值，求最小的总支付面值</p><h2 id="解决方法">解决方法</h2><p>要使花的钱最少，即让每一次交易中，纸币面值与商品价值的差值之和最小。（贪心）<br>由此可推出以下两点：</p><ol><li><p>【贪心地购买】在不需要使用魔法的情况下，如何保证差值尽可能小？</p><ol><li>将$w_i,v_i$排序<br>由于</li><li>魔法改变纸币面值而商品价值固定（不会被操作打乱）</li><li>对于价值更高的商品，可能存在的能买下它的纸币数量更少。<br>因此</li><li>对商品价值 从大到小枚举进行操作。</li></ol></li><li><p>答案是每次从能买得起 的纸币中挑选面值 最小的纸币</p></li><li><p>【贪心的魔法】如何更加高效地使用魔法？<br>如果要使用魔法，只会存在两种情况：买不起，小改大；钱太多，大改小<br>（优先”小改大“，保证尽量有解；”小改大“之后有剩余魔法才考虑”大改小“）</p></li><li><p>如果想买下当前最贵的商品，需要把小纸币改大，则使用魔法之前不存在能买得起该商品的纸币，且一定刚好将某个小纸币改大到要买的商品的价值 。 此时不确定是对哪个小纸币使用魔法，但是由于纸币数量刚好和商品数量相同，如果有解，则在一一 枚举商品之后一定存在被挑剩下的小纸币（挑选方式后续说明）</p></li><li><p>如果当前状态下不需要使用魔法把小纸币改大即可买下所有商品。</p></li></ol><p>用一个新数组记录每个对应关系中纸币面值与商品价值的差值。</p><p>后续将差值排序，取前k大的差值修改为零，即相当于将那k组对应关系中的大纸币改小到要买的商品的价值 。</p><ul><li>NIE的判断条件</li></ul><p>枚举到商品$v_i$时，<br>不存在买得起商品 的纸币，<br>且使用魔法的剩余次数为0</p><h2 id="代码-59">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N], v[N], c[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><span class="hljs-type">int</span> stk[N], top, cnt;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i]);<br>        <br>    <span class="hljs-built_in">sort</span>(w + <span class="hljs-number">1</span>, w + n + <span class="hljs-number">1</span>, cmp);<br>    <span class="hljs-built_in">sort</span>(v + <span class="hljs-number">1</span>, v + n + <span class="hljs-number">1</span>, cmp);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (w[j] &gt;= v[i])<br>        &#123;<br>            stk[ ++ top] = w[j];<br>            j ++ ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!top)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NIE&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            m -- ;<br>            res += v[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = stk[top -- ];<br>            c[ ++ cnt] = t - v[i];<br>            res += t;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + cnt, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>        res -= c[i];<br>        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>K题</h1><h2 id="题意分析-56">题意分析</h2><p>一个n*n的矩阵(1≤n≤500)，m(1≤m≤10^5)次操作，每次修改矩阵中的一个值或查询一个矩形中的最大值和最小值</p><h2 id="解决思路-5">解决思路</h2><p>线段树可以维护一维的信息，通过线段树套线段树来维护二维的信息。</p><p>外层的线段树维护第一个维度上的信息，即第1到n行，对于每个节点各开一个内层线段树，这个线段树维护在外层线段树节点对应的行中1到n列的信息</p><p>注意单点修改时非叶子节点和叶子节点的更新方式不同，修改时现在外层线段树找到要修改的叶子节点，修改内层线段树，之后根据叶子结点的内层线段树修改外层非叶子节点的内层线段树</p><p>我们考虑用树套树如何实现在二维平面上进行单点修改，区域查询。我们考虑外层的线段树，最底层的1到n个节点的子树，分别代表第1 到第n行的线段树。那么这些底层的节点对应的父节点，就代表其两个子节点的子树所在的一片区域。</p><h2 id="代码-60">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e8</span>;<br> <br><span class="hljs-type">int</span> n,q,mx[N][N],mi[N][N];<br><span class="hljs-type">int</span> fg,xo,mians,mxans;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(fg) mi[xo][o]=v,mx[xo][o]=v;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            mi[xo][o]=<span class="hljs-built_in">min</span>(mi[<span class="hljs-number">2</span>*xo][o],mi[<span class="hljs-number">2</span>*xo+<span class="hljs-number">1</span>][o]);<br>            mx[xo][o]=<span class="hljs-built_in">max</span>(mx[<span class="hljs-number">2</span>*xo][o],mx[<span class="hljs-number">2</span>*xo+<span class="hljs-number">1</span>][o]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(y&lt;=m) <span class="hljs-built_in">upd2</span>(l,m,<span class="hljs-number">2</span>*o,y,v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">upd2</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,y,v);<br>    mi[xo][o]=<span class="hljs-built_in">min</span>(mi[xo][<span class="hljs-number">2</span>*o],mi[xo][<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>]);<br>    mx[xo][o]=<span class="hljs-built_in">max</span>(mx[xo][<span class="hljs-number">2</span>*o],mx[xo][<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) &#123;<br>        fg=<span class="hljs-number">1</span>;<br>        xo=o;<br>        <span class="hljs-built_in">upd2</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,y,v);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=m) <span class="hljs-built_in">upd1</span>(l,m,<span class="hljs-number">2</span>*o,x,y,v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">upd1</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,x,y,v);<br>    fg=<span class="hljs-number">0</span>,xo=o;<br>    <span class="hljs-built_in">upd2</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,y,v);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qy2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> pre,<span class="hljs-type">int</span> ly,<span class="hljs-type">int</span> ry)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ly&lt;=l&amp;&amp;ry&gt;=r) <br>    &#123;<br>        mians=<span class="hljs-built_in">min</span>(mians,mi[pre][o]);<br>        mxans=<span class="hljs-built_in">max</span>(mxans,mx[pre][o]);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(ly&lt;=m) <span class="hljs-built_in">qy2</span>(l,m,<span class="hljs-number">2</span>*o,pre,ly,ry);<br>    <span class="hljs-keyword">if</span>(ry&gt;m) <span class="hljs-built_in">qy2</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,pre,ly,ry);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qy1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> lx,<span class="hljs-type">int</span> rx,<span class="hljs-type">int</span> ly,<span class="hljs-type">int</span> ry)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(lx&lt;=l&amp;&amp;rx&gt;=r) <br>    &#123;<br>        <span class="hljs-built_in">qy2</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,o,ly,ry);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(lx&lt;=m) <span class="hljs-built_in">qy1</span>(l,m,<span class="hljs-number">2</span>*o,lx,rx,ly,ry);<br>    <span class="hljs-keyword">if</span>(rx&gt;m) <span class="hljs-built_in">qy1</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,lx,rx,ly,ry);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v),<span class="hljs-built_in">upd1</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,i,j,v);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br>        <span class="hljs-type">int</span> x,y,x1,y1;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>) <br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;x1,&amp;y1);<br>            mians=inf;<br>            mxans=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">qy1</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,x,x1,y,y1);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,mxans,mians);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);<br>            <span class="hljs-built_in">upd1</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,x,y,v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>L题</h1><h2 id="题意分析-57">题意分析</h2><p>求区间众数</p><h2 id="解决思路-6">解决思路</h2><p>可以采用分块的思想</p><p>分块的思想其实就是一个朴素的暴力做法。<br>我们把一个区间分成$\sqrt{n}$段，对于查询的区间，我们可以将其分成最多两个不完整段（长度$\leq \sqrt{n}$）和不超过$\sqrt{n}$个完整段。因此我们可以把$O(N)$复杂度变为$O(logn)$</p><p>对于这个题首先预处理i~j块的众数个数，如果求出i~j-1的众数个数了，现在要求i~j的众数个数，是不是就很简单了，众数个数要么是i~j-1的众数个数，要么就是第j块中数字出现的次数，那么就可以枚举第j块的数字，如果我们预处理出前i块数字j出现的次数（定义为sum[i][j]）,那么第j块出现的数字a[p]（其中p处于第j块中）在i~j块出现的次数为sum[j][ a[p] ]-sum[i-1][ a[p] ]。并且sum数字的预处理很简单。</p><p>预处理完成后，就是查询问题，查询其实和预处理的原理是一样的，假设L属于第x块，R属于第y块，那么此区间的众数个数要么是x+1~y-1块的众数个数，要么是L~第x块结束中数字出现的次数，要么就是第y块开始~R中数字出现的次数，由于x+1~y-1块的众数个数已经处理，那么只需要O（1）即可知道，另外两块就可以直接暴力统计个数就行（这里需要注意只需要初始化这两块中出现的数字，这样初始化复杂度只有sqrt（n），初值应为sum[y-1][p]-sum[x][p]，p为块中出现的数字），另外注意处理L和R处于同一块的情况，这样区间众数问题就解决了。</p><h2 id="代码-61">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> p, q , t, n, m;<br><span class="hljs-type">int</span> l, r, L, pos, lan;<br><span class="hljs-type">int</span> most[N],maxn[N],sum[<span class="hljs-number">1600</span>][N],a[N], b[<span class="hljs-number">100</span>],temp[N], c[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">discrete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+n+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> sz=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+n+<span class="hljs-number">1</span>)-c<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i]=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+sz+<span class="hljs-number">1</span>,a[i])-c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l,r);<br><br>p=l/L;<br>q=r/L;<br><span class="hljs-keyword">if</span>(l % L == <span class="hljs-number">1</span>)<br>p++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l % L) p += <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> p++;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-keyword">if</span>(q-p&lt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)<br>&#123; <br>temp[a[i]]++;<br><span class="hljs-keyword">if</span>(temp[a[i]]&gt;maxx)<br>maxx=temp[a[i]],ans=a[i];<br><span class="hljs-keyword">if</span>(temp[a[i]]==maxx&amp;&amp;c[a[i]]&lt;c[ans])<br>ans=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++) temp[a[i]]--;<br><br><span class="hljs-keyword">return</span> c[ans];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pos=b[p<span class="hljs-number">-1</span>] + q- p + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> maxx=maxn[pos];ans=most[pos];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt;= L*(p<span class="hljs-number">-1</span>); i++)<br>&#123;<br>sum[pos][a[i]]++;<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]&gt;maxx)<br>maxx=sum[pos][a[i]],ans=a[i];<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]==maxx&amp;&amp;c[a[i]]&lt;c[ans])<br>ans=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L*q+<span class="hljs-number">1</span>;i&lt;=r;i++)<br>&#123;<br>sum[pos][a[i]]++;<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]&gt;maxx)<br>maxx=sum[pos][a[i]],ans=a[i];<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]==maxx&amp;&amp;c[a[i]]&lt;c[ans])<br>ans=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=L*(p<span class="hljs-number">-1</span>);i++) sum[pos][a[i]]--;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L*q+<span class="hljs-number">1</span>;i&lt;=r;i++) sum[pos][a[i]]--;<br><br><span class="hljs-keyword">return</span> c[ans] ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),c[i]=a[i];<br><span class="hljs-built_in">discrete</span>();<br>t=<span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span>*n,<span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span>);L=n/t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++) b[i]=b[i<span class="hljs-number">-1</span>],b[i]+=t-i+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=t-i+<span class="hljs-number">1</span>;j++)<br>&#123;<br>pos=b[i<span class="hljs-number">-1</span>]+j;<br><span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=L*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;k&lt;=L*(i+j<span class="hljs-number">-1</span>);k++)<br>&#123;<br>sum[pos][a[k]]++;<br><span class="hljs-keyword">if</span>(sum[pos][a[k]]&gt;maxx)<br>maxx=sum[pos][a[k]],ans=a[k];<br><br><span class="hljs-keyword">if</span>(sum[pos][a[k]]==maxx&amp;&amp;c[a[k]]&lt;c[ans])<br>ans=a[k];<br>&#125;<br>most[pos]=ans;maxn[pos]=maxx;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,lan=<span class="hljs-built_in">ask</span>(l,r));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>M题</h1><h2 id="题意分析-58">题意分析</h2><p>给你一棵树有N个节点，这棵树的节点编号从 1 到 N。每个节点都有一个颜色。<br>要求你得到以下操作的答案：U V : 询问从 U 到 V 的路径上有多少个不同的颜色。</p><h2 id="解决方法-2">解决方法</h2><p>可以使用树上莫队解决<br>这道题其实就是将基本莫队那道例题搬到了树上，求树中任意两个点之间最短路径的数字个数。对于在树上维护某些路径的信息，普遍的做法是将数转换成一个序列，此题用的是欧拉序列。</p><p>欧拉序列：</p><p>从根节点向下dfs，记录所有遇到的点，最终返回到根节点，故每个点都会在序列中出现两次。</p><p>观察上面的欧拉序列，我们可以发现这样几个性质，假设 X在欧拉序中出现地比 Y早：</p><p>如果 X是 Y 的祖先，那么从 X 到 Y 的路径上经过的节点为：欧拉序中 X 第一次出现的位置到 Y 第一次出现的位置的区间内只出现过一次的节点（如1到4）。<br>如果 X 和 Y 有一个公共祖先 $(P \not = X, P \not = Y)$  ，那么从 X 到 Y 的路径上经过的节点为：欧拉序列中 X 第二次出现的位置到 Y 第一次出现的位置的区间内所有只出现过一次的节点，另外再加上 P ，如（4到6经过的数字在欧拉序中为4236再加上祖先1）。<br>如此，我们就可以将树转换成一个序列，对于每次询问，先判断 X 是否为 Y 的祖先，然后将询问的两个节点转变为欧拉序列中对应的下标，然后用莫队维护欧拉序列即可。当然，如果 X 和 Y 有一个不同于他们的公共祖先，那么还得在维护完区间后再加上他们的公共祖先。</p><p>4.2 莫队的加数操作<br>需要注意的是，此题莫队需要维护的是区间内只出现过一次的节点对应的数字的种数，我们用  记录某个数字在区间内出现过几次，用 标记某个节点是否在询问的路径上（如果在欧拉序中对应的区间内只出现过一次则在路径上，记为1）。我们考虑在当前序列中加入一个节点，如果这个节点当前状态  ，说明此节点之前出现过一次，现在又出现了一次，则不存在于路径上，则更新 ，我们可以发现加入一个节点其实就是将该节点的  异或上1。更新完  后，如果  变为1了，说明有新节点加入路径，则将该节点对应的数字维护到  中，同时更新 ；如果  变为 0， 则删去该节点对应的数字，更新  ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span> </span>&#123;<br>    sta[x] ^= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sta[x]) &#123;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res++;<br>        cnt[w[x]]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cnt[w[x]]--;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>梳理一遍代码流程：</p><p>由于数字取值在  范围，所以首先进行离散化操作。<br>求出树的欧拉序列。<br>求出每个节点的深度，同时将倍增计算lca的预处理完成。<br>将每次询问的两个节点转换成欧拉序的左右端点。<br>莫队维护计算所有询问。</p><h2 id="代码-62">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m, len;<br><span class="hljs-type">int</span> w[N];<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> depth[N], f[N][<span class="hljs-number">16</span>];<br><span class="hljs-type">int</span> seq[N], top, first[N], last[N];<br><span class="hljs-type">int</span> cnt[N], st[N], ans[N];<br><span class="hljs-type">int</span> que[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span><br>&#123;<br>    <span class="hljs-type">int</span> id, l, r, p;<br>&#125;q[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    seq[ ++ top] = u;<br>    first[u] = top;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j != father) <span class="hljs-built_in">dfs</span>(j, u);<br>    &#125;<br>    seq[ ++ top] = u;<br>    last[u] = top;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> depth);<br>    depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    que[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = que[hh ++ ];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (depth[j] &gt; depth[t] + <span class="hljs-number">1</span>)<br>            &#123;<br>                depth[j] = depth[t] + <span class="hljs-number">1</span>;<br>                f[j][<span class="hljs-number">0</span>] = t;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">15</span>; k ++ )<br>                    f[j][k] = f[f[j][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>                que[ ++ tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (depth[f[a][k]] &gt;= depth[b])<br>            a = f[a][k];<br>    <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (f[a][k] != f[b][k])<br>        &#123;<br>            a = f[a][k];<br>            b = f[b][k];<br>        &#125;<br>    <span class="hljs-keyword">return</span> f[a][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x / len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Query&amp; a, <span class="hljs-type">const</span> Query&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(a.l), j = <span class="hljs-built_in">get</span>(b.l);<br>    <span class="hljs-keyword">if</span> (i != j) <span class="hljs-keyword">return</span> i &lt; j;<br>    <span class="hljs-keyword">return</span> a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[x] ^= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (st[x] == <span class="hljs-number">0</span>)<br>    &#123;<br>        cnt[w[x]] -- ;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res -- ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res ++ ;<br>        cnt[w[x]] ++ ;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]), nums.<span class="hljs-built_in">push_back</span>(w[i]);<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    nums.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        w[i] = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), w[i]) - nums.<span class="hljs-built_in">begin</span>();<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add_edge</span>(a, b), <span class="hljs-built_in">add_edge</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">bfs</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span> (first[a] &gt; first[b]) <span class="hljs-built_in">swap</span>(a, b);<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(a, b);<br>        <span class="hljs-keyword">if</span> (a == p) q[i] = &#123;i, first[a], first[b]&#125;;<br>        <span class="hljs-keyword">else</span> q[i] = &#123;i, last[a], first[b], p&#125;;<br>    &#125;<br><br>    len = <span class="hljs-built_in">sqrt</span>(top);<br>    <span class="hljs-built_in">sort</span>(q, q + m, cmp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, L = <span class="hljs-number">1</span>, R = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;<br>        <span class="hljs-keyword">while</span> (R &lt; r) <span class="hljs-built_in">add</span>(seq[ ++ R], res);<br>        <span class="hljs-keyword">while</span> (R &gt; r) <span class="hljs-built_in">add</span>(seq[R -- ], res);<br>        <span class="hljs-keyword">while</span> (L &lt; l) <span class="hljs-built_in">add</span>(seq[L ++ ], res);<br>        <span class="hljs-keyword">while</span> (L &gt; l) <span class="hljs-built_in">add</span>(seq[ -- L], res);<br>        <span class="hljs-keyword">if</span> (p) <span class="hljs-built_in">add</span>(p, res);<br>        ans[id] = res;<br>        <span class="hljs-keyword">if</span> (p) <span class="hljs-built_in">add</span>(p, res);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>N题</h1><h2 id="题意分析-59">题意分析</h2><p>给定n(1≤n≤5×10^4)个元素， m(1≤m≤5×10^4)次操作，每次操作修改一个元素或查询一个区间上某个元素的排名或区间上第k小的值</p><h2 id="解决方法-3">解决方法</h2><ol><li>线段树中的每个点表示一个区间，单独开一个平衡树存储这个区间内的点</li><li>修改操作：在外层线段树中查询要修改的节点（logn），对这个节点的内层平衡树做修改（logn）</li><li>排名查询：在外层线段树中将查询的区间拆开（ logn，最多有logn个 ），在内层平衡树中可以查询到比k小的元素个数（ logn ），加起来计算可以得到结果</li><li>第k小：排名查询+二分，复杂度（log^3n）</li></ol><h2 id="代码-63">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000010</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], p, v;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> _v, <span class="hljs-type">int</span> _p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        v = _v, p = _p;<br>        size = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;tr[N];<br><span class="hljs-type">int</span> L[N], R[N], T[N], idx;<br><span class="hljs-type">int</span> w[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[x].size = tr[tr[x].s[<span class="hljs-number">0</span>]].size + tr[tr[x].s[<span class="hljs-number">1</span>]].size + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>    <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;<br>    tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x, tr[x].p = z;<br>    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>    tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].p = x;<br>    <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (tr[x].p != k)<br>    &#123;<br>        <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>        <span class="hljs-keyword">if</span> (z != k)<br>            <span class="hljs-keyword">if</span> ((tr[y].s[<span class="hljs-number">1</span>] == x) ^ (tr[z].s[<span class="hljs-number">1</span>] == y)) <span class="hljs-built_in">rotate</span>(x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!k) root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (u) p = u, u = tr[u].s[v &gt; tr[u].v];<br>    u = ++ idx;<br>    <span class="hljs-keyword">if</span> (p) tr[p].s[v &gt; tr[p].v] = u;<br>    tr[u].<span class="hljs-built_in">init</span>(v, p);<br>    <span class="hljs-built_in">splay</span>(root, u, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_k</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v &lt; v) res += tr[tr[u].s[<span class="hljs-number">0</span>]].size + <span class="hljs-number">1</span>, u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v == x) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (tr[u].v &lt; x) u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-built_in">splay</span>(root, u, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> l = tr[u].s[<span class="hljs-number">0</span>], r = tr[u].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (tr[l].s[<span class="hljs-number">1</span>]) l = tr[l].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (tr[r].s[<span class="hljs-number">0</span>]) r = tr[r].s[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">splay</span>(root, l, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(root, r, l);<br>    tr[r].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pushup</span>(r), <span class="hljs-built_in">pushup</span>(l);<br>    <span class="hljs-built_in">insert</span>(root, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    L[u] = l, R[u] = r;<br>    <span class="hljs-built_in">insert</span>(T[u], -INF), <span class="hljs-built_in">insert</span>(T[u], INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) <span class="hljs-built_in">insert</span>(T[u], w[i]);<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_k</span>(T[u], x) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a &lt;= mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, a, b, x);<br>    <span class="hljs-keyword">if</span> (b &gt; mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a, b, x);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">update</span>(T[u], w[p], x);<br>    <span class="hljs-keyword">if</span> (L[u] == R[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (p &lt;= mid) <span class="hljs-built_in">change</span>(u &lt;&lt; <span class="hljs-number">1</span>, p, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, p, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = -INF;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v &lt; v) res = <span class="hljs-built_in">max</span>(res, tr[u].v), u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = INF;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v &gt; v) res = <span class="hljs-built_in">min</span>(res, tr[u].v), u = tr[u].s[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_pre</span>(T[u], x);<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>, res = -INF;<br>    <span class="hljs-keyword">if</span> (a &lt;= mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query_pre</span>(u &lt;&lt; <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">if</span> (b &gt; mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query_pre</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_suc</span>(T[u], x);<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>, res = INF;<br>    <span class="hljs-keyword">if</span> (a &lt;= mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query_suc</span>(u &lt;&lt; <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">if</span> (b &gt; mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query_suc</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, a, b, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, a, b, x));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e8</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, a, b, mid) + <span class="hljs-number">1</span> &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;x);<br>            <span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>, a, x);<br>            w[a] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>Z题</h1><h2 id="题意分析-60">题意分析</h2><p>给定n(1≤n≤$10^6$)个元素，m(1≤m≤$10^5$)次操作，每次向里面的某个位置插入一个数或查询某一位置上的数</p><h2 id="解决方法-4">解决方法</h2><p>采用块状链表解决</p><h2 id="块状链表">块状链表</h2><p>把原来的序列分成若干块，每一块会用双向链表维护，每一段长度不定</p><ul><li>插入一段 $O(\sqrt(n))$ 首先分裂节点，然后在分裂点插入序列</li><li>删除一段 $O(\sqrt(n))$ 首先删除开头节点的后半部分，然后删除中间完整节点，最后删除结尾节点的前半部分</li><li>合并块状链表 遍历整个块状链表，若下一个点可以合并至当前点，则合并，该操作是保证时间复杂度的关键 $O(\sqrt(n))$</li></ul><h2 id="例题-3"><a href="https://www.acwing.com/problem/content/949/">例题</a></h2><h2 id="rope">rope</h2><p>这里介绍下rope容器<br>Rope其主要是结合了链表和数组各自的优点，链表中的节点指向每个数据.<br>时间复杂度为$O(n \sqrt n)$可以在很短的时间内实现快速的插入、删除和查找字符串，是一个很厉害的神器！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/rope&gt;</span><span class="hljs-comment">///头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br>rope &lt;<span class="hljs-type">int</span>&gt; x;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    x.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">///在末尾加x</span><br>    x.<span class="hljs-built_in">insert</span>(pos, x); <span class="hljs-comment">///在pos位置加入x</span><br>    x.<span class="hljs-built_in">erase</span>(pos, x); <span class="hljs-comment">///从pos位置删除x个元素</span><br>    x.<span class="hljs-built_in">copy</span>(pos, len, x); <span class="hljs-comment">///从pos开始len个元素用x代替</span><br>    x.<span class="hljs-built_in">replace</span>(pos, x); <span class="hljs-comment">///从pos开始全部换为x</span><br>    x.<span class="hljs-built_in">substr</span>(pos, x); <span class="hljs-comment">///提取pos开始x个元素</span><br>    x.<span class="hljs-built_in">at</span>(x)/[x]; <span class="hljs-comment">///访问第x个元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码-64">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/rope&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br><br>rope&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;S:&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : s)<br>        cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> opt, k, pos;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;opt, &amp;k);<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pos);<br>            s.<span class="hljs-built_in">insert</span>(pos - <span class="hljs-number">1</span>, k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s.<span class="hljs-built_in">at</span>(k - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架学习</title>
      <link href="/2022/05/06/Django%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/06/Django%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> 工程课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web学习</title>
      <link href="/2022/05/06/Web%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/06/Web%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工程课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习</title>
      <link href="/2022/05/06/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/06/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="常用文件管理命令">常用文件管理命令</h2><h3 id="linux文件系统">linux文件系统</h3><p>根目录：/<br>根目录常见文件夹</p><ol><li>bin 常用的可执行文件命令</li><li>etc 配置文件</li><li>var 日志保存</li><li>lib 安装包 头文件</li><li>home 所有用户的家目录</li><li>proc 进程相关信息</li></ol><h3 id="描述路径的方式">描述路径的方式</h3><ol><li>绝对路径 从根目录开始描述，开头一定是/</li><li>相对路径 开头一定不是/</li><li>…上级目录 .当前目录</li><li>~/ 家目录</li></ol><h3 id="文件常用指令">文件常用指令</h3><ol><li><code>ctrl c</code>：取消命令 并且换行</li><li><code>ctrl u</code>: 清空本行命令</li><li><code>tab</code>:可以补全命令和文件名 如果补全不了快速按两下tab键，可以显示备选选项</li><li><code>ls</code>：列出当前目录的所有文件<ol><li>蓝色的是文件夹</li><li>白色的是普通文件</li><li>绿色的是可执行文件</li><li><code>ls -a</code>可以展示所有文件，包括隐藏文件</li></ol></li><li><code>pwd</code>：显示当前路径</li><li><code>cd XXX</code>:进入<code>XXX</code>目录下<code>cd...</code>:返回上层目录</li><li><code>cp XXX YYY</code>:将<code>XXX</code>文件复制成<code>YYY</code> <code>XXX</code>和<code>YYY</code>可以是一个路径，比如<code>../dir_c/a.txt</code>，表示上层目录下的<code>dir_c</code>文件夹下的文件<code>a.txt</code></li><li><code>mkdir XXX</code>： 创建目录<code>XXX</code></li><li><code>rm XXX</code>: 删除普通文件 <code>rm XXX -r</code>:删除文件夹</li><li><code>mv XXX YYY</code>:将<code>XXX</code>文件移动到<code>YYY</code>和<code>cp</code>命令一样，<code>XXX</code>和<code>YYY</code>可以是一个路径， 重命名也是用这个命令</li><li><code>touch XXX</code>：创建一个文件</li><li><code>cat XXX</code>:展示文件<code>XXX</code>中的内容</li><li>复制文本windows/Linux:<code>ctrl + insert</code> Mac下：<code>command + c</code></li><li>粘贴文本windows/Linux:<code>shift + insert</code> Mac下：<code>command + v</code></li></ol><h3 id="AC-Terminaal的lab指南">AC-Terminaal的lab指南</h3><ol><li><code>homework 1 create</code>可以重新创建所有<code>lesson_1</code>的作业</li><li><code>homework 1 create id</code>可以单独创建<code>lesson_1</code>的第<code>id</code>个作业 e.g. <code>homework 1 create 0</code>可以只重新创建<code>lesson_1</code>的第<code>0</code>个作业</li><li><code>homework 1 test</code>可以评测<code>lesson_1</code>的所有作业</li><li><code>homework 1 show</code>可以显示第<code>1</code>个作业的要求</li></ol><h3 id="作业">作业</h3><ol start="0"><li>进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_0<br><span class="hljs-built_in">mkdir</span> dir_a dir_b dir_c<br></code></pre></td></tr></table></figure><ol><li>进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_1<br><span class="hljs-built_in">cp</span> a.txt a.txt.bak<br><span class="hljs-built_in">cp</span> b.txt b.txt.bak<br><span class="hljs-built_in">cp</span> c.txt c.txt.bak<br></code></pre></td></tr></table></figure><ol start="2"><li>进入入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_2<br><span class="hljs-built_in">mv</span> a.txt a_new.txt<br><span class="hljs-built_in">mv</span> b.txt b_new.txt<br><span class="hljs-built_in">mv</span> c.txt c_new.txt<br></code></pre></td></tr></table></figure><ol start="3"><li>进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_3<br><span class="hljs-built_in">mv</span> dir_a/* dir_b/<br></code></pre></td></tr></table></figure><ol start="4"><li>进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_4<br><span class="hljs-built_in">rm</span> a.txt b.txt c.txt<br></code></pre></td></tr></table></figure><ol start="5"><li>进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_5<br><span class="hljs-built_in">rm</span> * -r<br></code></pre></td></tr></table></figure><ol start="6"><li>进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_6<br><span class="hljs-built_in">cat</span> task.txt<br><span class="hljs-built_in">mkdir</span> dir_a<br><span class="hljs-built_in">mv</span> task.txt dir_a/done.txt<br></code></pre></td></tr></table></figure><ol start="7"><li>进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2， 1. 将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt; 2. 将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt; 3. 将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_7<br><span class="hljs-built_in">mkdir</span> dir_0 dir_1 dir_2<br><span class="hljs-built_in">cp</span> a.txt dir_0/a0.txt<br><span class="hljs-built_in">cp</span> a.txt dir_1/a1.txt<br><span class="hljs-built_in">cp</span> a.txt dir_2/a2.txt<br><span class="hljs-built_in">cp</span> b.txt dir_0/b0.txt<br><span class="hljs-built_in">cp</span> b.txt dir_1/b1.txt<br><span class="hljs-built_in">cp</span> b.txt dir_2/b2.txt<br><span class="hljs-built_in">cp</span> c.txt dir_0/c0.txt<br><span class="hljs-built_in">cp</span> c.txt dir_1/c1.txt<br><span class="hljs-built_in">cp</span> c.txt dir_2/c2.txt<br></code></pre></td></tr></table></figure><ol start="8"><li>进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_8<br><span class="hljs-built_in">cd</span> dir_a<br><span class="hljs-built_in">cat</span> task.txt<br><span class="hljs-built_in">rm</span> a.txt<br><span class="hljs-built_in">cd</span> ../dir_b/<br><span class="hljs-built_in">cat</span> task.txt<br><span class="hljs-built_in">mv</span> b.txt b_new.txt<br><span class="hljs-built_in">cd</span> ../dir_c/<br><span class="hljs-built_in">cat</span> task.txt<br><span class="hljs-built_in">cp</span> c.txt c.txt.bak<br></code></pre></td></tr></table></figure><ol start="9"><li>进入homework_9文件夹，将其中所有txt类型的文件删除</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_9<br><span class="hljs-built_in">rm</span> *.txt<br></code></pre></td></tr></table></figure><h2 id="tmux和vim">tmux和vim</h2><h3 id="tmux教程">tmux教程</h3><p>功能：</p><ol><li>分屏</li><li>允许断开Terminal连接后，继续运行进程<br>结构：<br>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane<br>实例：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SH">tmux:  <br>    session 0:<br>    |   window 0:<br>    |   |   pane 0<br>    |   |   pane 1<br>    |   |   pane2<br>    |   |   ...<br>    |   window 1<br>    |   window 2<br>    |   ...<br>    session 1<br>    session 2<br>    ...<br></code></pre></td></tr></table></figure><p>操作：</p><blockquote><p>AC-Terminal下前缀键被修改为<kbd>Ctrl + a</kbd>, 一般默认情况为<kbd>Ctrl + b</kbd></p></blockquote><ol><li>tmux:新建一个session，其中包含window，window中包含一个pane，pane里打开一个shell对话框</li><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按<kbd>%</kbd>:将当前pane左右平分成两个pane.</li><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按<kbd>&quot;</kbd>:将当前pane上下平分成两个pane.</li><li><kbd>Ctrl + d</kbd>：关闭当前pane；当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已经关闭，则自动关闭session。</li><li>鼠标点击可以选pane</li><li>按下<kbd>Ctrl+a</kbd>后手指松开，然后按<strong>方向键</strong>：先择相邻的pane</li><li>鼠标拖动pane之间的分割线，可以调整分割线的位置</li><li>按住<kbd>Ctrl+a</kbd>的同时按<strong>方向键</strong>，可以调整pane之间分割线的位置。</li><li>按下<kbd>Ctrl+a</kbd>后手指松开，然后按<kbd>z</kbd>：将当前pane全屏/取消全屏</li><li>按下<kbd>Ctrl+a</kbd>后手指松开，然后按d：挂起当前<strong>session</strong></li><li><kbd>tmux a</kbd>：打开之前挂起的session。</li><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按s，选择其他session。1.方向键——<code>上</code>：选择上一项session/window/pane 2.方向键——下：选择下一项session/window/pane 3. 方向键——<code>右</code>：展开当前项session/window 4.方向键——<code>左</code>：闭合当前项session/window</li><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按<code>c</code>:在当前session中创建一个新的window。</li><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按<code>w</code>：选择其他window，操作方法与(12)完全相同。</li><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按<code>PageUp</code>：翻阅当前pane的内容</li><li>鼠标滚轮：翻阅当前pane内的内容</li><li>在tmux中选中文本时，需要按住<code>shift</code>键。（仅支持window和linux，不支持Mac，不过该操作不是必须的，因此影响不大）</li><li>tmux中复制/粘贴文本的通用方式：<ol><li>按下<kbd>Ctrl + a</kbd>后手指松开，然后按<code>[</code></li><li>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪切板</li><li>按下<code>Ctrl + a</code>后松开手指，然后按<code>]</code>，会将剪切板中的内容粘贴到光标处</li></ol></li></ol><h3 id="vim教程">vim教程</h3><p><strong>功能</strong>：1.命令行模式下的文本编辑器。2.根据文件拓展名自动判别编程语言。支持代码缩进，代码高亮等功能，3.使用方式：<code>vim filename</code>1.如果已有文件，则打开它2.如果没有文件，则打开一个新的文件，并命名为filename<br><strong>模式</strong>1.一般命令模式 默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可出现不同的操作，可以复制，粘贴，删除文本等。2.编辑模式在一般命令模式里按下i，会进入编辑模式。按下<code>ESC</code>会退出<code>编辑模式</code>，返回<code>一般命令模式</code>3.<strong>命令行模式</strong>在<strong>一般命令模式</strong>里按下<code>:/?</code>三个字母中的任意一个，会进入<strong>命令行模式</strong>。命令行在最下面。可以查找，替换，保存，退出，配置编辑器等。<br>操作：</p><ol><li>一般模式切换到编辑模式（常用）<ol><li><code>i</code>:从光标所处位置<strong>直接</strong>开始</li><li><code>a</code>:从光标所处位置<code>下一个字符</code>开始</li><li><code>o</code>：从光标所处位置的<code>下一行</code>开始</li><li><code>r</code>:取代当前光标处的字符，然后开始</li><li><code>[ESC]</code>：退出编辑模式，回到一般模式</li></ol></li><li>光标移动操作<ol><li><code>h</code>或<code>左箭头键</code>：光标向<code>左</code>移动 <code>一个字符</code></li><li><code>j</code> 或 <code>向下箭头</code>： 光标向<code>下</code>移动<code>一个字符</code></li><li><code>k</code>或<code>向上箭头</code>：光标向<code>上</code>移动<code>一个字符</code></li><li><code>l</code>或<code>向右箭头</code>:光标向<strong>右</strong>移动<code>一个字符</code></li><li>n<Space>：n为数字，光标向右移动这一行的n个字符</li><li>n<Enter>:n为数字，光标<strong>向下移动n行</strong></li><li><code>0</code>或<code>功能键[Home]</code>：光标移动到<strong>本行开头</strong></li><li><code>$</code>或<code>功能键[End]</code>:光标移动到<strong>本行末尾</strong></li><li><code>G</code>：光标移动到<strong>最后一行</strong></li><li><code>:n</code>或<code>nG</code>:<strong>n</strong>为数字，光标移动到<strong>第n行</strong></li><li><code>gg</code>:光标移动到<strong>第一行</strong>，相当于<code>1G</code></li></ol></li><li>查找，替换操作<ol><li><code>/word</code>：向<strong>光标之下</strong> <strong>寻找</strong>第一个值为<code>word</code>的字符串</li><li><code>?word</code>：向<strong>光标之上</strong> <strong>寻找</strong>第一个值为<code>word</code>的字符串</li><li><code>n</code>:<strong>重复</strong>前一个<strong>查找操作</strong></li><li><code>N</code>:反向<strong>重复</strong>前一个<strong>查找操作</strong></li><li><code>:n1,n2s/word1/word2/g</code>：<code>n1</code>与<code>n2</code>为数字，在第<code>n1</code>行与<code>n2</code>行之间寻找<code>word1</code>这个字符串，并将改字符串<strong>替换</strong>为<code>word2</code></li><li><code>:1,$s/word1/word2/g</code>：将全文的<code>word1</code>替换为<code>word2</code></li><li><code>:1,$s/word1/word2/gc</code>:将全文的<code>word1</code>替换为<code>word2</code>，且在替换前<strong>要求用户确认</strong></li></ol></li><li>文本操作（可搭配<code>数字+&lt;enter&gt;/&lt;space&gt;、0、G、$</code>等使用，达到预期组合效果）<ol><li><code>v</code>：选中文本</li><li><code>d</code>:<strong>删除选中的文本</strong></li><li><code>dd</code>:删除当前行</li><li><code>y</code>:复制选中的文本</li><li><code>yy</code>:复制当前行</li><li><code>p</code>:将复制的数据在光标的下一行/下一位置 <strong>粘贴</strong></li><li><code>u</code>：撤销</li><li><kbd>Ctrl + r</kbd>取消撤销</li><li><kbd>shift+&gt;</kbd>：将选中的文本整体 <strong>向右缩进一次</strong></li><li><kbd>shift+&lt;</kbd>： 将选中的文本整体 <strong>向左缩进一次</strong></li></ol></li><li>命令行操作<ol><li><code>:w</code>：保存</li><li><code>:w!</code>：强制保存</li><li><code>:q</code>:退出</li><li><code>:q!</code>:强制退出</li><li><code>:wq</code>：保存并退出</li><li><code>:set paste</code>：设置成粘贴模式，取消代码的自动缩进</li><li><code>:set nopaste</code>:取消粘贴模式，开启代码自动缩进</li><li><code>:set nu</code>:显示行号</li><li><code>:set nonu</code>:隐藏行号</li><li><code>:noh</code> 关闭查找关键词高亮</li></ol></li><li><code>gg=G</code>将全文代码格式化</li><li><kbd>Ctrl + q</kbd>：当vim卡死时，可以<strong>取消当前正在执行的命令</strong></li><li>异常处理<ol><li>每次用vim编辑文件，会自动创建一个filename.swp的临时文件</li><li>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</li></ol></li><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件即可</li></ol><h3 id="作业-2">作业</h3><ol start="0"><li>进入homework_0文件夹，创建文件names.txt，并顺次将下列姓名写入该文件，每个名字占一行。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_0<br>vim names.txt<br>输入 i 进入编辑模式<br>依次输入各个单词<br>按ESC返回一般命令模式  <br>按 :wq 保存并退出<br></code></pre></td></tr></table></figure><ol><li>进入homework_1文件夹，打开problem.txt，并依次删除下列字符：<br>最后一行第101个字符<br>第3行第8个字符<br>第1行第30个字符<br>第16行第55个字符<br>第9行第80个字符<br>最后保存文件并退出</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_0<br>vim names.txt<br>输入 i 进入编辑模式<br>依次输入各个单词<br>按ESC返回一般命令模式  <br>按 :wq 保存并退出<br></code></pre></td></tr></table></figure><ol start="2"><li>进入homework_2文件夹，打开problem.txt，并依次执行如下操作： 1. 在第1个&quot;two&quot;的后面添加&quot;abc&quot; 2. 在第2个&quot;two&quot;的前面添加&quot;def&quot; 3. 将第3个&quot;two&quot;后面的连续12个字符删掉 4. 将第4个&quot;two&quot;所在的行删掉<br>最后保存文件并退出。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_1<br>vim problem.txt<br>[1] 最后一行第101个字符：G101&lt;Space&gt;i&lt;Backspace&gt;ESC<br>[2] 第3行第8个字符：3G8&lt;Space&gt;i&lt;Backspace&gt;ESC<br>[3] 第1行第30个字符：gg30&lt;Space&gt;i&lt;Backspace&gt;ESC<br>[4] 第16行第55个字符：:16&lt;Enter&gt;55&lt;Space&gt;i&lt;Backspace&gt;ESC<br>[5] 第9行第80个字符：9G80&lt;Space&gt;i&lt;Backspace&gt;ESC<br>:wq&lt;Enter&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>进入homework_3文件夹，打开problem.txt，并依次执行如下操作：<br>将第5行至第15行中所有 of 替换成 OF<br>将全文中所有的 the 替换成 THE<br>将第偶数个 is替换成 IS，第奇数个 is不变(下标从1开始)</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_3<br>vim problem.txt  <br>[1] 将第5行至第15行中所有of替换成OF  :5,15s/of/OF/g<br>[2] 将全文中所有的the替换成THE  :1,<span class="hljs-variable">$s</span>/the/THE/g<br>[3] 将第偶数个is替换成IS，第奇数个is不变(下标从1开始)  :1,<span class="hljs-variable">$s</span>/is/IS/gc  然后ny交替按即可<br>:wq&lt;Enter&gt;<br></code></pre></td></tr></table></figure><ol start="4"><li>进入homework_4文件夹，打开problem.txt，并依次执行如下操作：<br>删除第11行<br>将所删除的行粘贴到文件最后一行的下一行</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_4<br>vim problem.txt<br>[1] 删除第11行  11Gdd<br>[2] 将所删除的行粘贴到文件最后一行的下一行  Gp<br>[3] 复制第5行  5Gyy<br>[4] 将所复制的行粘贴到文件当前最后一行的下行  Gp<br>:wq&lt;Enter&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>进入homework_5文件夹，打开problem.txt，并依次执行如下操作：<br>删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）<br>将所删除的内容粘贴到文件末尾（注意不要另起一行）<br>复制第5行第88个字符（包含该字符）至第7行第6个字符（包含该字符）<br>将所复制的内容粘贴到当前文件末尾（注意不要另起一行）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_5<br>vim problem.txt<br>[1] 删除第11行第15个字符（包含该字符）至第13行第5个字符（包含该字符）  11G14&lt;Space&gt;v13G5&lt;Space&gt;d<br>[2] 将所删除的内容粘贴到文件末尾（注意不要另起一行）  G<span class="hljs-variable">$p</span><br>[3] 复制第5行第88个个字符（包含该字符）至第7行第6个字符（包含该字符）  5G87&lt;Space&gt;v7G6&lt;Space&gt;y<br>[4] 将所复制的内容粘贴到当前文件末尾（注意不要另起一行） G<span class="hljs-variable">$p</span><br>:wq&lt;Enter&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li>进入homework_6文件夹，并依次执行如下操作：<br>清空source0.cpp<br>将source1.cpp中的第1-3行和第12-24行复制到source0.cpp中</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_6<br>vim source0.cpp<br><span class="hljs-built_in">cd</span> homework_6<br>vim source0.cpp<br><br>ggdG  <span class="hljs-comment"># 删掉全文</span><br><br>Ctrl + a + <span class="hljs-string">&quot;   # 在tmux中打开一个新的pane</span><br><span class="hljs-string">vim source1.cpp</span><br><span class="hljs-string">:set nonu  删掉行号</span><br><span class="hljs-string">使用tmux的复制模式(Ctrl-a, [)复制source1.cpp的第1-3行</span><br><span class="hljs-string">选择source0.cpp所在的pane</span><br><span class="hljs-string">:set paste 进入粘贴模式</span><br><span class="hljs-string">i进入编辑模式</span><br><span class="hljs-string">使用tmux的粘贴模式(Ctrl-a, ])粘贴内容。</span><br><span class="hljs-string"></span><br><span class="hljs-string">同理操作source1.cpp的第12-24行</span><br><span class="hljs-string"></span><br><span class="hljs-string">保存source0.cpp  :wq</span><br><span class="hljs-string">退出source1.cpp  :q</span><br></code></pre></td></tr></table></figure><ol start="7"><li>进入homework_7文件夹，格式化source.cpp</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_7<br>vim source.cpp<br>gg=G  全文格式化<br><br>:wq&lt;Enter&gt;<br></code></pre></td></tr></table></figure><ol start="8"><li>进入homework_8文件夹，打开source.cpp，并依次执行如下操作：<br>将第15-21行向右缩进2次<br>将第22-23行向左缩进1次</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework_8<br>vim source.cpp<br>15Gv21G <span class="hljs-comment"># 选中15-21行</span><br>&gt; <span class="hljs-comment"># 向右缩进一次</span><br><span class="hljs-comment"># 同理再缩进一次</span><br><br>22Gv23G <span class="hljs-comment"># 选中22-23行</span><br>&lt; <span class="hljs-comment"># 向左缩进一次</span><br><br>:wq&lt;Enter&gt;<br></code></pre></td></tr></table></figure><ol start="9"><li>进入homework_9文件夹，打开链接：<a href="https://www.acwing.com/activity/content/code/content/1694465/">https://www.acwing.com/activity/content/code/content/1694465/</a> 新建文件source.cpp，将链接中的代码抄进source.cpp文件中。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework/lesson_2/homework_9<br>vim source.cpp<br>i<br><span class="hljs-comment">#include &lt;iostream&gt;</span><br><br>using namespace std;<br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>    int a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-string">a + b &lt;&lt; endl;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">:wq&lt;Enter&gt;</span><br></code></pre></td></tr></table></figure><h2 id="shell语法">shell语法</h2><h3 id="概论">概论</h3><p>Shell是一个用c语言编写的程序，他是用户使用Linux的桥梁。<br>Shell既是一种命令语言，又是一种程序设计语言。<br>Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。<br>Ken Thompson 的sh 是第一种Unix Shell，Window Explorer是一个典型的图形界面Shell。<br><strong>脚本示例</strong><br><a href="http://xn--test-k84fui098hxhl.sh">新建一个test.sh</a>，内容如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>运行方式</strong><br>作为可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">chmod</span> +x test.h <span class="hljs-comment"># 使脚本具有可执行权限  </span><br>acs@9e0ebfcd82d7:~$ ./test.sh <span class="hljs-comment"># 当前路径执行</span><br>Hello World! <span class="hljs-comment"># 脚本输出</span><br></code></pre></td></tr></table></figure><p>用解释器执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ bash test.sh<br>Hello World!  <span class="hljs-comment"># 脚本输出</span><br></code></pre></td></tr></table></figure><h3 id="注释">注释</h3><p><strong>单行注释</strong><br>每行中<code>#</code>之后的内容均是注释。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 这是一行注释</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hello World&#x27;</span> <span class="hljs-comment"># 这也是一行注释</span><br></code></pre></td></tr></table></figure><p><strong>多行注释</strong><br>格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH">:&lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">第一行注释</span><br><span class="hljs-string">第二行注释</span><br><span class="hljs-string">第三行注释</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>其中EOF可以换成其他任意字符串，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SH">:&lt;&lt;<span class="hljs-string">abc</span><br><span class="hljs-string">第一行注释</span><br><span class="hljs-string">第二行注释</span><br><span class="hljs-string">第三行注释</span><br><span class="hljs-string">abc</span><br><br>:&lt;&lt;!<br>第一行注释<br>第二行注释<br>第三行注释<br>!<br></code></pre></td></tr></table></figure><h3 id="变量">变量</h3><p><strong>定义变量</strong><br>定义变量，不需要加$符号，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">name1=<span class="hljs-string">&#x27;yxc&#x27;</span> <span class="hljs-comment"># 单引号定义字符串</span><br>name2=<span class="hljs-string">&#x27;yxc&#x27;</span> <span class="hljs-comment"># 双引号定义字符串</span><br>name3=yxc <span class="hljs-comment"># 也可以不加引号，同样表示字符串</span><br></code></pre></td></tr></table></figure><p><strong>使用变量</strong><br>使用变量，需要加上<code>$</code>符号，或者<code>$&#123;&#125;</code>符号。花括号是可选的，主要是为了帮助解释器识别变量边界。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=yxc<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span> <span class="hljs-comment"># 输出yxc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name&#125;</span> <span class="hljs-comment"># 输出yxc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name&#125;</span>acwing <span class="hljs-comment"># 输出yxcacwing</span><br></code></pre></td></tr></table></figure><p><strong>只读变量</strong><br>使用<code>readonly</code>或者<code>declare</code>可以将变量变为只读</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=yxc<br><span class="hljs-built_in">readonly</span> name<br><span class="hljs-built_in">declare</span> -r name <span class="hljs-comment"># 两种写法均可  </span><br><br>name=abc <span class="hljs-comment"># 会报错，因为此时name为只读</span><br></code></pre></td></tr></table></figure><p><strong>删除变量</strong><br><code>unset</code>可以删除变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=yxc<br><span class="hljs-built_in">unset</span> name <br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span> <span class="hljs-comment"># 输出空行</span><br></code></pre></td></tr></table></figure><p><strong>变量类型</strong></p><ol><li>自定义变量（局部变量）子进程不能访问的变量</li><li>环境变量（全局变量）子进程可以访问的变量</li></ol><p>自定义变量改为环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ name = yxc <span class="hljs-comment"># 定义变量</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">export</span> name <span class="hljs-comment"># 第一种方法</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">declare</span> -x name <span class="hljs-comment"># 第二种方法</span><br></code></pre></td></tr></table></figure><p>环境变量改为自定义变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">export</span> name = yxc  <span class="hljs-comment"># 定义环境变量</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">declare</span> +x  name   <span class="hljs-comment"># 改为自定义变量</span><br></code></pre></td></tr></table></figure><p><strong>字符串</strong><br>字符串可以用单引号，也可以用双引号，也可以不用引号。<br>单引号和双引号的区别：</p><ol><li>单引号中的内容会原样输出，不会执行，不会取变量</li><li>双引号中的内容可以执行，可以取变量</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">name = yxc <span class="hljs-comment"># 不用引号</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello, $name \&quot;hh\&quot;&#x27;</span> <span class="hljs-comment"># 单引号字符串，输出hello,$name \&quot;hh\&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello, <span class="hljs-variable">$name</span> \&quot;hh\&quot;&quot;</span> <span class="hljs-comment"># 双引号字符串，输出hello,yxc &quot;hh&quot;</span><br></code></pre></td></tr></table></figure><p><strong>获取字串长度</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">name = yxc<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#name&#125;</span> <span class="hljs-comment"># 输出3</span><br></code></pre></td></tr></table></figure><p><strong>提取字串</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=<span class="hljs-string">&quot;hello, yxc&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name:0:5&#125;</span> <span class="hljs-comment"># 提取从0开始的5个字符</span><br></code></pre></td></tr></table></figure><h3 id="默认变量">默认变量</h3><p><strong>文本参数变量</strong><br>在执行shell脚本时，可以向脚本传递参数。<br><code>$1</code>是第一个参数，<code>$2</code>是第二个参数，以此类推。特殊的，<code>$0</code>是文件名（包括路径）。例如：<br>创建文件<code>test.sh</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件名：&quot;</span> <span class="hljs-variable">$0</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数：&quot;</span><span class="hljs-variable">$1</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数：&quot;</span><span class="hljs-variable">$2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数:&quot;</span> <span class="hljs-variable">$3</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第四个参数: &quot;</span> <span class="hljs-variable">$4</span><br></code></pre></td></tr></table></figure><p>然后执行该脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">chmod</span> +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4<br>文件名: ./test.sh <br>第一个参数: 1<br>第二个参数: 2 <br>第三个参数: 3 <br>第四个参数: 4 <br>其他参数相关变量<br></code></pre></td></tr></table></figure><p><strong>其他参数相关变量</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>$#</code></td><td style="text-align:center">代表文件传入参数的个数，如上例中值为4</td></tr><tr><td style="text-align:center"><code>$*</code></td><td style="text-align:center">由所有参数构成的用空格隔开的字符串，等价上例中的<code>&quot;$1 $2 $3 $4&quot;</code></td></tr><tr><td style="text-align:center"><code>$@</code></td><td style="text-align:center">每个参数分别用双括号括起来的字符串，等价于上例中<code>&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot;</code></td></tr><tr><td style="text-align:center"><code>$$</code></td><td style="text-align:center">脚本当前运行的进程ID</td></tr><tr><td style="text-align:center"><code>$?</code></td><td style="text-align:center">上一条命令的退出状态（exit code),0表示正常退出，其他值表示错误</td></tr><tr><td style="text-align:center"><code>$(command)</code></td><td style="text-align:center">返回<code>command</code>这条命令的stdout（可嵌套）</td></tr><tr><td style="text-align:center"><code>command</code></td><td style="text-align:center">返回<code>command</code>这条命令的stdout(不可嵌套)</td></tr></tbody></table><h3 id="expr命令">expr命令</h3><p><code>expr</code>命令用于求表达式的值，格式为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">expr</span> 表达式<br></code></pre></td></tr></table></figure><p><strong>表达式说明:</strong></p><ul><li>空格隔开每一项</li><li>用反斜杠放到shell特定的字符前面（发现表达式运行错误时，可以试试转义）</li><li>对包含空格和其他特殊符号的字符串要用引号括起来</li><li>expr会在<code>stdout</code>中输出结果。如果为逻辑关系表达式，则结果为真，<code>stdout</code>为<code>1</code>，否则为<code>0</code>.</li><li>expr的<code>exit code</code>: 如果为逻辑关系表达式，则结果为真，<code>exit code</code>为<code>0</code>,否则为<code>1</code>.</li></ul><p><strong>字符串表达式</strong></p><ul><li><code>length STRING</code>: 返回STRING的长度</li><li><code>index STRING CHARSET</code>:<code>CHARSET</code>中任意单个字符在<code>STRING</code>中最前面的字符位置，下标从<code>1</code>开始。如果在<code>STRING</code>中完全不存在<code>CHARSET</code>中的字符，则返回<code>0</code></li><li><code>substr STRING POSITION LENGTH</code>:返回<code>STRING</code>字符串中从<code>POSITION</code>开始，长度最大为<code>LENGTH</code>的子串。如果<code>POSITION</code>或<code>LENGTH</code>为负数,<code>0</code>为非数值，则返回空字符串。<br>示例：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH">str = <span class="hljs-string">&quot;Hello World!&quot;</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> length <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span>` <span class="hljs-comment"># ``不是单引号，表示执行命令，输出出12</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> index <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span> aWd` <span class="hljs-comment"># 输出7，下标从1开始</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> substr <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span> 2 3` <span class="hljs-comment"># 输出 ell</span><br></code></pre></td></tr></table></figure><p><strong>整数表达式</strong></p><ul><li><code>expr</code>支持普通的算数操作，算术表达式优先级低于字符串表达式，高于逻辑表达式。</li><li><code>+ -</code> 加减运算。两端参数会转换为整数，如果转换失败组会报错</li><li><code>()</code>可以该表优先级，但是需要反斜杠转义<br><strong>实例：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SH">a=3<br>b=4<br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出7</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出-1</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \* <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出12 *需要转义</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> / <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出0，整除</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> % <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出3 </span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> \( <span class="hljs-variable">$a</span> + 1 \) \* \( <span class="hljs-variable">$b</span> + 1 \)` <span class="hljs-comment"># 输出20，值为(a + 1) * (b + 1)</span><br></code></pre></td></tr></table></figure><p><strong>逻辑表达式</strong></p><ul><li><code>|</code>如果第一个参数非空且非零，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0，如果第一个参数是非空或非0时，不会计算第二个参数。</li><li><code>&amp;</code>如果两个参数都非空且非零，则返回第一个参数，否则返回0.如果第一个参为0或为空，则不会计算第二个参数。</li><li>$&lt; \leq = == \ne \geq &gt;$ 比较两端的参数，如果为true，则返回1，否则返回0，“==”是“=”的同义词。“expr”首先尝试将两端的参数转换为整数，并作算术比较，如果转换失败，则按字符集排序做字符比较。</li><li><code>()</code>可以表该优先级，但是需要反斜杠转义<br>示例：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SH">a = 3<br>b = 4<br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> &gt; <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出0，&gt;需要转义</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出1，也可以将特殊字符用引号引起来</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> <span class="hljs-string">&#x27;&gt;=&#x27;</span> <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出0</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \&lt;\= <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出1</span><br><br>c = 0<br>d = 5<br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$c</span> \&amp; <span class="hljs-variable">$d</span>` <span class="hljs-comment"># 输出0</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \&amp; <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出3</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$c</span> \| <span class="hljs-variable">$d</span>` <span class="hljs-comment"># 输出5</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \| <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出3</span><br></code></pre></td></tr></table></figure><h3 id="read命令">read命令</h3><p><code>read</code>命令用于从标准输入中读取单行数据。当读到文件结束符，<code>exit code</code>为<code>1</code>,否则为<code>0</code>.<br>参数说明</p><ul><li><code>-p</code>:后面可以接提示信息</li><li><code>-t</code>:后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令<br>实例：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">read</span> name <span class="hljs-comment"># 读入name的值</span><br>acwing yxc <span class="hljs-comment"># 标准输入</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span> <span class="hljs-comment"># 输出name的值</span><br>acwing yxc <span class="hljs-comment"># 标准输出</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please input your name：&quot;</span> -t 30 name<br><span class="hljs-comment"># 读入name的值，等待时间为30秒</span><br>Please input your name:acwing yxc <span class="hljs-comment"># 标准输入</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span> <span class="hljs-comment"># 输出name的值</span><br>acwing yxc <span class="hljs-comment"># 标准输出</span><br></code></pre></td></tr></table></figure><h3 id="echo命令">echo命令</h3><p><code>echo</code>用于输出字符串<br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> STRING<br></code></pre></td></tr></table></figure><p><strong>显示普通字符串</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello AC Terminal&quot;</span><br><span class="hljs-built_in">echo</span> Hello AC Terminal <span class="hljs-comment"># 引号可以忽略</span><br></code></pre></td></tr></table></figure><p><strong>显示转义字符</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\&quot;Hello AC Terminal \&quot;&quot;</span> <span class="hljs-comment"># 注意只能使用双引号，如果使用单引号，则不转义</span><br><span class="hljs-built_in">echo</span> \&quot;Hello AC Terminal\&quot; <span class="hljs-comment"># 也可以忽略双引号</span><br></code></pre></td></tr></table></figure><p><strong>显示变量</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=yxc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;My name is <span class="hljs-variable">$name</span>&quot;</span> <span class="hljs-comment"># 输出 My name is yxc</span><br></code></pre></td></tr></table></figure><p><strong>显示换行</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Hi\n&quot;</span> <span class="hljs-comment"># -e 开启转义</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;acwing&quot;</span><br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">Hi<br><br>acwing <br></code></pre></td></tr></table></figure><p><strong>实现不换行</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Hi \c&quot;</span> <span class="hljs-comment"># -e 开启转义 \c 不换行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;acwing&quot;</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">Hi acwing<br></code></pre></td></tr></table></figure><p><strong>显示结果定向文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span> &gt; output.txt <span class="hljs-comment"># 将内容以覆盖的方式输出到output.txt中</span><br></code></pre></td></tr></table></figure><p><strong>原样输出字符串</strong>，不进行转义或取变量（用单引号）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=acwing<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$name\&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-variable">$name</span>\&quot;<br></code></pre></td></tr></table></figure><p><strong>显示命令的执行结果</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">date</span>`<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Wed Sep 1 11:45:33 CST 2021<br></code></pre></td></tr></table></figure><h3 id="printf命令">printf命令</h3><p><code>printf</code>命令用于格式化输出，类似于C/C++中的<code>printf</code>函数。<br>默认不会在字符串末尾添加换行符。<br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">printf</span> format-string [arguments ...]<br></code></pre></td></tr></table></figure><p><strong>用法示例</strong><br>脚本内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%10d.\n&quot;</span> 123 <span class="hljs-comment"># 占10位，右对齐</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;-10.2f.\n&quot;</span> 123.123321 <span class="hljs-comment"># 占10位，保留两位小数，左对齐 </span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;My name is %s\n&quot;</span> <span class="hljs-string">&quot;yxc&quot;</span> <span class="hljs-comment"># 格式化输出字符串</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%d * %d = %d\n&quot;</span> 2 3 `<span class="hljs-built_in">expr</span> 2 \* 3` <span class="hljs-comment"># 表达式的值作为参数</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH">       123.<br>123.12    .<br>My name is yxc<br>2 * 3 = 6<br></code></pre></td></tr></table></figure><h3 id="test命令与判断符号">test命令与判断符号</h3><p>逻辑运算符<code>&amp;&amp;</code>和<code>||</code></p><ul><li><code>&amp;&amp;</code>表示与，<code>||</code>表示或</li><li>二者具有短路原则：<code>expr1 &amp;&amp; expr2</code>:当<code>expr</code>为假时，直接忽略<code>expr2</code> <code>expr1 ||  expr2</code>:当<code>expr1</code>为真时，直接忽略<code>expr2</code></li><li>表达式<code>exit code</code>为<code>0</code>，表示真，为<code>非零</code>,表示假的<br><strong>test命令</strong><br>在命令行中输入<code>man test</code>,可以直接查看test命令的用法。<br><code>test</code>命令用于判断文件类型，以及对变量做比较。<br><code>test</code>命令用<code>exit code</code>返回结果，而不是使用<code>stdout</code>.<code>0</code>表示<code>真</code>，<code>非0</code>表示<code>假</code><br>例如：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">test</span> 2 -lt 3 <span class="hljs-comment"># 为真，返回值为0  </span><br><span class="hljs-built_in">echo</span> $? <span class="hljs-comment"># 输出上一个命令的返回值，输出0</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">ls</span>  <span class="hljs-comment"># 列出当前目录下的所有文件</span><br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">test</span> -e test.sh &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not exist&quot;</span><br>exist  <span class="hljs-comment"># test.sh 文件存在</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">test</span> -e test2.sh &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not exist&quot;</span><br>Not exist  <span class="hljs-comment"># testh2.sh 文件不存在</span><br></code></pre></td></tr></table></figure><p><strong>文件类型判断</strong><br>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">test -e filename # 判断文件是否存在<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试参数</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>-e</code></td><td style="text-align:center">文件是否存在</td></tr><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center">是否为文件</td></tr><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">是否为目录</td></tr></tbody></table><p><strong>文件权限判断</strong><br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">test</span> -r filename <span class="hljs-comment"># 判断文件是否可读</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试参数</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:center">文件是否可读</td></tr><tr><td style="text-align:center"><code>-w</code></td><td style="text-align:center">文件是否可写</td></tr><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">文件是否可执行</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">是否是非空文件</td></tr></tbody></table><p><strong>整数间比较</strong><br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">test</span> <span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> <span class="hljs-comment"># a是否等于b</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试参数</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>-eq</code></td><td style="text-align:center">a是否等于b</td></tr><tr><td style="text-align:center"><code>-ne</code></td><td style="text-align:center">a是否不等于b</td></tr><tr><td style="text-align:center"><code>-gt</code></td><td style="text-align:center">a是否大于b</td></tr><tr><td style="text-align:center"><code>-lt</code></td><td style="text-align:center">a是否小于b</td></tr><tr><td style="text-align:center"><code>-ge</code></td><td style="text-align:center">a是否大于等于b</td></tr><tr><td style="text-align:center"><code>-le</code></td><td style="text-align:center">a是否小于等于b</td></tr></tbody></table><p><strong>字符串比较</strong></p><p>| 测试参数 | 代表意义 |<br>| <code>test -z STRING</code> |  判断<code>STRING</code>是否为空，如果为空，则返回true |<br>| <code>test -n STRING</code> |  判断<code>STRING</code>是否为空，如果非空，则返回true (-n可以忽略) |<br>| <code>test str1 == str2</code> | 判断<code>str1</code>是否等于<code>str2</code> |<br>| <code>test str1 $\ne$ str2</code> | 判断<code>str1</code>是否等于<code>str2</code> |</p><p><strong>多重条件判定</strong><br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">test</span> -r filename -a -x filename<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试参数</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center">两条件是否同时成立</td></tr><tr><td style="text-align:center"><code>-o</code></td><td style="text-align:center">两条件是否至少一个成立</td></tr><tr><td style="text-align:center"><code>!</code></td><td style="text-align:center">取反，如<code>test ! -x file</code>,当<code>file</code>不可执行时，返回true</td></tr></tbody></table><p><strong>判断符号[]</strong><br><code>[ ]</code>与<code>test</code>用法几乎一模一样，更常用于<code>if</code>语句中，另外<code>[[]]</code>是<code>[]</code>的加强版，支持的特性更多。<br>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SH">[ 2 -lt 3 ]  <span class="hljs-comment"># 为真，返回值为0</span><br><span class="hljs-built_in">echo</span> $?  <span class="hljs-comment"># 输出上个命令的返回值，输出0</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">ls</span>  <span class="hljs-comment"># 列出当前目录下的所有文件</span><br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not exist&quot;</span><br>exist  <span class="hljs-comment"># test.sh 文件存在</span><br>acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not exist&quot;</span><br>Not exist  <span class="hljs-comment"># testh2.sh 文件不存在</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>[ ]</code>内每一项都要用空格隔开</li><li>中括号内的变量最好用双引号括起来</li><li>中括号内的常数，最好用单或双引号括起来</li></ul><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">name=<span class="hljs-string">&quot;acwing yxc&quot;</span><br>[ <span class="hljs-variable">$name</span> == <span class="hljs-string">&quot;acwing yxc&quot;</span> ] <span class="hljs-comment"># 错误，等价于[ acwing yxc == &quot;acwing yxc&quot; ],参数太多</span><br>[ <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> == <span class="hljs-string">&quot;acwing yxc&quot;</span> ] <span class="hljs-comment"># 正确  </span><br></code></pre></td></tr></table></figure><h3 id="判断语句">判断语句</h3><p><strong>if…then形式</strong><br>类似于C/C++中的if-else语句。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">if</span> condition <br><span class="hljs-keyword">then</span> <br>    语句一<br>    语句二<br><span class="hljs-keyword">elif</span> condition<br><span class="hljs-keyword">then</span> <br>    语句一<br>    语句二<br>    ...<br><span class="hljs-keyword">elif</span> condition<br><span class="hljs-keyword">then</span> <br>    语句一<br>    语句二<br><span class="hljs-keyword">else</span><br>    语句一<br>    语句二<br>    ...<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><strong>case…esac形式</strong><br>类似于C/C++中的switch语句</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">case</span> $变量名称 <span class="hljs-keyword">in</span><br>    值1）<br>语句一<br>语句二<br>...<br>;; <span class="hljs-comment"># 类似于C/C++中的break</span><br>    值2）<br>语句一<br>语句二<br>...<br>;;<br>    *)  <span class="hljs-comment"># 类似于C/C++中的defalut</span><br>语句一<br>语句二<br>...<br>;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><h3 id="循环语句">循环语句</h3><p><strong>for…in…都…done</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> val1 val2 val3<br><span class="hljs-keyword">do</span> <br>    语句1<br>    语句2<br>    ...<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>示例1，输出<code>a 2 cc</code>，每个元素一行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a 2 cc <br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>示例2，输出当前路径下的所有文件名，每个文件名一行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span>  `<span class="hljs-built_in">ls</span>`<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$file</span><br></code></pre></td></tr></table></figure><p>示例3，输出<code>1-10</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 1 10)<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>示例4，使用{1…10}或者{a…z}</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;a...z&#125;<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>for((…;…;…))do…done</strong><br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">for</span> ((expression; condition; expression))<br><span class="hljs-keyword">do</span> <br>    语句1<br>    语句2<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>while…do…done循环</strong><br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span> <br>    语句1<br>    语句2<br>    ...<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>示例，文件结束符为<code>Ctrl+d</code>，输入文件结束符后<code>read</code>指令后返回</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> name<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>死循环的处理方式</strong><br>如果AC Terminal可以打开该程序，则输入<code>Ctrl+c</code>即可<br>否则可以直接关闭进程：<br>使用<code>top</code>命令找到该进程<code>PID</code><br>输入<code>kill -9 PID</code>即可关掉此进程</p><h3 id="函数">函数</h3><p><code>bash</code>中的函数类似于C/C++中的函数<br>但<code>return</code>的返回值与与C/C++不同，返回的是<code>exit code</code>,取值为<code>0-255</code>,<code>0</code>表示正常结束<br>如果想要获取函数的输出结果，可以通过<code>echo</code>输出到<code>stdout</code>中<br>然后通过<code>$(function_name)</code>来获取<code>stdout</code>中的结果。<br>函数<code>return</code>值可以通过<code>$?</code>来获取<br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH">[<span class="hljs-keyword">function</span>] <span class="hljs-function"><span class="hljs-title">func_name</span></span>() &#123; <span class="hljs-comment"># function关键字可以省略</span><br>    语句1<br>    语句2<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>不获取return和stdout值</strong><br>示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<br>    name = yxc<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>&quot;</span><br>&#125;<br><br>func<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">Hello yxc<br></code></pre></td></tr></table></figure><p><strong>获取return值和stdout值</strong><br>不写return时，默认return 0<br>示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<br>    name=yxc<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>&quot;</span><br><br>    <span class="hljs-built_in">return</span> 123<br>&#125;<br><br>output=$(func)<br>ret=$?<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ouput=<span class="hljs-variable">$ouput</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;return=<span class="hljs-variable">$ret</span>&quot;</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">output=Hello yxc<br><span class="hljs-built_in">return</span> = 123<br></code></pre></td></tr></table></figure><p><strong>函数的输入参数</strong><br>在函数中，<code>$1</code>表示第一个输入参数，<code>$2</code>表示第二个输入参数，以此类推<br>注意：函数内<code>$0</code>仍然是文件名，而不是函数名<br>示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123; <span class="hljs-comment"># 递归计算$1 + ($1 - 1) + ($1 - 2) + ... + 0</span><br>    word = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;word&#125;</span>&quot;</span> != <span class="hljs-string">&#x27;y&#x27;</span> ] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;word&#125;</span>&quot;</span> != <span class="hljs-string">&#x27;n&#x27;</span> ]<br>    <span class="hljs-keyword">do</span> <br>        <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;要进入func(<span class="hljs-variable">$1</span>)函数吗？请输入y/n:&quot;</span> word<br>    <span class="hljs-keyword">done</span><br><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$word</span>&quot;</span> == <span class="hljs-string">&#x27;n&#x27;</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> 0<br>        <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-keyword">fi</span><br><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -le 0 ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> 0<br>        <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-keyword">fi</span><br><br>    <span class="hljs-built_in">sum</span> = $(func $(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$1</span> - 1))<br>    <span class="hljs-built_in">echo</span> $(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$sum</span> + <span class="hljs-variable">$1</span>)   <br>&#125;<br><br><span class="hljs-built_in">echo</span> $(func 10)<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">55<br></code></pre></td></tr></table></figure><p><strong>函数内的局部变量</strong><br>可以在函数内定义局部变量，作用范围仅在当前函数内。<br>可以在递归函数中定义局部变量<br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">local</span> 变量名=变量值<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash  </span><br><br><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> name = yxc <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span><br>&#125;<br><br>func <span class="hljs-comment"># 第一次在函数内调用(有)</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span> <span class="hljs-comment"># 第二次在函数外调用(无)</span><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">yxc<br></code></pre></td></tr></table></figure><p>第一行为函数内的<code>name</code>变量，第二行行为函数外调用<code>name</code>变量，会发现此时变量不存在</p><h3 id="exit命令">exit命令</h3><p><code>exit</code>命令用来退出当前<code>shell</code>进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态。<br><code>exit</code>命令可以接受一个整数值作为参考，代表退出状态。如果不指定，默认状态是<code>0</code>.<br><code>exit</code>退出状态只能是一个介于<code>0~255</code>之间的整数，其中只有<code>0</code>表示成功，其他值都表示失败。</p><blockquote><p><code>return</code>和<code>exit</code>的共同之处都是返回<code>exit code</code>，区别是<code>return</code>结束当前函数，<code>exit</code>结束整个<code>shell</code>脚本<br>示例：<br>创建脚本<code>test.sh</code>,内容如下：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash  </span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 1 ] <span class="hljs-comment"># 如果传入参数个数等于1，则正常退出；否则非正常退出。</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arguments not valid&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arguments valid&quot;</span><br>    <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>执行该脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">chmod</span> +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh acwing<br>arguments valid<br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">echo</span> $?  <span class="hljs-comment"># 传入一个参数，则正常退出，exit code为0</span><br>0<br>acs@9e0ebfcd82d7:~$ ./test.sh <br>arguments not valid<br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">echo</span> $?  <span class="hljs-comment"># 传入参数个数不是1，则非正常退出，exit code为1</span><br>1<br></code></pre></td></tr></table></figure><h3 id="文件重定向">文件重定向</h3><p>每次进程默认打开3个文件描述符：</p><ul><li><code>stdin</code> 标准输入，从命令行读取数据，文件描述符为<code>0</code></li><li><code>stdout</code> 标准输出，从命令行输出数据，文本描述符为<code>1</code></li><li><code>stderr</code> 标准错误输出，向命令行输出文件，文本描述符为<code>2</code></li></ul><p>可以用文件重定向将这三个文件重定向到其他文件中。<br><strong>重定向命令列表</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>commmand &gt; file</code></td><td style="text-align:center">将<code>stdout</code>重定向到<code>file</code>中</td></tr><tr><td style="text-align:center"><code>commmand &lt; file</code></td><td style="text-align:center">将<code>stdin</code>重定向到<code>file</code>中</td></tr><tr><td style="text-align:center"><code>commmand &gt;&gt; file</code></td><td style="text-align:center">将<code>stdout</code>以追加方式重定向到<code>file</code>中</td></tr><tr><td style="text-align:center"><code>commmand n&gt; file</code></td><td style="text-align:center">将文件描述符<code>n</code>重定向到<code>file</code>中</td></tr><tr><td style="text-align:center"><code>commmand n&gt;&gt; file</code></td><td style="text-align:center">将文件描述符<code>n</code>以追加方式重定向到<code>file</code>中</td></tr></tbody></table><p><strong>输入和输出重定向</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Hello \c&quot;</span> &gt; output.txt <span class="hljs-comment"># 将stdout重定向到output.txt中  </span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;World&quot;</span> &gt;&gt; output.txt <span class="hljs-comment"># 将字符串追加到output.txt中  </span><br><br><span class="hljs-built_in">read</span> str &lt; output.txt <span class="hljs-comment"># 从output.txt中读取字符串  </span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span> <span class="hljs-comment"># 输出结果 Hello World</span><br></code></pre></td></tr></table></figure><p><strong>同时重新定向stdin和stdout</strong><br>创建bash脚本:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">read</span> a<br><span class="hljs-built_in">read</span> b<br><br><span class="hljs-built_in">echo</span> $(<span class="hljs-built_in">expr</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> + <span class="hljs-string">&quot;<span class="hljs-variable">$b</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>创建input.txt，里面内容为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">3<br>4<br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">chmod</span> +x test.sh  <span class="hljs-comment"># 添加可执行权限</span><br>acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  <span class="hljs-comment"># 从input.txt中读取内容，将输出写入output.txt中</span><br>acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">cat</span> output.txt  <span class="hljs-comment"># 查看output.txt中的内容</span><br>7   <br></code></pre></td></tr></table></figure><h3 id="引入外部脚本">引入外部脚本</h3><p>类似于C/C++中的<code>include</code>操作，<code>bash</code>也可以引入其他文件中的代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">. filename <span class="hljs-comment"># 注意点和文件名之间有一个空格</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br>name=yxc <span class="hljs-comment"># 定义变量name</span><br></code></pre></td></tr></table></figure><p>然后创建<code>test2.sh</code>，内容为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">source</span> test1.sh <span class="hljs-comment"># 或. test1.sh</span><br><br><span class="hljs-built_in">echo</span> My name is: <span class="hljs-variable">$name</span> <span class="hljs-comment"># 可以使用使用test1.sh中的变量  </span><br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@9e0ebfcd82d7:~$ <span class="hljs-built_in">chmod</span> +x test2.sh<br>acs@9e0ebfcd82d7:~$ ..test2.sh<br>My name is: yxc<br></code></pre></td></tr></table></figure><h3 id="作业-3">作业</h3><ol start="0"><li>进入 homework_0 文件夹，编写自动完成 lesson_1 作业的脚本 <a href="http://helper.sh">helper.sh</a> 。要求：<ol><li>当前目录下仅包含 <a href="http://helper.sh">helper.sh</a></li><li>helper.sh具有可执行权限</li><li>在任意路径依次执行下列命令后，lesson_1 的作业可以得到满分：<ol><li>homework 1 create</li><li>/home/acs/homework/lesson_3/homework_0/helper.sh</li></ol></li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-comment"># homework0</span><br>homework 1 create 0<br>dir0=/home/acs/homework/lesson_1/homework_0<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dir_a dir_b dir_c<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$&#123;dir0&#125;</span>/<span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># homework1</span><br>homework 1 create 1<br>dir1=/home/acs/homework/lesson_1/homework_1<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a b c<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">cp</span> <span class="hljs-variable">$&#123;dir1&#125;</span>/<span class="hljs-variable">$&#123;i&#125;</span>.txt <span class="hljs-variable">$&#123;dir1&#125;</span>/<span class="hljs-variable">$&#123;i&#125;</span>.txt.bak<br><span class="hljs-keyword">done</span><br><span class="hljs-comment"># homework2</span><br>homework 1 create 2<br>dir2=/home/acs/homework/lesson_1/homework_2<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a b c<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;dir2&#125;</span>/<span class="hljs-variable">$&#123;i&#125;</span>.txt <span class="hljs-variable">$&#123;dir2&#125;</span>/<span class="hljs-variable">$&#123;i&#125;</span>_new.txt<br><span class="hljs-keyword">done</span><br><span class="hljs-comment"># homework3</span><br>homework 1 create 3<br>dir3=/home/acs/homework/lesson_1/homework_3<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a b c<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;dir3&#125;</span>/dir_a/<span class="hljs-variable">$&#123;i&#125;</span>.txt <span class="hljs-variable">$&#123;dir3&#125;</span>/dir_b<br><span class="hljs-keyword">done</span><br><span class="hljs-comment"># homework4</span><br>homework 1 create 4<br>dir4=/home/acs/homework/lesson_1/homework_4<br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$&#123;dir4&#125;</span>/*.txt<br><span class="hljs-comment"># homework5</span><br>homework 1 create 5<br>dir5=/home/acs/homework/lesson_1/homework_5<br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$&#123;dir5&#125;</span>/dir_* -r<br><span class="hljs-comment"># homework6</span><br>homework 1 create 6<br>dir6=/home/acs/homework/lesson_1/homework_6<br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$&#123;dir6&#125;</span>/dir_a<br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;dir6&#125;</span>/task.txt <span class="hljs-variable">$&#123;dir6&#125;</span>/dir_a/<span class="hljs-string">&quot;done.txt&quot;</span><br><span class="hljs-comment"># homework7</span><br>homework 1 create 7<br>dir7=/home/acs/homework/lesson_1/homework_7<br><span class="hljs-keyword">for</span> ((i=0;i&lt;=2;i++))<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$&#123;dir7&#125;</span>/dir_<span class="hljs-variable">$&#123;i&#125;</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> a b c<br>    <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">cp</span> <span class="hljs-variable">$&#123;dir7&#125;</span>/<span class="hljs-variable">$&#123;j&#125;</span>.txt <span class="hljs-variable">$&#123;dir7&#125;</span>/dir_<span class="hljs-variable">$&#123;i&#125;</span>/<span class="hljs-variable">$&#123;j&#125;</span><span class="hljs-variable">$&#123;i&#125;</span>.txt<br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br><span class="hljs-comment"># homewrok8</span><br>homework 1 create 8<br>dir8=/home/acs/homework/lesson_1/homework_8<br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$&#123;dir8&#125;</span>/dir_a/a.txt<br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;dir8&#125;</span>/dir_b/b.txt <span class="hljs-variable">$&#123;dir8&#125;</span>/dir_b/b_new.txt<br><span class="hljs-built_in">cp</span> <span class="hljs-variable">$&#123;dir8&#125;</span>/dir_c/c.txt <span class="hljs-variable">$&#123;dir8&#125;</span>/dir_c/c.txt.bak<br><span class="hljs-comment"># homework9</span><br>homework 1 create 9<br>dir9=/home/acs/homework/lesson_1/homework_9<br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$&#123;dir9&#125;</span>/*.txt<br>```  <br>1. 进入 homework_1 文件夹，编写脚本 check_file.sh。要求： 1. 当前目录下仅包含 check_file.sh 。 2. check_file.sh 具有可执行权限。 3. check_file.sh 接收一个传入参数。格式为 ./check_file.sh file 4. 判断传递参数，分别在标准输出中输出如下内容（不包括双引号）： 1. 如果传入参数个数不是 1 ，则输出一行：<span class="hljs-string">&quot;arguments not valid&quot;</span>，然后退出，退出状态等于 1。 2. 如果 file 文件不存在，则输出一行：<span class="hljs-string">&quot;not exist&quot;</span>，然后退出，退出状态等于 2 。 3. 如果 file 文件存在，则输出分别进行如下 5 个判断，然后退出，退出状态等于 0 。 1. 如果 file 为普通文件，则输出一行：<span class="hljs-string">&quot;regular file&quot;</span> 2. 如果 file 为目录（文件夹），则输出一行：<span class="hljs-string">&quot;directory&quot;</span> 3. 如果 file 具有可读权限，则输出一行：<span class="hljs-string">&quot;readable&quot;</span> 4. 如果 file 具有可写权限，则输出一行：<span class="hljs-string">&quot;writable&quot;</span> 5. 如果 file 具有可执行权限，则输出一行：<span class="hljs-string">&quot;executable&quot;</span><br>```SH<br><span class="hljs-comment">#! /bin/bash</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 1 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> arguments not valid<br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> not exist<br>    <span class="hljs-built_in">exit</span> 2<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> regular file<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> directory<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ -r <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> readable<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ -w <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> writable<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ -x <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> executable<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><ol start="2"><li>进入 homework_2 文件夹，编写脚本 <a href="http://main.sh">main.sh</a>。要求：<ol><li>当前目录下仅包含 <a href="http://main.sh">main.sh</a></li><li><a href="http://main.sh">main.sh</a> 具有可执行权限</li><li>该文件从 stdin (标准输入)中读取一个整数 n</li><li>在 stdout (标准输出)输出斐波那契数列的第 n 项。即：a[0] = 1, a[1] = 1, a[i] = a[i - 1] + a[i - 2], 求 a[n]</li><li>数据保证 $0 \leq n \leq 20$，脚本不需要判断 n 的合法性。</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">read</span> n<br><br>a[0]=1<br>a[1]=1<br><br><span class="hljs-keyword">for</span> ((i = 2; i &lt;= n; i ++ ))<br><span class="hljs-keyword">do</span><br>    x=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$i</span> - 1)<br>    y=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$i</span> - 2)<br>    a[<span class="hljs-variable">$i</span>]=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$&#123;a[$x]&#125;</span> + <span class="hljs-variable">$&#123;a[$y]&#125;</span>)<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;a[$n]&#125;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>进入 homework_3 文件夹，编写脚本 <a href="http://main.sh">main.sh</a>。要求：<ol><li>当前目录下仅包含 <a href="http://main.sh">main.sh</a></li><li><a href="http://main.sh">main.sh</a> 具有可执行权限</li><li>该文件从 stdin (标准输入)中读取两行整数 n 和 m</li><li>在 stdout (标准输出)中输出 1~n 的按字典序从小到大的顺序数第 m 个全排列，输出一行，用空格隔开所有数，行末可以有多余空格</li><li>数据保证 1 &lt;= n &lt;= 10, 1 &lt;= m &lt;= min(100, n!)，脚本不需要判断数据的合法性</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">read</span> n<br><span class="hljs-built_in">read</span> m<br><br><span class="hljs-keyword">for</span> ((i = 1; i &lt;= n; i ++ ))<br><span class="hljs-keyword">do</span><br>    st[<span class="hljs-variable">$i</span>]=0<br><span class="hljs-keyword">done</span><br><br><span class="hljs-function"><span class="hljs-title">dfs</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -eq <span class="hljs-variable">$n</span> ]<br>    <span class="hljs-keyword">then</span><br>        m=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$m</span> - 1`<br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$m</span> -eq 0 ] <br>        <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;path[@]&#125;</span><br>            <span class="hljs-built_in">return</span> 0<br>        <span class="hljs-keyword">fi</span><br>        <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-keyword">fi</span>  <br><br>    <span class="hljs-built_in">local</span> j=0<br>    <span class="hljs-keyword">for</span> ((j = 1; j &lt;= n; j ++ ))<br>    <span class="hljs-keyword">do</span>  <br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;st[$j]&#125;</span> -eq 0 ] <br>        <span class="hljs-keyword">then</span><br>            path[<span class="hljs-variable">$1</span>]=<span class="hljs-variable">$j</span><br>            st[<span class="hljs-variable">$j</span>]=1<br><br>            <span class="hljs-keyword">if</span> dfs `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$1</span> + 1`<br>            <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">return</span> 0<br>            <span class="hljs-keyword">fi</span><br><br>            st[<span class="hljs-variable">$j</span>]=0<br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><br><br>dfs 0<br><br></code></pre></td></tr></table></figure><ol start="4"><li>进入 homework_4 文件夹，编写脚本 <a href="http://main.sh">main.sh</a> 。要求：<ol><li>当前目录下仅包含 <a href="http://main.sh">main.sh</a></li><li><a href="http://main.sh">main.sh</a> 具有可执行权限</li><li><a href="http://main.sh">main.sh</a> 接收两个传入参数。格式为 ./main.sh input_file output_file</li><li>从 input_file 中读取一个正整数 n，然后将前 n 个正整数的平方和写入 output_file 中</li><li>数据保证 $1 \leq n \leq 100$，脚本不需要判断所有数据的合法性</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br>input_file=<span class="hljs-variable">$1</span><br>output_file=<span class="hljs-variable">$2</span><br><br><span class="hljs-built_in">read</span> n &lt; <span class="hljs-variable">$input_file</span><br><br><br><span class="hljs-built_in">sum</span>=0<br><br><span class="hljs-keyword">for</span> ((i = 1; i &lt;= n; i ++ ))<br><span class="hljs-keyword">do</span><br>    sqr=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$i</span> \* <span class="hljs-variable">$i</span>`<br>    <span class="hljs-built_in">sum</span>=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$sum</span> + <span class="hljs-variable">$sqr</span>`<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span> &gt; <span class="hljs-variable">$output_file</span><br></code></pre></td></tr></table></figure><h2 id="ssh">ssh</h2><h3 id="ssh登陆">ssh登陆</h3><p><strong>基本用法</strong><br>远程登陆服务器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh user@hostname<br></code></pre></td></tr></table></figure><ul><li>name: 用户名</li><li>hostname: IP地址或域名</li></ul><p>第一次登录会提示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">The authenticity of host <span class="hljs-string">&#x27;123.57.47.211 (123.57.47.211)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><br><span class="hljs-string">ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.</span><br><span class="hljs-string">Are you sure you want to continue connecting (yes/no/[fingerprint])?</span><br></code></pre></td></tr></table></figure><p>输入<code>yes</code>，然后回车即可。<br>这样会将该服务器的信息记录到<code>~/.ssh/known_hosts</code>文件中。<br>然后输入密码即可登录到远程服务器中。<br>默认端口号为22.如果想登录到某一特定端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh user@hostname -p 22<br></code></pre></td></tr></table></figure><p><strong>配置文件</strong><br>创建文件<code>~/.ssh/config</code><br>然后在文件中输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SH">Host myserver1<br>    HostName IP地址或域名<br>    User 用户名<br><br>Host myserver2<br>    HostName IP地址或域名<br>    User 用户名<br></code></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名<code>myserver1,myserver2</code><br><strong>密钥登录</strong><br>创建密钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh-keygen<br></code></pre></td></tr></table></figure><p>然后一直回车即可<br>执行结束后，<code>~/.ssh/</code>目录下会有多个文件：</p><ul><li><code>id_rsa</code>:私钥</li><li><code>id_rsa.pub</code>:公钥<br>之后想免密登录哪个服务器，就将公钥传给哪个服务器即可。<br>例如，想要免密登录myserver服务器。则将公钥中的内容，复制到<code>myserver</code>中的<code>~/.ssh/authorized_keys</code>文件中里即可。<br>也可以使用如下命令一键添加公钥：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh-copy-id myserver<br></code></pre></td></tr></table></figure><p><strong>执行命令</strong><br>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh user@hostname <span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh user@hostname <span class="hljs-built_in">ls</span> -a<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 单引号中的$i可以求值  </span><br>ssh myserver <span class="hljs-string">&#x27;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">a=1<br>ssh myserver <span class="hljs-string">&quot;echo <span class="hljs-variable">$a</span>&quot;</span><br>ssh myserver <span class="hljs-string">&#x27;echo $a&#x27;</span><br></code></pre></td></tr></table></figure><br>双引号是在本地服务器进行转义了，所以传过去的命令不是<code>echo $a</code>,而是<code>echo 1</code>单引号传过去的是<code>echo $a</code></p></blockquote><h3 id="scp-传文件">scp 传文件</h3><p><strong>基本用法</strong><br>命令格式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp <span class="hljs-built_in">source</span> destination<br></code></pre></td></tr></table></figure><blockquote><p>【注意】 myserver是默认定位到用户的家目录</p></blockquote><p>将<code>soruce</code>路径下的文件复制到<code>destination</code>中<br><strong>一次复制多个文件：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp soruce1 soruce2 destination<br></code></pre></td></tr></table></figure><p><strong>复制文件夹</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp -r ~/tmp myserver:/home/acs/<br></code></pre></td></tr></table></figure><p>将本地家目录中的<code>tmp</code>文件夹复制到<code>myserver</code>服务器中的<code>/home/acs/</code>目录下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp -r ~/tmp myserver:homework/acs/<br></code></pre></td></tr></table></figure><p>将本地家目录的<code>tmp</code>文件夹复制到<code>myserver</code>服务器中的<code>~/homework/</code>目录下面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp -r myserver:homework .<br>```SH<br>将`myserver`服务器中的`~/homework/`文件夹复制到本地的当前路径下。  <br>指定服务器的端口号：<br>```SH<br>scp -p 22 soruce1 soruce2 destination<br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>scp</code>的<code>-r -P</code>等参数尽量加在<code>source</code>和<code>destination</code>之间。<br>使用<code>scp</code>配置其他服务器的<code>vim</code>和<code>tmux</code></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp ~/.vimrc ~/.tmux.conf myserver:<br></code></pre></td></tr></table></figure><h3 id="作业-4">作业</h3><p>(0) 进入homework_0文件夹，要求：<br>[1] 该文件夹内容为空<br>[2] 配置服务器账号的密钥登陆方式。服务器信息可以通过如下命令获得：<br>homework 4 getinfo<br>将服务器账号的名称（Host）配置成：myserver<br><strong>配置服务器别名</strong><br>在<code>~/.ssh</code>目录下创建文件：<code>config</code><br>内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">Host myserver<br>    HostName 123.57.47.211<br>    User acs_2349<br></code></pre></td></tr></table></figure><p><strong>配置密钥登陆</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh-keygen<br>ssh-copy-id myserver<br></code></pre></td></tr></table></figure><p>(1) 进入homework_1文件夹，下列描述中的“本地”均表示当前文件夹。要求：<br>[1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_1/<br>[2] 将本地的main.cpp文件上传到myserver中的~/homework/lesson_4/homework_1/目录中。<br>[3] 在本地创建文件夹dir。<br>[4] 将myserver中的/etc/lsb-release文件复制到dir中。<br><strong>在myserver端</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">mkdir</span> ~/homework/lesson_4/homework_1/ -p<br></code></pre></td></tr></table></figure><p><strong>在本地</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp main.cpp myserver:homework/lesson_4/homework_1<br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span><br>scp myserver:/etc/lsb-release <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure><p>(2) 进入homework_2文件夹，下列描述中的“本地”均表示当前文件夹，要求：<br>[1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_2/<br>[2] 将本地的dir文件夹上传到myserver中的~/homework/lesson_4/homework_2/目录中。<br><strong>在myserver端</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> homework/lesson_4<br><span class="hljs-built_in">mkdir</span> homework_2<br></code></pre></td></tr></table></figure><p><strong>在本地</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp -r <span class="hljs-built_in">dir</span>/ myserver:homework/lesson_4/homework_2<br></code></pre></td></tr></table></figure><p>(3) 进入homework_3文件夹，下列描述中的“本地”均表示当前文件夹，要求：<br>[1] 在本地创建文件夹dir。<br>[2] 将myserver中的/var/lib/locales/supported.d文件夹下载到本地dir文件夹中。<br><strong>在本地</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dir</span><br>scp -r myserver:/var/lib/locales/supported.d <span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure><p>(4) 进入homework_4文件夹，编写脚本remote_mkdir.sh和remote_rmdir.sh，要求：<br>[1] 在myserver服务器上创建并清空文件夹：~/homework/lesson_4/homework_4/<br>[2] 本地目录下仅包含remote_mkdir.sh和remote_rmdir.sh<br>[3] remote_mkdir.sh和remote_rmdir.sh具有可执行权限<br>[4] remote_mkdir.sh接收一个传入参数。格式为 ./remote_mkdir.sh directory_name<br>该操作可以在myserver服务器上的~/homework/lesson_4/homework_4/目录下，创建一个名为directory_name的文件夹<br>[5] remote_rmdir.sh接收一个传入传输。格式为 ./remote_rmdir.sh directory_name<br>该操作可以将myserver服务器上的~/homework/lesson_4/homework_4/目录下的名为directory_name的文件夹删掉。<br>[6] 注意：传入的文件参数可能包含空格。两个脚本均不需要判断传入参数的合法性。<br><strong>remote_mkdir.sh</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br>ssh myserver <span class="hljs-built_in">mkdir</span> homework/lesson_4/homework_4/\&quot;<span class="hljs-variable">$1</span>\&quot;<br></code></pre></td></tr></table></figure><p><strong>remote_rmdir.sh</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-meta">#! /bin/bash</span><br><br>ssh myserver <span class="hljs-built_in">rm</span> homework/lesson_4/homework_4/\&quot;<span class="hljs-variable">$1</span>\&quot; -r<br></code></pre></td></tr></table></figure><h2 id="git">git</h2><p>代码托管平台：<a href="git.acwing.com">git.acwing.com</a></p><h3 id="git基本概念">git基本概念</h3><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h3 id="git常用命令">git常用命令</h3><p><code>git config --global user.name xxx :</code> 设置全局用户名，信息记录在 ~/.gitconfig 文件中</p><p><code>git config --global user.email xxx@xxx.com : </code>设置全局邮箱地址，信息记录在 ~/.gitconfig 文件中</p><h3 id="git-单分支基本指令">git 单分支基本指令</h3><p><code>git init :</code> 将当前目录配置成<code> git</code> 仓库，信息记录在隐藏的 <code>.git</code> 文件夹中</p><p><code>git add XX :</code> 将 <code>XX</code> 文件添加到 暂存区</p><p><code>git add . :</code> 将所有待加入 <code>暂存区</code> 的文件加入 <code>暂存区</code> (<code>.</code> 可以用 <code>*</code> 代替)</p><p><code>git rm --cached XX :</code> 将文件从 <code>仓库索引目录</code> 中 <code>删掉</code></p><p><code>git commit -m &quot;给自己看的备注信息&quot;</code> : 将 暂存区 的内容 提交 到 当前分支</p><p><code>git status :</code> 查看仓库 状态</p><p><code>git diff XX :</code> 查看 XX 文件相对于 暂存区 修改了哪些内容</p><h3 id="git-单分支版本切换指令">git 单分支版本切换指令</h3><p><code>git log :</code> 查看当前分支的 所有版本</p><p><code>git log --pretty=oneline:</code>单行展示</p><p><code>git reflog :</code> 查看 HEAD指针 的 移动历史（包括被回滚的版本，这是回滚后再回来的方法）</p><p><code>git reset --hard HEAD^ 或 git reset --hard HEAD~ :</code> 将代码库 回滚 到 上一个版本</p><p><code>git reset --hard HEAD^^ :</code> 往上 回滚 两次，以此类推（几个 ^ 就回滚几次）</p><p><code>git reset --hard HEAD~100 :</code> 往上 回滚 100个版本，以此类推（~n 回滚 n 次）</p><p><code>git reset --hard 版本号 :</code> 回滚 到某一特定版本</p><p><code>git checkout — XX 或 git restore XX :</code> 将 XX 文件 尚未加入暂存区 的修改 全部撤销</p><h3 id="git-单分支与远程仓库交互的指令">git 单分支与远程仓库交互的指令</h3><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git :</code> 将本地仓库关联到远程仓库</p><p><code>git push -u (第一次需要-u以后不需要) : </code>将当前分支推送到远程仓库</p><p><code>git push origin branch_name :</code> 将本地的 某个分支 推送到远程仓库</p><p><code>git clone git@git.acwing.com:xxx/XXX.git :</code> 将远程仓库 XXX 下载 到当前目录下</p><h3 id="git-多分支管理指令">git 多分支管理指令</h3><p><code>git branch :</code> 查看 所有分支 和 当前所处分支</p><p><code>git branch branch_name :</code> 创建 新分支</p><p><code>git checkout -b branch_name :</code> 创建并切换 到 branch_name 这个分支</p><p><code>git checkout branch_name :</code> 切换 到 branch_name 这个分支</p><p><code>git merge branch_name :</code> 将分支 branch_name 合并 到 当前分支 上</p><h3 id="git-多分支与远程仓库交互的指令">git 多分支与远程仓库交互的指令</h3><p><code>git branch -d branch_name :</code> 删除 本地仓库 的 branch_name 分支</p><p><code>git push -d origin branch_name :</code> 删除 远程仓库 的 branch_name 分支</p><p><code>git push --set-upstream origin branch_name :</code> 设置 本地仓库 的 branch_name 分支与 远程仓库 的 branch_name 分支 对应</p><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2 : </code>将 远程仓库 的 branch_name1 分支与 本地仓库 的 branch_name2 分支 对应</p><p><code>git pull :</code> 将 远程仓库 的 当前分支 与 本地仓库 的 当前分支 合并</p><p><code>git pull origin branch_name :</code> 将 远程仓库 的 branch_name 分支与 本地仓库 的当前分支 合并</p><p><code>git checkout -t origin/branch_name :</code> 将 远程仓库 的 branch_name 分支拉取到 本地仓库</p><h3 id="git-stash暂存">git stash暂存</h3><p><code>git stash :</code> 将 工作区 和 暂存区 中 尚未提交 的修改存入 栈 中</p><p><code>git stash apply :</code> 将 栈顶 存储的修改 恢复 到 当前分支 ，但 不删除 栈顶元素</p><p><code>git stash drop : </code>删除 栈顶 存储的修改</p><p><code>git stash pop :</code> 将 栈顶 存储的修改 恢复 到当前分支，同时删除 栈顶元素</p><p><code>git stash list :</code> 查看 栈中 所有元素</p><h3 id="作业-5">作业</h3><p>注意： 本次作业的10个题目不是独立的，每个题目会依赖于前一个题目，因此评测时如果当前题目错误，则不再评测后续题目。</p><p>创建好作业后，先进入文件夹/home/acs/homework/lesson_5/，然后：</p><p>(0) 在当前目录下创建文件夹homework，并将homework目录配置成git仓库。后续作业均在homework目录下操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SSH">mkdir homework<br>cd homework<br>git init<br></code></pre></td></tr></table></figure><p>(1) 创建文件readme.txt，内容包含一行：111；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">vim readme.txt<br>***<br>111<br>***<br>git add .<br>git commit -m &quot;add readme.txt&quot;<br></code></pre></td></tr></table></figure><p>将修改提交一个commit；<br>(2) 在readme.txt文件末尾新增一行：222；<br>将修改提交一个commit；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">vim readme.txt<br>***<br>111<br>222<br>***<br>git add .<br>git commit -m &quot;add 222&quot;<br></code></pre></td></tr></table></figure><p>(3) 创建文件夹：problem1和problem2；<br>创建文件problem1/main.cpp。文件内容为下述链接中的代码：<a href="https://www.acwing.com/problem/content/submission/code_detail/7834813/%EF%BC%9B">https://www.acwing.com/problem/content/submission/code_detail/7834813/；</a><br>创建文件problem2/main.cpp。文件内容为下述链接中的代码：<a href="https://www.acwing.com/problem/content/submission/code_detail/7834819/%EF%BC%9B">https://www.acwing.com/problem/content/submission/code_detail/7834819/；</a><br>将修改提交一个commit；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir problem1 problem2<br>cd problem1<br>vim main.cpp<br>***<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>int main()<br>&#123;<br>    int a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; a + b &lt;&lt; endl;<br>    return 0;<br>&#125;<br>***<br>cd ../problem2<br>vim main.cpp<br>***<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>const int N = 1010;<br><br>int n, m;<br>int f[N];<br><br>int main()<br>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    while (n -- )<br>    &#123;<br>        int v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        for (int j = m; j &gt;= v; j -- )<br>            f[j] = max(f[j], f[j - v] + w);<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    return 0;<br>&#125;<br>***<br>cd ..<br>git add .<br>git commit -m &quot;add problem1 problem2&quot;<br></code></pre></td></tr></table></figure><p>(4) 删除文件夹problem2；<br>创建文件夹problem3；<br>创建文件problem3/main.cpp。文件内容为下述链接中的代码：<a href="https://www.acwing.com/problem/content/submission/code_detail/7834841/%EF%BC%9B">https://www.acwing.com/problem/content/submission/code_detail/7834841/；</a><br>将readme.txt中最后一行222删掉，然后添加一行333；<br>将修改提交一个commit；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">rm problem2 -r<br>mkdir problem3<br>cd problem3<br>vim main.cpp<br>***<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>const int N = 1010;<br><br>int n, m;<br>int f[N];<br><br>int main()<br>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    while (n -- )<br>    &#123;<br>        int v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        for (int j = v; j &lt;= m; j ++ )<br>            f[j] = max(f[j], f[j - v] + w);<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    return 0;<br>&#125;<br>***<br><br>cd ..<br>vim readme.txt<br>***<br>111<br>333<br>***<br><br>git add .<br>git commit -m &quot;many operations&quot;<br></code></pre></td></tr></table></figure><p>(5) 在https://git.acwing.com/上注册账号并创建仓库，仓库名称为homework；<br>将本地git仓库上传到AC Git云端仓库；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">本地操作<br><br>git remote add origin git@git.acwing.com:yxc/homework.git<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>(6) 创建并切换至新分支dev；<br>在readme.txt文件中添加一行444；<br>将修改提交一个commit；<br>将dev分支推送至AC Git远程仓库；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git checkout -b dev<br>vim readme.txt<br>***<br>111<br>333<br>444<br>***<br><br>git add .<br>git commit -m &quot;add 444&quot;<br><br>git push origin dev<br></code></pre></td></tr></table></figure><p>(7) 切换回master分支；<br>在readme.txt文件中添加一行555；<br>将修改提交一个commit；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git checkout master  # 切换回master分支<br><br>vim readme.txt<br><br>***<br>111<br>333<br>555<br>***<br><br>git add .<br>git commit -m &quot;add 555&quot;<br></code></pre></td></tr></table></figure><p>(8) 将dev分支合并到master分支；<br>手动处理冲突，使readme文件最终内容包含4行：111、333、555、444；<br>将修改提交一个commit；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git merge dev  # 将dev分支合并到当前分支<br><br>vim readme.txt<br><br>***<br>111<br>333<br>555<br>444<br>***<br><br>git add .<br>git commit -m &quot;fix conflicts&quot;<br></code></pre></td></tr></table></figure><p>(9) 将master分支的版本库push到AC Git云端仓库；<br>登录myserver服务器（4. ssh作业中配置的服务器）；<br>创建并清空文件夹：~/homework/lesson_5/；<br>将AC Git云端仓库clone到~/homework/lesson_5/中；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ssh myserver<br>cd homework<br>mkdir lesson_5<br>cd lesson_5<br><br>git clone git@git.acwing.com:xiaochaomeng/homework.git<br></code></pre></td></tr></table></figure><h2 id="thrift">thrift</h2><p>thrift 是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。</p><p>它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。</p><h3 id="查阅thrift官方文档">查阅thrift官方文档</h3><p><a href="https://thrift.apache.org/">thrift 官网</a> -&gt; <a href="https://thrift.apache.org/tutorial/">Tutorial</a> -&gt; <a href="https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=tutorial/tutorial.thrift">tutorial.thrift</a></p><p><strong>thrift基础数据类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//The first thing to know about are types. The available types in Thrift are:<br>bool        //Boolean, one byte<br>i8 (byte)   //Signed 8-bit integer<br>i16         //Signed 16-bit integer<br>i32         //Signed 32-bit integer<br>i64         //Signed 64-bit integer<br>double      //64-bit floating point value<br>string      //String<br>binary      //Blob (byte array)<br>map&lt;t1,t2&gt;  //Map from one type to another<br>list&lt;t1&gt;    //Ordered list of one type<br>set&lt;t1&gt;     //Set of unique elements of one type<br></code></pre></td></tr></table></figure><p><strong>声明要转化的语言</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Thrift files can namespace, package, or prefix their output in various</span><br><span class="hljs-comment"> * target languages.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> cl tutorial<br><span class="hljs-keyword">namespace</span> cpp tutorial<br><span class="hljs-keyword">namespace</span> d tutorial<br><span class="hljs-keyword">namespace</span> dart tutorial<br><span class="hljs-keyword">namespace</span> java tutorial<br><span class="hljs-keyword">namespace</span> php tutorial<br><span class="hljs-keyword">namespace</span> perl tutorial<br><span class="hljs-keyword">namespace</span> haxe tutorial<br><span class="hljs-keyword">namespace</span> netstd tutorial<br><br></code></pre></td></tr></table></figure><p><strong>结构体定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Structs are the basic complex data structures. They are comprised of fields</span><br><span class="hljs-comment"> * which each have an integer identifier, a type, a symbolic name, and an</span><br><span class="hljs-comment"> * optional default value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Fields can be declared &quot;optional&quot;, which ensures they will not be included</span><br><span class="hljs-comment"> * in the serialized output if they aren&#x27;t set.  Note that this requires some</span><br><span class="hljs-comment"> * manual management in some languages.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Work</span> &#123;<br>  <span class="hljs-number">1</span>: i32 num1 = <span class="hljs-number">0</span>,<br>  <span class="hljs-number">2</span>: i32 num2,<br>  <span class="hljs-number">3</span>: Operation op,<br>  <span class="hljs-number">4</span>: optional string comment,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Service定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Ahh, now onto the cool part, defining a service. Services just need a name</span><br><span class="hljs-comment"> * and can optionally inherit from another service using the extends keyword.</span><br><span class="hljs-comment"> */</span><br>service Calculator extends shared.SharedService &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A method definition looks like C code. It has a return type, arguments,</span><br><span class="hljs-comment">   * and optionally a list of exceptions that it may throw. Note that argument</span><br><span class="hljs-comment">   * lists and exception lists are specified using the exact same syntax as</span><br><span class="hljs-comment">   * field lists in struct or exception definitions.</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ping</span><span class="hljs-params">()</span>,</span><br><span class="hljs-function"></span><br><span class="hljs-function">   i32 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">1</span>:i32 num1, <span class="hljs-number">2</span>:i32 num2)</span>,</span><br><span class="hljs-function"></span><br><span class="hljs-function">   i32 <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-number">1</span>:i32 logid, <span class="hljs-number">2</span>:Work w)</span> <span class="hljs-title">throws</span> <span class="hljs-params">(<span class="hljs-number">1</span>:InvalidOperation ouch)</span>,</span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="hljs-function">    * This method has a oneway modifier. That means the client only makes</span></span><br><span class="hljs-comment"><span class="hljs-function">    * a request and does not listen for any response at all. Oneway methods</span></span><br><span class="hljs-comment"><span class="hljs-function">    * must be void.</span></span><br><span class="hljs-comment"><span class="hljs-function">    */</span></span><br><span class="hljs-function">   oneway <span class="hljs-type">void</span> <span class="hljs-title">zip</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="用-thrift-实现一个基本的匹配系统-接口">用 thrift 实现一个基本的匹配系统 接口</h3><blockquote><p>thrift 是一种接口描述语言，用简便的 thrift 语言写完以后，可以用命令快速生成任何语言的文件</p></blockquote><p><strong>基本框架</strong></p><ol><li>游戏应用端（Python3）<ol><li>客户端：与 匹配系统服务器 的服务端交互</li></ol></li><li>匹配系统服务器（C++）<ol><li>服务端：与 游戏应用端 的客户端交互</li><li>客户端：与 数据存储服务器 的服务端交互</li></ol></li><li>数据存储服务器（已经实现）<ol><li>服务端：与 匹配系统服务器 的客户端交互<br><strong>初始化 git 仓库</strong></li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">mkdir</span> thrift_lesson<br><span class="hljs-built_in">cd</span> thrift_lesson<br>git init<br><br><span class="hljs-built_in">mkdir</span> thrift        <span class="hljs-comment"># 存放 thrift 源文件</span><br><span class="hljs-built_in">mkdir</span> game          <span class="hljs-comment"># 实现 游戏应用端 的 客户端 功能</span><br><span class="hljs-built_in">mkdir</span> match_system  <span class="hljs-comment"># 实现 匹配系统服务器 的 服务端 和 客户端 功能</span><br><br><span class="hljs-built_in">touch</span> readme.md<br><span class="hljs-comment"># 远程创建好git上的repo</span><br>git remote add origin git@git.acwing.com:colopen/thrift_lesson.git<br>git add .<br>git commit -m <span class="hljs-string">&quot;init repo&quot;</span><br>git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="实现-游戏应用端-与-匹配系统服务器-的交互">实现 游戏应用端 与 匹配系统服务器 的交互</h3><p>创建 <strong>match.thrift</strong> 接口文件</p><p>用于实现 游戏应用端 与 匹配系统服务器 交互的 service</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">namespace</span> cpp match_service <span class="hljs-comment">//声明转换为C++语言</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;   <span class="hljs-comment">//定义结构体 User</span><br>    <span class="hljs-number">1</span>: i32 id, <br>    <span class="hljs-number">2</span>: string name,<br>    <span class="hljs-number">3</span>: i32 score<br>&#125;<br><br>service Match &#123; <span class="hljs-comment">//定义service服务</span><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * user: 添加的用户信息</span><br><span class="hljs-comment">     * info: 附加信息</span><br><span class="hljs-comment">     * 在匹配池中添加一个名用户</span><br><span class="hljs-comment">     */</span>  <br><br>    <span class="hljs-function">i32 <span class="hljs-title">add_user</span><span class="hljs-params">(<span class="hljs-number">1</span>: User user, <span class="hljs-number">2</span>: string info)</span>,</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-comment">/** </span></span><br><span class="hljs-comment"><span class="hljs-function">     * user: 删除的用户信息</span></span><br><span class="hljs-comment"><span class="hljs-function">     * info: 附加信息</span></span><br><span class="hljs-comment"><span class="hljs-function">     * 从匹配池中删除一名用户</span></span><br><span class="hljs-comment"><span class="hljs-function">     */</span>  </span><br><span class="hljs-function"></span><br><span class="hljs-function">    i32 <span class="hljs-title">remove_user</span><span class="hljs-params">(<span class="hljs-number">1</span>: User user, <span class="hljs-number">2</span>: string info)</span>,</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="匹配系统服务器的客户端">匹配系统服务器的客户端</h4><p><strong>运行 match.thrift 接口文件在匹配系统服务器端生成 C++ 源文件</strong></p><p>进入 match_system 中新建文件夹 src （之后所有的 匹配服务器 源文件放在 src 下）</p><p>并在 src 文件夹中运行 thrift 脚本生成 C++ 版本的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 原始的thrift生成文件语法：thrift -r --gen &lt;language&gt; &lt;Thrift filename&gt;</span><br><span class="hljs-built_in">mkdir</span> match_system/src<br><span class="hljs-built_in">cd</span> match_system/src<br>thrift -r --gen cpp ../../thrift/match.thrift<br><br><span class="hljs-comment"># 将该文件夹重命名为 match_server（区别于之后要此处生成的client server）</span><br><span class="hljs-comment"># match_server 与 游戏应用端交互 ; client_server 与 数据存储服务器交互</span><br><span class="hljs-built_in">mv</span> gen-cpp match_server<br><br><span class="hljs-comment"># 把 Match_server.skeleton.cpp 移动到当前 src 目录下并重命名为 main.cpp</span><br><span class="hljs-comment"># 方便之后调试 main.cpp 文件，其他的源文件仍被存放在 src 文件夹下</span><br><span class="hljs-built_in">mv</span> match_server/Match_server.skeleton.cpp main.cpp<br><br><span class="hljs-comment"># 由于移动了 main.cpp 故需要修改一下 main.cpp 中头文件里关于 Math.cpp 的引用路径</span><br><span class="hljs-comment"># 之后写 client_server 同理</span><br></code></pre></td></tr></table></figure><p>生成完成后的工作区状态如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SH">acs@7854cf6acd7f:~/thrift_lesson$ tree<br>.<br>|-- game<br>|-- match_system<br>|   `-- src<br>|       |--main.cpp<br>|       `-- match_server<br>|           |-- Match.cpp<br>|           |-- Match.h<br>|           |-- match_types.cpp<br>|           `-- match_types.h<br>|-- readme.md<br>`-- thrift<br>    `-- match.thrift<br><br>5 directories, 7 files<br></code></pre></td></tr></table></figure><p>编译并运行 cpp 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 1. 编译 所有的 .cpp 文件生成 .o 文件</span><br><span class="hljs-comment"># g++ -c [文件1.cpp] [文件2.cpp] ...</span><br>g++ -c main.cpp match_server/*.cpp<br><br><span class="hljs-comment"># 2. 链接 所有的 .o 文件生成可执行文件 .exe</span><br><span class="hljs-comment"># g++ [文件1.o] [文件2.o] ... -o [需要额外添加的动态库]</span><br><span class="hljs-comment"># 此处需要额外添加 -lthrift 的 thrift 动态库</span><br>g++ *.o -o main -lthrift<br><br><span class="hljs-comment"># 3. 运行 可执行文件</span><br>./main<br></code></pre></td></tr></table></figure><p>将 <strong>非编译文件</strong> 和 <strong>非可执行文件</strong> 提交到 git 中去（好的工程习惯）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SH">git add .<br>git restore --stage *.o     <span class="hljs-comment"># .o文件是编译文件，不加入暂存区里</span><br>git restore --stage main    <span class="hljs-comment"># main是可执行文件，不加入暂存区里</span><br>git commit -m <span class="hljs-string">&quot;add match server&quot;</span><br>git push<br></code></pre></td></tr></table></figure><h4 id="游戏应用端的客户端">游戏应用端的客户端</h4><p>运行 match.thrift 在游戏应用端生成 python3 源文件</p><p>同上，在 game 文件夹下实现 游戏应用端 的 客户端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 原始的thrift生成文件语法：thrift -r --gen &lt;language&gt; &lt;Thrift filename&gt;</span><br><span class="hljs-built_in">mkdir</span> game/src<br><span class="hljs-built_in">cd</span> game/src<br>thrift -r --gen py ../../thrift/match.thrift<br><br><span class="hljs-comment"># 将该文件夹重命名为 match_client</span><br><span class="hljs-comment"># 不过这里不改也无所谓，游戏应用端只有匹配的客户端</span><br><span class="hljs-built_in">mv</span> gen-py match_client<br><br><span class="hljs-comment"># 删掉 Match_remote </span><br><span class="hljs-comment"># 该文件是用 py 实现 服务端 时用的文件</span><br><span class="hljs-comment"># 此处我们只需要实现 客户端 功能，因此他没有作用，不妨删掉，让文档简洁一点</span><br><span class="hljs-built_in">rm</span> match_client/match/Match-remote<br></code></pre></td></tr></table></figure><p>利用官网提供的模板，编写 客户端 文件 <code>client.py</code></p><p><a href="https://thrift.apache.org/tutorial/py.html">官网模板</a></p><p><code>client.py</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 先删去开头三行声明</span><br><span class="hljs-comment"># 此处修改路径，以及Calculator 为 Match</span><br><span class="hljs-comment"># 此处修改 ttypes 路径 以及 User 类</span><br><span class="hljs-keyword">from</span> match_client.match <span class="hljs-keyword">import</span> Match<br><span class="hljs-keyword">from</span> match_client.match.ttypes <span class="hljs-keyword">import</span> User<br><br><span class="hljs-keyword">from</span> thrift <span class="hljs-keyword">import</span> Thrift<br><span class="hljs-keyword">from</span> thrift.transport <span class="hljs-keyword">import</span> TSocket<br><span class="hljs-keyword">from</span> thrift.transport <span class="hljs-keyword">import</span> TTransport<br><span class="hljs-keyword">from</span> thrift.protocol <span class="hljs-keyword">import</span> TBinaryProtocol<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># Make socket</span><br>    transport = TSocket.TSocket(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">9090</span>)<br><br>    <span class="hljs-comment"># Buffering is critical. Raw sockets are very slow</span><br>    transport = TTransport.TBufferedTransport(transport)<br><br>    <span class="hljs-comment"># Wrap in a protocol</span><br>    protocol = TBinaryProtocol.TBinaryProtocol(transport)<br><br>    <span class="hljs-comment"># Create a client to use the protocol encoder</span><br>    client = Match.Client(protocol)<br><br>    <span class="hljs-comment"># Connect!</span><br>    transport.<span class="hljs-built_in">open</span>()<br><br>    <span class="hljs-comment"># 调试语句</span><br>    user = User(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;yxc&#x27;</span>, <span class="hljs-number">1500</span>)<br>    client.add_user(user, <span class="hljs-string">&quot;&quot;</span>) <br><br>    <span class="hljs-comment"># Close!</span><br>    transport.close()<br><br><span class="hljs-comment"># 调用 main 函数</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main() <br></code></pre></td></tr></table></figure><p>将 非编译文件 和 非可执行文件 提交到 git 中去（好的工程习惯）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH">git add .<br>git restore --stage *.pyc   <span class="hljs-comment"># .pyc文件是编译文件，不加入暂存区里</span><br>git restore --stage *.swp   <span class="hljs-comment"># .swp文件是缓存文件，不加入暂存区里（vim没关时会生成）</span><br>git commit -m <span class="hljs-string">&quot;add client&quot;</span><br>git push<br>重写 client.py 使之能不断从终端里读入信息<br></code></pre></td></tr></table></figure><p><code>client.py</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 利用 python 在终端读入信息需要引入 stdin</span><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> stdin<br><br><span class="hljs-comment"># 将原来的通信 main 函数改写成operate函数，每次需要的时候调用一次建立通信传递信息</span><br><span class="hljs-comment"># 目的是可以一直不断处理信息</span><br><span class="hljs-comment"># 然后重写 main 函数，使之能不断从终端读入信息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">op, user_id, user_name, score</span>):<br>    <span class="hljs-comment"># ...........................</span><br><br>    <span class="hljs-comment"># 针对 op 参数，分别进行 &quot;增加&quot; 与 &quot;删出&quot; 操作</span><br>    user = User(user_id, user_name, score)<br><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&quot;add&quot;</span>:<br>        client.add_user(user, <span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        client.remove_user(user, <span class="hljs-string">&quot;&quot;</span>)<br><br>    <span class="hljs-comment"># ...........................</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> stdin:<br>        op, user_id, user_name, score = line.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>        operate(op, <span class="hljs-built_in">int</span>(user_id), user_name, <span class="hljs-built_in">int</span>(score))<br></code></pre></td></tr></table></figure><h4 id="在匹配服务器里给-匹配系统-开一个-线程">在匹配服务器里给 匹配系统 开一个 线程</h4><p>运用到了 <strong>操作系统</strong> 里的 <strong>PV</strong> 原语 以及 <strong>生产者-消费者</strong> 模型</p><p>重写 <code>match_system/main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// This autogenerated skeleton file illustrates how to build a server.</span><br><span class="hljs-comment">// You should copy it to another filename to avoid overwriting it.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;match_server/Match.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/protocol/TBinaryProtocol.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/server/TSimpleServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/transport/TServerSocket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/transport/TBufferTransports.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>               <span class="hljs-comment">// 需要线程，引入头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>                <span class="hljs-comment">// 互斥信号量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span>   <span class="hljs-comment">// 条件变量，用于 阻塞和唤醒 线程</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span>                <span class="hljs-comment">// 用于模拟消息队列</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::protocol;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::transport;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::apache::thrift::server;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  ::match_service;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> <span class="hljs-comment">//消息队列中的元素</span><br>&#123;<br>    User user;<br>    string type;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MessageQueue</span> <span class="hljs-comment">//消息队列</span><br>&#123;<br>    queue&lt;Task&gt; q;          <span class="hljs-comment">//消息队列本体</span><br>    mutex m;                <span class="hljs-comment">//互斥信号量</span><br>    condition_variable cv;  <span class="hljs-comment">//条件变量，用于阻塞唤醒线程</span><br>&#125;message_queue;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span>  <span class="hljs-comment">// 模拟匹配池</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save_result</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  <span class="hljs-comment">// 记录成功匹配的信息</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Match Result: %d %d\n&quot;</span>, a, b);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">match</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 匹配池中的第一、第二个用户进行匹配</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span> (users.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> a = users[<span class="hljs-number">0</span>], b = users[<span class="hljs-number">1</span>];<br>            users.<span class="hljs-built_in">erase</span>(users.<span class="hljs-built_in">begin</span>());<br>            users.<span class="hljs-built_in">erase</span>(users.<span class="hljs-built_in">begin</span>());<br><br>            <span class="hljs-built_in">save_result</span>(a.id, b.id);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(User user)</span> <span class="hljs-comment">// 向匹配池中加入用户</span></span><br><span class="hljs-function">    </span>&#123;<br>        users.<span class="hljs-built_in">push_back</span>(user);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(User user)</span>  <span class="hljs-comment">// 从匹配池中删除用户</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; users.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span> (users[i].id == user.id)<br>            &#123;<br>                users.<span class="hljs-built_in">erase</span>(users.<span class="hljs-built_in">begin</span>() + i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;User&gt; users; <span class="hljs-comment">// 匹配池中的用户，用 vector 记录</span><br>&#125;pool;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchHandler</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> MatchIf &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MatchHandler</span>() &#123;<br>            <span class="hljs-comment">// Your initialization goes here</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">add_user</span><span class="hljs-params">(<span class="hljs-type">const</span> User&amp; user, <span class="hljs-type">const</span> std::string&amp; info)</span> </span>&#123;<br>            <span class="hljs-comment">// Your implementation goes here</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add_user\n&quot;</span>);<br><br>            <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(message_queue.m)</span></span>;    <span class="hljs-comment">// 访问临界区(消息队列)，先上锁</span><br>            message_queue.q.<span class="hljs-built_in">push</span>(&#123;user, <span class="hljs-string">&quot;add&quot;</span>&#125;);        <span class="hljs-comment">// 把新消息加入消息队列</span><br>            message_queue.cv.<span class="hljs-built_in">notify_all</span>();              <span class="hljs-comment">// 唤醒阻塞的线程</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">remove_user</span><span class="hljs-params">(<span class="hljs-type">const</span> User&amp; user, <span class="hljs-type">const</span> std::string&amp; info)</span> </span>&#123;<br>            <span class="hljs-comment">// Your implementation goes here</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;remove_user\n&quot;</span>);<br><br>            <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(message_queue.m)</span></span>;    <span class="hljs-comment">// 访问临界区(消息队列)，先上锁</span><br>            message_queue.q.<span class="hljs-built_in">push</span>(&#123;user, <span class="hljs-string">&quot;remove&quot;</span>&#125;);     <span class="hljs-comment">// 把新消息加入消息队列</span><br>            message_queue.cv.<span class="hljs-built_in">notify_all</span>();              <span class="hljs-comment">// 唤醒阻塞的线程</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>&#125;;<br><br><br><span class="hljs-comment">// 基于 &quot;生产者-消费者模型&quot; 的线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consume_task</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(message_queue.m)</span></span>;    <span class="hljs-comment">// 访问临界区(消息队列)，先上锁</span><br><br>        <span class="hljs-keyword">if</span> (message_queue.q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            message_queue.cv.<span class="hljs-built_in">wait</span>(lck);     <span class="hljs-comment">//这里要阻塞进程</span><br>            <span class="hljs-comment">// 避免队列为空时，一直反复运行该线程，导致一直占用临界区，而不能加入新消息</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">auto</span> task = message_queue.q.<span class="hljs-built_in">front</span>();    <span class="hljs-comment">// 取出消息队列队头元素</span><br>            message_queue.q.<span class="hljs-built_in">pop</span>();<br><br>            lck.<span class="hljs-built_in">unlock</span>();   <span class="hljs-comment">// 临界区访问结束，直接解锁</span><br>            <span class="hljs-comment">// 避免后续没用到临界区信息，而长时间占用临界区的情况发生</span><br><br>            <span class="hljs-keyword">if</span> (task.type == <span class="hljs-string">&quot;add&quot;</span>) pool.<span class="hljs-built_in">add</span>(task.user);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task.type == <span class="hljs-string">&quot;remove&quot;</span>) pool.<span class="hljs-built_in">remove</span>(task.user);<br><br>            pool.<span class="hljs-built_in">match</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-type">int</span> port = <span class="hljs-number">9090</span>;<br>    ::<span class="hljs-function">std::shared_ptr&lt;MatchHandler&gt; <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MatchHandler())</span></span>;<br>    ::<span class="hljs-function">std::shared_ptr&lt;TProcessor&gt; <span class="hljs-title">processor</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MatchProcessor(handler))</span></span>;<br>    ::<span class="hljs-function">std::shared_ptr&lt;TServerTransport&gt; <span class="hljs-title">serverTransport</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TServerSocket(port))</span></span>;<br>    ::<span class="hljs-function">std::shared_ptr&lt;TTransportFactory&gt; <span class="hljs-title">transportFactory</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TBufferedTransportFactory())</span></span>;<br>    ::<span class="hljs-function">std::shared_ptr&lt;TProtocolFactory&gt; <span class="hljs-title">protocolFactory</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TBinaryProtocolFactory())</span></span>;<br><br>    <span class="hljs-function">TSimpleServer <span class="hljs-title">server</span><span class="hljs-params">(processor, serverTransport, transportFactory, protocolFactory)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Start Match Server&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-function">thread <span class="hljs-title">matching_thread</span><span class="hljs-params">(consume_task)</span></span>;   <span class="hljs-comment">// 调用一个线程运行 consume_task</span><br><br>    server.<span class="hljs-built_in">serve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译，运行，上传</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH">g++ -c main.cpp<br>g++ *.o -o main -lthrift -pthread<br><br>git add main.cpp<br>git commit -m <span class="hljs-string">&quot;match-server ver:2.0&quot;</span><br>git push<br></code></pre></td></tr></table></figure><h4 id="数据存储服务器-与-匹配系统服务器-的交互">数据存储服务器 与 匹配系统服务器 的交互</h4><p><strong>数据存储服务器的服务端</strong></p><p><code>save.thrift</code> 文件(现成)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">namespace</span> cpp save_service<br><br>service Save &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * username: myserver的名称</span><br><span class="hljs-comment">     * password: myserver的密码的md5sum的前8位</span><br><span class="hljs-comment">     * 用户名密码验证成功会返回0，验证失败会返回1</span><br><span class="hljs-comment">     * 验证成功后，结果会被保存到myserver:homework/lesson_6/result.txt中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">i32 <span class="hljs-title">save_data</span><span class="hljs-params">(<span class="hljs-number">1</span>: string username, <span class="hljs-number">2</span>: string password, <span class="hljs-number">3</span>: i32 player1_id, <span class="hljs-number">4</span>: i32 player2_id)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>在 <strong>匹配系统服务器</strong> 利用 <strong>thrift</strong> 生成 <strong>C++</strong> 文件</p><p>并删掉不必要 <strong>服务端</strong> 文件，因为在该交互功能里，<strong>匹配系统服务器</strong> 是作为客户端的</p><blockquote><p>而且，一个服务器里只能有一个 main 函数执行</p></blockquote><p>只保留 <strong>客户端</strong> 文件即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">cd</span> match_system/src<br>thrift -r --gen cpp ../../thrift/save.thrift<br><span class="hljs-built_in">mv</span> gen-cpp save_client<br><span class="hljs-built_in">rm</span> save_client/Save_server.skeleton.cpp<br></code></pre></td></tr></table></figure><p>利用 md5 哈希函数获得服务器密码的 哈希值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SH">homework 4 getinfo<br><br>--------------<br>User: acs_2<br>HostName: 123.57.47.211<br>Password: dff1704d<br>--------------<br><br><span class="hljs-built_in">md5sum</span><br><br>dff1704d [&lt;Enter&gt;]<br>[Ctrl + D]<br><br>--------------<br>50c0f4b28a0b353e7b20489a1fd984e7  -<br>--------------<br><span class="hljs-comment"># 哈希值前 8 位就是我们要调用服务器接口时用的密码</span><br></code></pre></td></tr></table></figure><p>从 thrift官网 复制 Client 端的模板到 main.cpp 下与 数据存储服务器 交互的函数中，然后开始修改模板里的一些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 需要额外引入的头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/transport/TSocket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/transport/TTransportUtils.h&gt;</span></span><br><br><span class="hljs-comment">// 需要额外声明的命名空间</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  ::save_service;<br><br><span class="hljs-comment">//重写 save_result 内的内容，使其能够与 &quot;数据存储服务器&quot; 交互</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save_result</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  <span class="hljs-comment">// 记录成功匹配的信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Match Result: %d %d\n&quot;</span>, a, b);<br><br>    <span class="hljs-comment">// Client端的板子</span><br>    <span class="hljs-function">std::shared_ptr&lt;TTransport&gt; <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TSocket(<span class="hljs-string">&quot;123.57.47.211&quot;</span>, <span class="hljs-number">9090</span>))</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;TTransport&gt; <span class="hljs-title">transport</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TBufferedTransport(socket))</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;TProtocol&gt; <span class="hljs-title">protocol</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TBinaryProtocol(transport))</span></span>;<br>    <span class="hljs-function">SaveClient <span class="hljs-title">client</span><span class="hljs-params">(protocol)</span></span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        transport-&gt;<span class="hljs-built_in">open</span>();<br><br>        <span class="hljs-comment">//调用接口，把信息存储 &quot;数据存储服务器&quot; 中</span><br>        <span class="hljs-type">int</span> res = client.<span class="hljs-built_in">save_data</span>(<span class="hljs-string">&quot;acs_2&quot;</span>, <span class="hljs-string">&quot;50c0f4b2&quot;</span>, a, b);<br>        <span class="hljs-comment">//输出匹配结果</span><br>        <span class="hljs-keyword">if</span> (!res) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;success&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fail&quot;</span>);<br><br>        transport-&gt;<span class="hljs-built_in">close</span>();<br>    &#125; <span class="hljs-built_in">catch</span> (TException&amp; tx) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR: &quot;</span> &lt;&lt; tx.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译，运行，上传</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs SH">g++ -c main.cpp save_client/*.cpp<br>g++ *.o -o main -lthrift -pthread<br>./main<br><br>-------------<br><span class="hljs-comment"># 游戏应用端</span><br>add 1 yxc 1500<br>add 2 zxc 1500<br><span class="hljs-comment"># 匹配系统服务器</span><br>add_user<br>add_user<br>Match Result: 1 2<br>success<br><span class="hljs-comment"># 数据存储服务器</span><br><span class="hljs-comment">## homework/lesson_6/result.txt</span><br>result: 1 2<br>141da30f<br>-------------<br><br><span class="hljs-comment"># 上传到 git 服务器</span><br>git add main.cpp<br>git add ../../thrift/save.thrift<br>git commit -m <span class="hljs-string">&quot;implement save-client&quot;</span><br>git push<br></code></pre></td></tr></table></figure><p>实现匹配系统 ver3.0 功能：每次只匹配分差小于 50 的用户<br>该功能的实现比较简单，基本的模拟题</p><p>考虑重写 main.cpp 文件中的部分函数功能</p><p>修改线程中 消息队列 为空时，不再是 阻塞 直到 唤醒 为止</p><p>让其可以每经过 1 秒就进行一次 match() 调用</p><p>这样做的目的是：由于我们的匹配策略发生了变化，可能匹配池中仍然有用户在等待匹配（当前匹配池各个用户分差都大于50），而消息队列此时仍为空</p><p>如果仍然采用先前的策略，可能会导致进程卡死（新用户不进去，老用户永远匹配不了）</p><blockquote><p>如果不加入 “随时间扩大匹配域” 的功能，无论改不改上述情况都会可能发生<br>但是为了后续实现 “随时间扩大匹配域” 功能，先做一个铺垫</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//引入调用 sleep 函数的头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span><span class="hljs-comment">// 用于调用 sleep 函数</span></span><br><br><span class="hljs-comment">//修改 &quot;生产者 - 消费者模型&quot; 的线程中，关于消息队列为空时的处理</span><br><span class="hljs-keyword">if</span> (message_queue.q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>    <span class="hljs-comment">// 此处修改为每 1 秒进行一次匹配，而不是等到被唤醒时才匹配</span><br>    lck.<span class="hljs-built_in">unlock</span>();   <span class="hljs-comment">// 直接解锁临界区资源</span><br>    pool.match;     <span class="hljs-comment">//调用math()</span><br>&#125;<br><br><span class="hljs-comment">//重写匹配池Pool类中的match函数，使之可以匹配分数差在 50 以内的两个用户</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">match</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 匹配池中的第一、第二个用户进行匹配</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (users.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 按照 rank分 排序</span><br>        <span class="hljs-built_in">sort</span>(users.<span class="hljs-built_in">begin</span>(), users.<span class="hljs-built_in">end</span>(), [&amp;](User &amp;a, User &amp;b)&#123;<br>            <span class="hljs-keyword">return</span> a.score &lt; b.score;<br>        &#125;);<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">1</span>; i &lt; users.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            User a = users[i - <span class="hljs-number">1</span>], b = users[i];<br>            <span class="hljs-comment">// 两名玩家分数差小于50时进行匹配</span><br>            <span class="hljs-keyword">if</span> (b.score - a.score &lt;= <span class="hljs-number">50</span>)<br>            &#123;<br>                users.<span class="hljs-built_in">erase</span>(users.<span class="hljs-built_in">begin</span>() + i - <span class="hljs-number">1</span>, users.<span class="hljs-built_in">begin</span>() + i); <span class="hljs-comment">//删掉用户a,b</span><br>                <span class="hljs-built_in">save_result</span>(a.id, b.id);<br><br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">// 一轮扫描后，发现没有能够匹配的用户，就停止扫描，等待下次调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译，运行，上传</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP">g++ -c main.cpp<br>g++ *.o -o main -lthrift -pthread<br>./main<br><br>-------------<br># 游戏应用端<br>add <span class="hljs-number">1</span> yxc <span class="hljs-number">2000</span><br>add <span class="hljs-number">2</span> zxc <span class="hljs-number">1500</span><br>add <span class="hljs-number">3</span> cxc <span class="hljs-number">1549</span><br># 匹配系统服务器<br>add_user<br>add_user    # 此处用户 yxc 与用户 zxc 没有匹配，因为分差超过<span class="hljs-number">50</span><br>add_user<br>Match Result: <span class="hljs-number">2</span> <span class="hljs-number">3</span>   # 用户 zxc 与用户 cxc 分差在 <span class="hljs-number">50</span> 以内，进行匹配<br>success<br># 数据存储服务器<br>#<span class="hljs-meta"># homework/lesson_6/result.txt</span><br>result: <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>b6281235<br>-------------<br><br># 上传到 git 服务器<br>git add main.cpp<br>git add ../../thrift/save.thrift<br>git commit -m <span class="hljs-string">&quot;match server:3.0&quot;</span><br>git push<br></code></pre></td></tr></table></figure><p>实现匹配系统 ver4.0 功能：多线程</p><p>重写 main.cpp 文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 引入新的多线程头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/concurrency/ThreadManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/concurrency/ThreadFactory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/server/TThreadPoolServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/server/TThreadedServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thrift/TToString.h&gt;</span></span><br><br><span class="hljs-comment">// 复制模板的类 CalculatorCloneFactory 然后改一改，把所有的 Calculator 改为 Match</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchCloneFactory</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> MatchIfFactory &#123;<br>    <span class="hljs-keyword">public</span>:<br>        ~<span class="hljs-built_in">MatchCloneFactory</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-function">MatchIf* <span class="hljs-title">getHandler</span><span class="hljs-params">(<span class="hljs-type">const</span> ::apache::thrift::TConnectionInfo&amp; connInfo)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            std::shared_ptr&lt;TSocket&gt; sock = std::<span class="hljs-built_in">dynamic_pointer_cast</span>&lt;TSocket&gt;(connInfo.transport);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            cout &lt;&lt; &quot;Incoming connection\n&quot;;</span><br><span class="hljs-comment">            cout &lt;&lt; &quot;\tSocketInfo: &quot;  &lt;&lt; sock-&gt;getSocketInfo() &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            cout &lt;&lt; &quot;\tPeerHost: &quot;    &lt;&lt; sock-&gt;getPeerHost() &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            cout &lt;&lt; &quot;\tPeerAddress: &quot; &lt;&lt; sock-&gt;getPeerAddress() &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            cout &lt;&lt; &quot;\tPeerPort: &quot;    &lt;&lt; sock-&gt;getPeerPort() &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MatchHandler;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">releaseHandler</span><span class="hljs-params">(MatchIf* handler)</span> <span class="hljs-keyword">override</span> </span>&#123;    <span class="hljs-comment">//改为MatchIf*  </span><br>            <span class="hljs-keyword">delete</span> handler;<br>        &#125;<br>&#125;;<br><span class="hljs-comment">// 重写main函数，启用多线程服务器</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-function">TThreadedServer <span class="hljs-title">server</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;MatchProcessorFactory&gt;(std::make_shared&lt;MatchCloneFactory&gt;()),</span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;TServerSocket&gt;(<span class="hljs-number">9090</span>), <span class="hljs-comment">//port</span></span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;TBufferedTransportFactory&gt;(),</span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;TBinaryProtocolFactory&gt;())</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Start Match Server&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-function">thread <span class="hljs-title">matching_thread</span><span class="hljs-params">(consume_task)</span></span>;   <span class="hljs-comment">// 调用一个线程运行 consume_task</span><br><br>    server.<span class="hljs-built_in">serve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译，运行，上传</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SH">g++ -c main.cpp<br>g++ *.o -o main -lthrift -pthread<br>./main<br><span class="hljs-comment"># 上传到 git 服务器</span><br>git add main.cpp<br>git commit -m <span class="hljs-string">&quot;match server:4.0&quot;</span><br>git push<br></code></pre></td></tr></table></figure><p>实现匹配系统 ver5.0 功能：随时间扩大匹配域<br>就是字面意思，模拟一下就好了</p><p>说一下 y总 的做法，用额外一个数组 wt 来记录每个用户的等待时间</p><p>因为在消息队列为空时，线程会每 1 秒调用一次 match 函数</p><p>然后每次调用 match 函数，会首先对 匹配池中所有用户的 wt 值自增 1</p><p>从而实现用 wt 记录每个用户的等待时间</p><p>然后，每一单位的 wt 会扩大 50分 的匹配域，从而达到模拟题意的功能</p><p>main.cpp 修改部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 主要修改的是 pool 类中关于 match 函数的部分</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        User a = users[i], b = users[j];<br>        <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(a.score - b.score);<br>        <span class="hljs-type">int</span> a_diff_max = wt[i] * <span class="hljs-number">50</span>; <br>        <span class="hljs-type">int</span> b_diff_max = wt[j] * <span class="hljs-number">50</span>; <br>        <span class="hljs-keyword">return</span> diff &lt;= a_diff_max &amp;&amp; diff &lt;= b_diff_max;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">match</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 匹配池中的第一、第二个用户进行匹配</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 每 1 秒调用 1 次 match，实现 wt 自增 1，从而实现使所有用户等待时间增加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t: wt) <br>            t ++ ;<br><br>        <span class="hljs-keyword">while</span> (users.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; users.<span class="hljs-built_in">size</span>(); i ++ )<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = i + <span class="hljs-number">1</span>; j &lt; users.<span class="hljs-built_in">size</span>(); j ++ )<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(i, j)) <br>                    &#123;<br>                        users.<span class="hljs-built_in">erase</span>(users.<span class="hljs-built_in">begin</span>() + j); <br>                        users.<span class="hljs-built_in">erase</span>(users.<span class="hljs-built_in">begin</span>() + i); <br>                        wt.<span class="hljs-built_in">erase</span>(wt.<span class="hljs-built_in">begin</span>() + j); <br>                        wt.<span class="hljs-built_in">erase</span>(wt.<span class="hljs-built_in">begin</span>() + i); <br><br>                        <span class="hljs-built_in">save_result</span>(users[i].id, users[j].id);<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">// 一轮扫描后，发现没有能够匹配的用户，就停止扫描，等待下次调用</span><br>        &#125;<br>    &#125;<br>    ....<br><span class="hljs-keyword">private</span>:<br>    ....<br>    vector&lt;<span class="hljs-type">int</span>&gt; wt; <span class="hljs-comment">//wait_time 记录每个用户的等待时间</span><br>&#125;pool;<br></code></pre></td></tr></table></figure><p>编译，运行，上传</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs SH">g++ -c main.cpp<br>g++ *.o -o main -lthrift -pthread<br>./main<br><br>-------------<br><span class="hljs-comment"># 游戏应用端</span><br>add 1 yxc 2000<br>add 2 zxc 1500<br><span class="hljs-comment"># 匹配系统服务器</span><br>add_user<br>add_user<br><span class="hljs-comment"># 等待了 10 s</span><br>Match Result: 1 2<br>success<br><span class="hljs-comment"># 数据存储服务器</span><br><span class="hljs-comment">## homework/lesson_6/result.txt</span><br>result: 1 2<br>141da30f<br>-------------<br><br><span class="hljs-comment"># 上传到 git 服务器</span><br>git add main.cpp<br>git commit -m <span class="hljs-string">&quot;match server:5.0&quot;</span><br>git push<br></code></pre></td></tr></table></figure><h3 id="作业-6">作业</h3><p>本次作业为复现课上最后一个版本的内容，课程视频地址： <a href="https://www.acwing.com/video/3479/">https://www.acwing.com/video/3479/</a><br>注意：本次作业的2个题目采用整体评测，即如果两个作业同时正确，则得100分；否则如果至少有一个作业错误，则得0分。</p><p>创建好作业后，先进入文件夹 /home/acs/homework/lesson_6/ ，当前目录的文件结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SH">`-- thrift_lesson<br>    |-- game<br>    |   `-- src<br>    |-- match_system<br>    |   `-- src <br>    |-- readme.md<br>    `-- thrift<br>        |-- match.thrift<br>        `-- save.thrift <br></code></pre></td></tr></table></figure><ol start="0"><li>进入 thrift_lesson/match_system/src/ 目录，用cpp实现课上的match-server和save-client逻辑。</li></ol><p>接口文件在thrift_lesson/thrift/中。</p><p>实现后启动server，监听端口9090。</p><p>创建match-server：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cd thrift_lesson/match_system/src<br>thrift -r --gen cpp ../../thrift/match.thrift<br>mv gen-cpp match_server<br>rm match_server/Match_server.skeleton.cpp<br></code></pre></td></tr></table></figure><p>创建save-client：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cd thrift_lesson/match_system/src<br>thrift -r --gen cpp ../../thrift/save.thrift<br>mv gen-cpp save_client<br>rm save_client/Save_server.skeleton.cpp<br></code></pre></td></tr></table></figure><p>创建main.cpp，源代码在<a href="https://git.acwing.com/xiaochaomeng/thrift_lesson/-/blob/master/match_system/src/main.cpp">这里</a>:</p><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">g++ -c main.cpp match_server/*.cpp save_client/*.cpp<br></code></pre></td></tr></table></figure><p>链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">g++ *.o -o main -lthrift -pthread<br></code></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">./main<br></code></pre></td></tr></table></figure><ol><li>进入 thrift_lesson/game/src/ 目录，用 python3 实现课上的 match-client 逻辑。</li></ol><p>文件名和输入格式与课上内容相同。</p><p>创建match-client：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cd thrift_lesson/game/src<br>thrift -r --gen py ../../thrift/match.thrift<br>rm gen-py/match/Match-remote<br>mv gen-py match_client<br></code></pre></td></tr></table></figure><p><a href="http://xn--client-hn3jk46f.py">创建client.py</a>，内容在<a href="https://git.acwing.com/xiaochaomeng/thrift_lesson/-/blob/master/game/src/client.py">这里</a>。</p><p><a href="http://xn--client-vh7lp71w.py">执行client.py</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">python3 client.py<br></code></pre></td></tr></table></figure><h3 id="管道、环境变量与常用命令">管道、环境变量与常用命令</h3><h4 id="管道">管道</h4><p>概念</p><p>管道类似于文件重定向，可以将前一个命令的 <code>stdout</code> 重定向到下一个命令的 <code>stdin</code>。</p><p><strong>要点</strong></p><p>管道命令仅处理 <code>stdout</code>，会忽略 <code>stderr</code>。</p><p>管道右边的命令必须能接受stdin。</p><p>多个管道命令可以串联。</p><p><strong>与文件重定向的区别</strong></p><ul><li>文件重定向左边为命令，右边为文件。</li><li>管道左右两边均为命令，左边有 stdout，右边有 stdin。<br>举例<br>统计当前目录下所有 <code>python</code> 文件的总行数，其中 <code>find、xargs、wc</code> 等命令可以参考常用命令这一节内容。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">find . -name <span class="hljs-string">&#x27;*.py&#x27;</span> | xargs <span class="hljs-built_in">cat</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure><h4 id="环境变量">环境变量</h4><p><strong>概念</strong></p><p>Linux 系统中会用很多环境变量来记录配置信息。</p><p>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p><p><strong>查看</strong></p><p>列出当前环境下的所有环境变量 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">env</span>  <span class="hljs-comment"># 显示当前用户的变量</span><br><span class="hljs-built_in">set</span>  <span class="hljs-comment"># 显示当前shell的变量，包括当前用户的变量;</span><br><span class="hljs-built_in">export</span>  <span class="hljs-comment"># 显示当前导出成用户变量的shell变量</span><br></code></pre></td></tr></table></figure><p>输出某个环境变量的值 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p><strong>修改</strong></p><p>环境变量的定义、修改、删除操作可以参考 shell语法——变量 这一节的内容。</p><p>为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到 <code>~/.bashrc</code> 文件中。</p><p>修改完 <code>~/.bashrc</code> 文件后，记得执行 <code>source ~/.bashrc</code>，来将修改应用到当前的 <code>bash</code> 环境下。</p><p>为何将修改命令放到 <code>~/.bashrc</code> ，就可以确保修改会影响未来所有的环境呢？</p><p>每次启动 <code>bash</code>，都会先执行 <code>~/.bashrc</code>。<br>每次 <code>ssh</code> 登陆远程服务器，都会启动一个 <code>bash</code> 命令行给我们。<br>每次 <code>tmux</code> 新开一个 <code>pane</code>，都会启动一个 <code>bash</code> 命令行给我们。<br>所以未来所有新开的环境都会加载我们修改的内容。</p><p><strong>常见环境变量</strong></p><ol><li><code>HOME</code> : 用户的家目录</li><li><code>PATH</code> : 可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。</li><li><code>LD_LIBRARY_PATH</code> : 用于指定动态链接库(.so 文件)的路径，其内容是以冒号分隔的路径列表。</li><li><code>C_INCLUDE_PATH</code> : C 语言的头文件路径，内容是以冒号分隔的路径列表。</li><li><code>CPLUS_INCLUDE_PATH</code> : CPP 的头文件路径，内容是以冒号分隔的路径列表。</li><li><code>PYTHONPATH</code> : Python 导入包的路径，内容是以冒号分隔的路径列表。</li><li><code>JAVA_HOME</code> : jdk 的安装目录。</li><li><code>CLASSPATH</code> : 存放 Java 导入类的路径，内容是以冒号分隔的路径列表。</li></ol><h3 id="常用命令">常用命令</h3><blockquote><p>yxc: Linux命令非常多，本节讲解几个常用命令。其他命令依赖于大家根据实际操作环境，边用边查。</p></blockquote><h4 id="系统状况">系统状况</h4><ol><li>top : 查看所有进程的信息（Linux的任务管理器）<ul><li>打开后，输入 <code>M</code> : 按使用内存排序</li><li>打开后，输入 <code>P</code> : 按使用CPU排序</li><li>打开后，输入 <code>q</code> : 退出</li></ul></li><li><code>df -h</code> : 查看硬盘使用情况</li><li><code>free -h</code> :查看内存使用情况</li><li><code>du -sh</code> : 查看当前目录占用的硬盘空间</li><li><code>ps aux</code> : 查看所有进程</li><li><code>kill -9 pid</code> : 杀死编号为 pid 的进程<ul><li>传递某个具体的信号 : kill -s SIGTERM pid</li></ul></li><li><code>netstat -nt</code> : 查看所有网络连接</li><li><code>w</code> : 列出当前登陆的用户</li><li><code>ping www.baidu.com</code> : 检查是否连网</li></ol><h4 id="文件权限">文件权限</h4><ol><li><code>chmod</code> : 修改文件权限<ol><li><code>chmod +x xxx</code> : 给xxx添加可执行权限</li><li><code>chmod -x xxx</code> : 去掉xxx的可执行权限</li><li><code>chmod 777 xxx</code> : 将xxx的权限改成777</li><li><code>chmod 777 xxx -R</code> : 递归修改整个文件夹的权限</li></ol></li></ol><h4 id="文件检索">文件检索</h4><ol><li><p><code>find /path/to/directory/ -name '*.py'</code> : 搜索某个文件路径下的所有 *.py 文件</p></li><li><p><code>grep xxx</code> : 从 stdin 中读入若干行数据，如果某行中包含 xxx ，则输出该行；否则忽略该行</p></li><li><p><code>wc</code> : 统计行数、单词数、字节数 既可以从 stdin 中直接读入内容；也可以在命令行参数中传入文件名列表；</p><ol><li><code>wc -l</code> : 统计行数</li><li><code>wc -w</code> : 统计单词数</li><li><code>wc -c</code> : 统计字节数</li></ol></li><li><p><code>tree</code> : 展示当前目录的文件结构</p><ol><li><code>tree /path/to/directory/</code> : 展示某个目录的文件结构</li><li><code>tree -a</code> : 展示隐藏文件</li></ol></li><li><p><code>ag xxx :</code> 搜索当前目录下的所有文件，检索 <code>xxx</code> 字符串</p></li><li><p><code>cut :</code> 分割一行内容<br>从 <code>stdin</code> 中读入多行数据</p><ul><li><code>echo $PATH | cut -d ':' -f 3,5</code> : 输出 PATH 用 : 分割后第 3、5 列数据</li><li><code>echo $PATH | cut -d ':' -f 3-5</code> : 输出 PATH 用 : 分割后第 3-5 列数据</li><li><code>echo $PATH | cut -c 3,5</code> : 输出 PATH 的第 3、5 个字符</li><li><code>echo $PATH | cut -c 3-5</code> : 输出 PATH 的第 3-5 个字符</li></ul></li><li><p><code>sort</code> : 将每行内容按字典序排序</p><ul><li>可以从 stdin 中读取多行数据</li><li>可以从命令行参数中读取文件名列表</li></ul></li><li><p><code>xargs</code> : 将 <code>stdin</code> 中的数据用空格或回车分割成命令行参数</p></li><li><p><code>find . -name '*.py' | xargs cat | wc -l</code> : 统计当前目录下所有 python 文件的总行数</p></li></ol><h4 id="查看文件内容">查看文件内容</h4><ol><li><code>more</code> : 浏览文件内容<ul><li><code>回车</code> : 下一行</li><li><code>空格</code> : 下一页</li><li><code>b</code> : 上一页</li><li><code>q</code> : 退出</li></ul></li><li><code>less</code> : 与 <code>more</code> 类似，功能更全<ul><li><code>回车</code> : 下一行</li><li><code>y</code> : 上一行</li><li><code>Page Down</code> : 下一页</li><li><code>Page Up</code> : 上一页</li><li><code>q</code> : 退出</li></ul></li><li><code>head -3 xxx</code> : 展示 xxx 的前 3 行内容<ul><li>同时支持从stdin读入内容</li></ul></li><li><code>tail -3 xxx </code>: 展示 xxx 末尾 3 行内容<ul><li>同时支持从stdin读入内容</li></ul></li></ol><h4 id="用户相关">用户相关</h4><ol><li><code>history </code>: 展示当前用户的历史操作。内容存放在 ~/.bash_history 中<br><strong>工具</strong></li><li><code>md5sum</code> : 计算 md5 哈希值<ul><li>可以从stdin读入内容</li><li>也可以在命令行参数中传入文件名列表</li></ul></li><li><code>time command</code> : 统计 <code>command</code> 命令的执行时间</li><li><code>ipython3</code> : 交互式 <code>python3</code> 环境。可以当做计算器，或者批量管理文件。<br><code>! echo &quot;Hello World&quot;</code> : <code>!</code> 表示执行 <code>shell</code> 脚本</li><li><code>watch -n 0.1 command</code> : 每 <code>0.1</code> 秒执行一次 <code>command</code> 命令</li><li><code>tar</code> : 压缩文件<br><code>tar -zcvf xxx.tar.gz /path/to/file/* :</code> 压缩<br><code>tar -zxvf xxx.tar.gz :</code> 解压缩</li><li><code>diff xxx yyy :</code> 查找文件 <code>xxx</code> 与 <code>yyy</code> 的不同点</li></ol><h4 id="安装软件">安装软件</h4><ol><li><code>sudo command</code> : 以 <code>root</code> 身份执行 <code>command</code>命令</li><li><code>apt-get install xxx</code> : 安装软件（Ubuntu）<br><code>yum install xxx </code>: 安装软件（CentOS）</li><li><code>pip install xxx --user --upgrade</code> : 安装 python 包<br><code>pip3</code> 升级版的 <code>pip</code></li></ol><h3 id="作业-7">作业</h3><p>创建好作业后，先进入文件夹/home/acs/homework/lesson_7/，然后：</p><ul><li>(0) 进入homework_0文件夹，然后：<br>[1] 编写可执行shell脚本，文件名为mydu，使得在任意目录执行该脚本后，可以输出当前目录所占用的磁盘空间大小，格式化输出（例如 1K, 234M, 2G）。<br>[2] 修改环境变量PATH，使得在任意目录下输入mydu均可执行上述脚本。<br>进入homework_0文件夹</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">vim mydu<br><br>***<br>#! /bin/bash<br><br>du -sh<br>***<br></code></pre></td></tr></table></figure><p>[1] 添加可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">chmod +x mydu<br></code></pre></td></tr></table></figure><p>[2] 在~/.bashrc文件末尾添加一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export PATH=/home/acs/homework/lesson_7/homework_0:$PATH<br></code></pre></td></tr></table></figure><p>应用该修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">source ~/.bashrc<br></code></pre></td></tr></table></figure><ul><li>(1) 进入homework_1文件夹，然后：<br>[1] 给当前目录下的所有文件添加可读权限。<br>[2] 统计当前目录下共有多少个以.cpp结尾的文件，将结果写入ans.txt中。<br>进入入homework_1文件夹；</li></ul><p>[1] 添加可读权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">chmod +r * -R<br></code></pre></td></tr></table></figure><p>[2] 统计行数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">find . -name &#x27;*.cpp&#x27; | wc -l &gt; ans.txt<br></code></pre></td></tr></table></figure><ul><li>(2) 进入homework_2文件夹，然后：<br>[1] 统计当前目录下所有cpp文件的总行数，将结果写入ans1.txt中。<br>[2] 遍历当前目录下所有py文件，统计共有多少行包含字符串thrift，将结果写入ans2.txt中。<br>进入homework_2文件夹。</li></ul><p>[1] 统计cpp文件总行数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">find . -name &#x27;*.cpp&#x27; | xargs cat | wc -l &gt; ans1.txt<br></code></pre></td></tr></table></figure><p>[2] 统计py文件包含thrift字符串的总行数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">find . -name &#x27;*.py&#x27; | xargs cat | grep thrift | wc -l &gt; ans2.txt<br></code></pre></td></tr></table></figure><ul><li>(3) 进入homework_3文件夹，然后删除当前目录下的所有py文件。<br>进入homework_3文件夹。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">find . -name &#x27;*.py&#x27; | xargs rm<br></code></pre></td></tr></table></figure><ul><li>(4) 进入homework_4文件夹，然后：<br>[1] 当前目录下包含一个文件scores.txt，文件中有若干行数据，每行数据包含用空格隔开的3个字段：姓名、数学成绩、算法成绩。<br>[2] 将scores.txt文件的内容以空格为分隔符分隔成3列，将第一列内容写入names.txt，第二列内容写入mathematics.txt，第三列内容写入algorithm.txt。<br>注意：scores.txt文件本身不要修改。<br>进入homework_4文件夹。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cat scores.txt | cut -d &#x27; &#x27; -f 1 &gt; names.txt<br>cat scores.txt | cut -d &#x27; &#x27; -f 2 &gt; mathematics.txt<br>cat scores.txt | cut -d &#x27; &#x27; -f 3 &gt; algorithm.txt<br></code></pre></td></tr></table></figure><ul><li>(5) 进入homework_5文件夹，然后：<br>[1] 当前目录下包含一个文件scores.txt，文件中有若干行数据，每行数据包含用空格隔开的3个字段：姓名、数学成绩、算法成绩。<br>[2] 将scores.txt文件的内容以空格为分隔符分隔成3列，将第一列内容按字典序从小到大排序后写入names.txt。<br>注意：scores.txt文件本身不要修改。<br>进入homework_5文件夹。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cat scores.txt | cut -d &#x27; &#x27; -f 1 | sort &gt; names.txt<br></code></pre></td></tr></table></figure><ul><li>(6) 进入homework_6文件夹，然后将scores.txt文件的前5行写入top.txt，后4行写入bottom.txt。<br>进入homework_6文件夹。</li></ul><p>[1] 选取前5行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">head -5 scores.txt &gt; top.txt<br></code></pre></td></tr></table></figure><p>[2] 选取后4行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tail -4 scores.txt &gt; bottom.txt<br></code></pre></td></tr></table></figure><ul><li>(7) 进入homework_7文件夹，计算scores.txt文件的md5sum，将结果写入ans.txt。注意：ans.txt文件中只包含长度为32的md5sum，不包含其他内容。<br>进入homework_7文件夹。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">md5sum scores.txt | cut -c 1-32 &gt; ans.txt<br></code></pre></td></tr></table></figure><ul><li>(8) 进入homework_8文件夹，然后：<br>[1] 将dir_a文件夹压缩为project_a.tar.gz。<br>[2] 将project_b.tar.gz压缩文件解压到当前目录。<br>注意：不要删除dir_a文件夹和project_b.tar.gz文件。<br>进入homework_8文件夹。</li></ul><p>[1] 压缩文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tar -zcvf project_a.tar.gz dir_a/*<br></code></pre></td></tr></table></figure><p>[2] 解压文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tar -zxvf project_b.tar.gz<br></code></pre></td></tr></table></figure><ul><li>(9) 进入homework_9文件夹，然后计算 2112+3782112+378，将结果写入ans.txt中。<br>进入homework_9文件夹</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ipython3  # 打python3交互环境<br><br>res = 2**112 + 3**78<br><br>! echo $res &gt; ans.txt  # ! 表示后面的内容是shell脚本<br></code></pre></td></tr></table></figure><h2 id="租云服务器及安装docker">租云服务器及安装docker</h2><p>腾讯云 : <a href="https://cloud.tencent.com/">https://cloud.tencent.com/</a></p><p>创建工作用户 acs 并赋予 sudo 权限</p><p>登录到新服务器。打开 AC Terminal，然后 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh root@xxx.xxx.xxx.xxx  <span class="hljs-comment"># xxx.xxx.xxx.xxx替换成新服务器的公网IP</span><br></code></pre></td></tr></table></figure><p>创建acs用户 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">adduser acs  <span class="hljs-comment"># 创建用户acs</span><br>usermod -aG sudo acs  <span class="hljs-comment"># 给用户acs分配sudo权限</span><br></code></pre></td></tr></table></figure><p>配置免密登录方式</p><p>退回AC Terminal，然后配置acs用户的别名和免密登录，可以参考4. ssh——ssh登录</p><p>配置新服务器的工作环境</p><p>将 AC Terminal 的配置传到新服务器上 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">scp .bashrc .vimrc .tmux.conf server_name:  <span class="hljs-comment"># server_name需要换成自己配置的别名</span><br></code></pre></td></tr></table></figure><p>安装 tmux 和 docker</p><p>登录自己的服务器，然后安装 tmux :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH">sudo apt-get update<br>sudo apt-get install tmux<br></code></pre></td></tr></table></figure><p>打开 tmux。（养成好习惯，所有工作都在 tmux 里进行，防止意外关闭终端后，工作进度丢失）</p><p>然后在 tmux 中根据 docker安装教程 安装 docker 即可</p><h3 id="docker教程">docker教程</h3><p>将当前用户添加到 <code>docker</code> 用户组</p><p>为了避免每次使用 <code>docker</code> 命令都需要加上 <code>sudo</code> 权限，可以将当前用户加入安装中自动创建的 <code>docker</code> 用户组(可以参考<a href="https://docs.docker.com/engine/install/linux-postinstall/">官方文档</a>) :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SH">sudo groupadd docker<br>sudo usermod -aG docker <span class="hljs-variable">$USER</span><br>newgrp docker<br><br><span class="hljs-comment"># Verify that you can run docker commands without sudo</span><br>docker run hello-world<br></code></pre></td></tr></table></figure><p><strong>镜像（images）</strong></p><ol><li><p><code>docker pull ubuntu:20.04</code> : 拉取一个镜像</p></li><li><p><code>docker images</code> : 列出本地所有镜像</p></li><li><p><code>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04</code> : 删除镜像 ubuntu:20.04</p></li><li><p><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code> : 创建某个 container 的镜像</p></li><li><p><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code> : 将镜像 ubuntu:20.04 导出到本地文件 ubuntu_20_04.tar 中</p></li><li><p><code>docker load -i ubuntu_20_04.tar</code> : 将镜像 ubuntu:20.04 从本地文件 ubuntu_20_04.tar 中加载出来<br><strong>容器(container)</strong></p></li><li><p><code>docker [container] create -it ubuntu:20.04</code> : 利用镜像 ubuntu:20.04 创建一个容器。</p></li><li><p><code>docker ps -a :</code> 查看本地的所有容器</p></li><li><p><code>docker [container] start CONTAINER</code> : 启动容器</p></li><li><p><code>docker [container] stop CONTAINER</code> : 停止容器</p></li><li><p><code>docker [container] restart CONTAINER</code> : 重启容器</p></li><li><p><code>docker [contaienr] run -itd ubuntu:20.04</code> : 创建并启动一个容器</p></li><li><p><code>docker [container] attach CONTAINER</code> : 进入容器</p></li><li><p>先按 <code>Ctrl-p</code> ，再按 <code>Ctrl-q</code> 可以挂起容器</p></li><li><p><code>docker [container] exec CONTAINER COMMAND</code> : 在容器中执行命令</p></li><li><p><code>docker [container] rm CONTAINER</code> : 删除容器</p></li><li><p><code>docker container prune</code> : 删除所有已停止的容器</p></li><li><p><code>docker export -o xxx.tar CONTAINER</code> : 将容器 CONTAINER 导出到本地文件 xxx.tar 中</p></li><li><p><code>docker import xxx.tar image_name:tag</code> : 将本地文件 xxx.tar 导入成镜像，并将镜像命名为 image_name:tag</p></li><li><p><code>docker export/import</code> 与 <code>docker save/load</code>的区别 :</p><ol><li><code>export/import</code> 会丢弃历史记录和元数据信息，仅保存容器当时的快照状态</li><li><code>save/load</code> 会保存完整记录，体积更大</li></ol></li><li><p><code>docker top CONTAINER</code> : 查看某个容器内的所有进程</p></li><li><p><code>docker stats</code> : 查看所有容器的统计信息，包括CPU、内存、存储、网络等信息</p></li><li><p><code>docker cp xxx CONTAINER:xxx</code> 或 <code>docker cp CONTAINER:xxx xxx</code> : 在本地和容器间复制文件</p></li><li><p><code>docker rename CONTAINER1 CONTAINER2</code> : 重命名容器</p></li><li><p><code>docker update CONTAINER --memory 500MB</code> : 修改容器限制</p></li></ol><blockquote><p>更多可以查阅官方文档，在左上角搜索指令即可</p></blockquote><p>实战</p><p>进入 AC Terminal ，然后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SH"><br><span class="hljs-comment"># 将镜像上传到自己租的云端服务器</span><br>scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:<br><span class="hljs-comment"># 登录自己的云端服务器</span><br>ssh server_name<br><br><span class="hljs-comment"># 将镜像加载到本地</span><br>docker load -i docker_lesson_1_0.tar<br><span class="hljs-comment"># 创建并运行docker_lesson:1.0镜像</span><br><span class="hljs-comment"># 将docker镜像的22号端口映射到服务器的20000号端口</span><br>docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0<br><br><span class="hljs-comment"># 进入创建的docker容器</span><br>docker attach my_docker_server<br><span class="hljs-comment"># 设置root密码</span><br>passwd<br></code></pre></td></tr></table></figure><p>去云平台控制台中修改安全组配置，放行端口 20000</p><p>返回 AC Terminal，即可通过 ssh 登录自己的 docker 容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SH">ssh root@xxx.xxx.xxx.xxx -p 20000  <span class="hljs-comment"># 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址</span><br></code></pre></td></tr></table></figure><p>然后，可以仿照上节课内容，创建工作账户 acs</p><p>最后，可以参考 4. ssh——ssh登录 配置 docker 容器的别名和免密登录</p><p>小Tips</p><p>如果 apt-get 下载软件速度较慢，可以参考 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源软件镜像站</a> 中的内容，修改软件源。</p><h3 id="作业-8">作业</h3><ol start="0"><li>进入 homework_0 文件夹，然后：</li></ol><p>租一台云服务器<br>配置服务器别名及免密登录<br>将服务器别名写在当前目录下的 server_name.txt 文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cd homework/lesson_8/<br>echo tenserver &gt; server_name.txt  # server1要替换成自己起的别名<br></code></pre></td></tr></table></figure><ol><li>进入 homework_1 文件夹，然后：</li></ol><p>在租好的云服务器中安装 docker<br>2. 进入 homework_2 文件夹，然后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tmux  # 好习惯，进入tmux<br><br>sudo apt-get update<br><br>sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br>echo \<br>&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \<br>$(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br>sudo apt-get update<br><br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br><br></code></pre></td></tr></table></figure><ol start="3"><li>将 AC Terminal 中的 /var/lib/acwing/docker/images/docker_lesson_1_0.tar 镜像上传到租好的服务器中<br>登录到租好的服务器<br>将上传的镜像提取出来<br>创建该镜像的容器，设置端口映射：20000:22<br>去云平台控制台中修改安全组配置，放行端口 20000<br>进入该容器，创建新账户 acs<br>返回 AC Terminal。配置容器中 acs 账户的别名及免密登录<br>将别名写在当前目录下的 server_name.txt 文件中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器<br>ssh server_name  # 登录自己的云端服务器<br><br>docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地<br>docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像<br><br># 去云平台放开20000端口<br><br>docker attach my_docker_server  # 进入创建的docker容器<br>adduser acs<br><br>Ctrl-p<br>Ctrl-q  # 挂起容器<br></code></pre></td></tr></table></figure><p>退回AC Terminal，配置别名和免密登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cd homework/lesson_8/homework_2<br>echo server1_docker &gt; server_name.txt  # 将server1_docker换成自己起的别名<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2022/05/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/05/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2022/05/06/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/05/06/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化DP</title>
      <link href="/2022/05/06/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/"/>
      <url>/2022/05/06/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列优化DP</title>
      <link href="/2022/05/06/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/"/>
      <url>/2022/05/06/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位DP</title>
      <link href="/2022/05/06/%E6%95%B0%E4%BD%8DDP/"/>
      <url>/2022/05/06/%E6%95%B0%E4%BD%8DDP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形DP</title>
      <link href="/2022/05/06/%E6%A0%91%E5%BD%A2DP/"/>
      <url>/2022/05/06/%E6%A0%91%E5%BD%A2DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP</title>
      <link href="/2022/05/06/%E5%8C%BA%E9%97%B4DP/"/>
      <url>/2022/05/06/%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩DP</title>
      <link href="/2022/05/06/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
      <url>/2022/05/06/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机模型</title>
      <link href="/2022/05/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列模型</title>
      <link href="/2022/05/06/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/06/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://www.acwing.com/problem/content/1019/">怪盗基德的滑翔翼</a></h1><h2 id="题意分析-44">题意分析</h2><p>有n个楼房，怪盗基德可以任意选择一个楼房作为起点，可以向左滑行，也可以向右滑行，一旦方向确定就不能改变了，求最多滑行的建筑，即左右的最长下降子序列。</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_107a40dbce-1.png" alt="1.png"></p><p>当确定完方向和起点后，最长的距离是什么呢？</p><p>假设起点是a[i]</p><pre><code>如果往左飞，最长距离是从1号点开始以a[i]的结尾的最长上升子序列如果往右飞，最长距离是从n号点开始以a[i]的结尾的最长上升子序列</code></pre><p>因此我们就可以把该问题转换成在两个方向上求解最长上升子序列模型的问题</p><p>时间复杂度$O(n^2)$</p><h2 id="代码-48">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> f[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T -- )<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>        <br>        res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                    f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    <br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -- )<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j -- )<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                    f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    <br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1016/">登山</a></h1><h2 id="题意分析-45">题意分析</h2><p>条件1：要按照编号递增的顺序来浏览 $\to$ 子序列<br>条件2：相邻两个景点的高度不能相同<br>条件3：一旦开始下降，就不能上升 $\to$ 走过的路线必然是先严格单调上升再严格单调下降</p><p>目标：求最多浏览多少景点，求第k类最大长度</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_af49dd79ce-1.png" alt="1.png"></p><p>因为左右两边互不相关，我们先让左边最大，而且右边最大，就可以让我们整个值取得最大值左边的最大值是从1号点开始以a[k]的结尾的最长上升子序列，右边的最大值是从n号点开始以a[k]的结尾的最长上升子序列</p><p>用f[i],g[i]分别维护从1，n号节点开始的最长上升子序列，res=max(f[i] + g[i] - 1)，减一是因为第i个节点算了两次。</p><p>时间复杂度$O(n^2)$</p><h2 id="代码-49">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -- )<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j -- )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/484/">合唱队形</a></h1><h2 id="题意分析-46">题意分析</h2><p>和上面那个题本质一模一样</p><p>答案等于n-上面那个题求出的答案</p><h2 id="代码-50">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -- )<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j -- )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; (n - res) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1014/">友好城市</a></h1><h2 id="题意分析-47">题意分析</h2><p>有一条笔直的河流，河流的两侧有不同的城市，城市位置各不相同，一个城市只能连一条边，每个城市都会唯一的匹配一个城市，求最多选出多少互不相交的边。<br><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_b4006094ce-1.png" alt="1.png"></p><p>条件1：每个城市上只能建立一座桥<br>条件2：所有的桥与桥之间互不相交</p><p>目标：可以建立多少桥？</p><p>对于任何一个合法的建桥方式，一定对应一个单调上升子序列，反过来，一个单调上升的子序列也对应着一个合法的建桥方式</p><p>我们的做法是先按照一个点排序，然后对另一个点做LIS问题即可。</p><h2 id="代码-51">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-type">int</span> n, res;<br>PII q[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;q[i].x, &amp;q[i].y);<br>    <br>    <span class="hljs-built_in">sort</span>(q, q + n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (q[i].y &gt; q[j].y)<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 注意这里因为q[i].y不是有序的所以答案要在1~n的区间里面找      </span><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br># [拦截导弹](https://www.acwing.com/problem/content/1012/)<br>## 题意分析<br><br>## 代码<br>```CPP<br><br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/189/">导弹防御系统</a></h1><h2 id="题意分析-48">题意分析</h2><h2 id="代码-52">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/274/">最长公共上升子序列</a></h1><h2 id="题意分析-49">题意分析</h2><h2 id="代码-53">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字三角形模型</title>
      <link href="/2022/05/06/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/06/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://www.acwing.com/problem/content/1017/">摘花生</a></h1><p>从集合角度考虑DP问题</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_b8a87768ce-1.png" alt="1.png"></p><h2 id="代码-8">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N][N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T -- )<br>    &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>             cin &gt;&gt; w[i][j];<br>             <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + w[i][j];<br>                <br>        cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1020/">最低通行费</a></h1><p>2n - 1 步可以推出来不能走回头路，本质上这个题可以直接用摘花生的题目思路来做</p><h2 id="代码-9">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N][N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//这里要考虑边界问题，不能从i=0，j=0的地方走过去，要初始化一下</span><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            cin &gt;&gt; w[i][j];<br>    <br>    <span class="hljs-comment">//只有（1，1）点才可以从（0，1）走过来</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + w[i][j];<br>            <br>    cout &lt;&lt; f[n][n] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1029/">方格取数</a></h1><h2 id="题意分析-7">题意分析</h2><p>这个题是两次摘花生，但每个数只能摘一次</p><p>我们简单回顾一下摘花生的那个题<br>只走一次：</p><p>f[i,j]表示所有从(1,1)走到(i,j)路径上的最大值</p><p>f[i,j] = max(f[i-1,j],f[i,j-1])+w[i,j]</p><p>走两次：</p><p>f[i1,j1,i2,j2]表示所有从(1,1)(1,1)分别走到(i1,j1),(i2,j2)的路径的最大值</p><p>如何处理同一个格子不能被重复选择</p><p>只有在i1+j1==i2+j2时，两条路径的格子才可能重合</p><p>因此我们可以进行一个优化</p><p>f[k, i1, i2] 表示表示所有从(1,1)(1,1)分别走到(i1,k-i1),(i2,i-i2)的路径的最大值，k表示两条路线的横纵下标之和</p><p>从最后一步考虑，两条路线共有2*2=4种情况<br><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_37569210ce-1.png" alt="1.png"></p><p>考虑第一种情况其他类似<br><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_6cb43315ce-2.png" alt="2.png"></p><p>前面一部分有好多种途径它的数值刚好等于f(k-1,i1-1,i2-1),后面一部分要分情况考虑如果i1==i2，表示两个坐标重合那么就加上w[i1][k-i1]，否则加上w[i1][k-i1]+w[i1][k-i2]，然后在四种情况下求一个MAX</p><p>走过后不用删除格子里面的值，为什么？</p><p>因为你只有在k的那个时间点才有可能走到1号路径或者2号路径走到的格子，错过了，就不会做过去了。</p><h2 id="代码-10">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N][N], f[N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2</span> *n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++ )<br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;<br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= n)<br>                &#123;<br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    <span class="hljs-type">int</span> t;<br>                    <span class="hljs-keyword">if</span> (i1 == i2) t = w[i1][j1];<br>                    <span class="hljs-keyword">else</span> t = w[i1][j1] + w[i2][j2];<br>                    <br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2]);<br>                    x += t;<br>                &#125;<br>            &#125;<br>            <br>    cout &lt;&lt; f[<span class="hljs-number">2</span> * n][n][n] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="acwing.com/problem/content/277/">传纸条</a></h1><h2 id="题意分析-8">题意分析</h2><p>目标：</p><pre><code>集合：所有从左上走到右下，走两遍的方案属性：Max状态表示：状态表示有意义，状态计算好计算这个题和上面的题类似</code></pre><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_e3d78c55ce-1.png" alt="1.png"></p><p>下面证明传纸条为何可以使用方格取数的代码</p><h2 id="证明">证明</h2><p>首先， 从右下角回传可以等价为从左上角同时传两次。要想两个路径除了起点和终点之外没有交点，那么肯定有一条路径完全位于另一条的上方。<br>现在考虑路径有交点的情况：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_25473d19ce-2.png" alt="2.png"></p><p>这种情况其实转换起来很简单，只要把位于红色线段上方的蓝色线段交换颜色就可以了，也就是说当红色处于蓝色的下方的时候，将红色的路径换成从蓝色的那段走是等效的（因为两条路径加起来经过的节点完全没有变）。</p><p>就可以得到：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_28045a82ce-3.png" alt="3.png"></p><p>但是这个时候虽然满足了红色路径完全在蓝色的上方，但是却有交点。但是因为所有节点的权值都为非负数，那么可以证明这种情况永远不可能是最优解。比如以交点（2，2）为例，蓝色从（3，1）绕道或者红色从（1，3）处绕道一定不会比两条路径都从（2，2）处走差。</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_2a6e4bbfce-4.png" alt="4.png"></p><p>绕过交点之后，可以得到蓝色虚线的方案，该方案一定不会比之前的两个实线的方案更差。（当然该方案也不一定是最优的，还要确定应该由蓝色还是红色来走原来的交点的位置。</p><h2 id="结论">结论</h2><p>不论是在 <code>方格取数</code> 中，还是在本题中，最优解永远不会由两段相交的路径组成。<br>那么代码中的相关位置的判断在事实上是起到了上述的确定是让蓝色还是红色走虚线的效果。</p><h2 id="代码-11">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">60</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N][N], f[<span class="hljs-number">2</span> * N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            cin &gt;&gt; w[i][j];<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= n + m; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++ )<br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;<br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= m &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= m)<br>                &#123;<br>                    <span class="hljs-type">int</span> t;<br>                    t = w[i1][j1];<br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += w[i2][j2];<br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2]);<br>                    x += t;<br>                &#125;<br>            &#125;<br>            <br>    cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2022/05/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题知识图谱">背包问题知识图谱</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_40bb11a0ce-1.png" alt="1.png"></p><h2 id="简单回顾">简单回顾</h2><h3 id="01背包问题">01背包问题</h3><p>每个物品只能选择1次,体积循环的时候要从大到小</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_551c74ddd5-1.png" alt="1.png"><br><strong>集合划分</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_5710e6bbd5-2.png" alt="2.png"></p><h3 id="完全背包问题">完全背包问题</h3><p>每个物品可以选无数次，这里s=j/w<br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4f4c9198d5-4.png" alt="4.png"><br><strong>集合划分</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4ca7401ed5-3.png" alt="3.png"><br>我们如果直接这样做的话时间复杂度为$O(n^3)$ ,我们考虑从状态的表示中进行优化</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_cff80399d5-6.png" alt="6.png"></p><p>我们发现被黄色框框起来的项非常的像，首先一一对应，每一个框内，都是上面一个参数比下面的多一个w</p><p>因此我们可以直接替换得到 f[i,j]=max(f[i-1,j],f[i,j-v]+w)</p><p><strong>当空间优化成1维之后，只有完全背包问题和单调队列优化多重背包问题的体积是从小到大循环的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">for</span> 物品<br>    <span class="hljs-keyword">for</span> 体积<br>        <span class="hljs-keyword">for</span> 决策<br></code></pre></td></tr></table></figure><h3 id="多重背包问题">多重背包问题</h3><p>每个物品可以选0~s[i]次<br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4f4c9198d5-4.png" alt="4.png"><br><strong>集合划分</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4ca7401ed5-3.png" alt="3.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_f466c256d5-7.png" alt="7.png"></p><p>首先每一个部分都是对应的，上面比下面多一个w，但是下面多了一项f[i-1,j-(s+1)w]+sw，我们知道整个集合的最大值，并不能知道下面黄框框里面的最大值，就比如最大值是最后一项，黄框框里面的最大值就不清楚，因为有这样一点，所以我们并不能像完全背包问题那样处理</p><p>但是好在天无绝人之路，我们往后多写几项，我们可以发现最大值可以由一个长度为s的窗口来求出，记得加上偏移量<br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_aa5fa894d5-8.png" alt="8.png"></p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法</title>
      <link href="/2022/05/06/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/06/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们通过例题来学习莫队算法的思想</p><h1><a href="https://www.acwing.com/problem/content/2494/">基础莫队 HH的项链</a></h1><h1>题意分析</h1><p>给我们一个长度为n的序列，序列里面每个数的范围是[0, 1e6]，有m个询问，询问序列中某一段当中不同数字的个数。</p><p>莫队主要来优化暴力做法，为了理解莫队是如何优化暴力的，我们来看一下如何用暴力处理这个题目。</p><p>对于每个区间，我们暴力去循环就可以了，我们开一个cnt数组，用来记录当前每个数出现多少次，最开始cnt数组全零，长度为1e6+1，我们从前往后扫描下要查询的区间，然后统计下cnt数组里面非零的数，这样做的时间复杂度为$O(mnS)$</p><p>但是有一个比较直接的优化，可以不用乘S，就是说我们可以边去扫描，边去处理有多少个数，我们统计次数的时候只统计第一次出现的次数，时间复杂度为$O(nm)$</p><p>然后我们看一下怎么继续优化，与双指针算法思想类似，我们先将所有的询问排一个序，假设我们询问的上一个区间是蓝色标记的区间，当前查询的区间为红色区间，我们通过增量式的算法通过前一段的信息，去算后一段的信息，假设我们已经求出来蓝色区间内部的信息，将其存到cnt数组里面，我们现在用两个指针指向蓝色区间的端点，首先我们先将i走到红色区间的右端，每次i往后走时，相当于我们需要再cnt数组里面加上一个新的数，如果我们在cnt里面加上一个数x，如果这个x没有出现过，那么cnt[x] + + , res + + ，反之cnt[x] + + ， res不变。我们可以用$O(1)$的时间维护好cnt数组和不同数的个数，第二次我们再将j这个指针一步步移到红色区间的左侧，那么每次j往后走的时候，相当于我们需要再cnt数组立案删掉一个数x，x的出现次数大于1，我们直接让cnt[x] - - ，res不变，x出现次数等于1，我们直接让cnt[x] ++ , res - -; 我们可以利用前一个区间，利用增量的形式来处理。<br><img src="https://cdn.acwing.com/media/article/image/2022/05/07/99310_2fc8c9d2cd-1.png" alt="1.png"></p><p>如果直接这样做的话，前一个区间移动到后一个区间时，最坏的情况下，我们两个指针要移动$O(n)$次，一共有m个询问，所以最坏的复杂度为$O(nm)$</p><p>我们看一下莫队算法如何去优化它，我可以调整一下查询的区间的顺序使得我们可以把时间复杂度变为$O(n\sqrt n)$</p><p>来讨论一下它的优化思路，如果说我们的某一列区间右端点递增，左端点无所谓，它右指针走的复杂度为$O(n)$，但两个指针不一定同时为$O(n)$，左指针可以用分块的方法来优化。</p><p>具体做法是我们让区间第一关键字时左端点分块所在的编号，按照左端点分块的编号来排，如果分块相同的话，按照右端点排序，如果分块不同的话，按照左端点所在的分块编号排序，相当于我们将所有的查询操作分成$\sqrt n$ 块，在每一块内部右端点递增，分析下时间复杂度为多少，右指针走的总数不会超过n，一共有$\sqrt n$块，所以右端点要走$n \sqrt n$步，考虑左端点，第一中情况是在块内移动，最多移动$\sqrt n$ $O(m \sqrt n)$, 第二种情况是不同块之间移动,最坏情况是 $2 \sqrt n$ $O(2n)$</p><p>莫队的玄学优化：奇数块块内按照右端点按照从小到大排，偶数块内按照右端点从大到小排。<br>前一次右端点从小到大滚，下一次就会从大到小滚，这样就会滚回来，但如果是都是从小到大排，前一次是从小到大滚，因为是增量算法，下一次就会先从大到小滚回来，然后在从小滚到到，因此这种处理方法会优化一定的复杂度。</p><p>然后是块的大小的计算，假设我们块的大小为a，那么右端点的复杂度大概为$\frac{n}{a} * n = \frac{n^2}{a}$, 左端点的复杂度大概为$am$ 有$\frac{n^2}{a} = am$ 解得 $a=\sqrt {\frac{n^2}{m}}$</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDQ分治</title>
      <link href="/2022/05/06/CDQ%E5%88%86%E6%B2%BB/"/>
      <url>/2022/05/06/CDQ%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>CDQ分治能够快速的找出来三维偏序的问题,也就是对于一个n的序列，每个i有多少个j使得$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$</p><p>假设$a_i$ 不等于$a_j$</p><p>我们首先看一下一维版本我们将所有的元素按照第一关键字排序，对于i来说一共有i-1个j满足条件</p><p>然后看一下二维版本，将所有元素按照双关键字排序，也就是我们以a按照第一关键子排序，以b按照第二关键字排序，我们可以从前往后扫描，当我们扫描第i个元素的时候，所有满足要求的j一定在第i个元素前面，i前面的序列必然满足$a_j \leq a_i$，i的后面必然不满足，我们要做的是在前面i-1个元素中有多少个元素满足$b_j \leq b_i$</p><blockquote><p>双关键字排序的作用是对于i来说，满足要求的j一定是在i的前面，如果我们按照A来排，那么这个性质就不一定会成立。</p></blockquote><ul><li><p>我们可以用树状数组来做，我们可以将b离散化到1-n之间的数，但我们要求前面有多少个数小于等于$b_i$时，相当于求$b_i$的前缀和，然后我们求完后，将第i个元素插入到树状数组里面，将树状数组里面$b_i$这个位置加一。</p></li><li><p>我们也可以用分治做法来做，分治的话类似于归并排序求逆序对，我们现在想求的是对于当前区间，每一个i满足要求的j有多少个，我们可以将所有的i，j对分为3类（i在后，j在前）</p></li></ul><ol><li>i，j都在左侧 $\to$ 递归左边</li><li>i，j都在右侧 $\to$ 递归右边</li><li>i在右侧，j在左侧，因为一定满足第一维性质，所以我们只需要考虑第二维性质，我们需要找出$b_j \leq a_i$的个数，我们每次合并的时候，按照b进行维护序列，可以使用双指针算法，我们i和j从左往右枚举，每次i向后移动一格，j向后移动，找到大于$b_i$的位置<br>算法复杂度$O(nlogn)$</li></ol><p>最后讨论三维问题<br>对于每个i来说，我们都要求满足$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$的j的数目有多少。</p><p>我们的做法是按照三关键字排序，这样做的好处是，所有满足要求的j一定是在i的左侧</p><p>我们可以将所有&lt;i, j&gt; 分成三类 （i在j右边）</p><ol><li>i，j都在左侧</li><li>i，j都在右侧</li><li>i在左，j在右</li></ol><p>对于a条件来说这个限制一定成立，我们不用考虑，我们可以在归并分治的过程中，将区间的所有元素按照b进行排序，我们对于右侧任意一个元素i来说，我们要求的是在左侧有多少个j满足$b_j \leq b_i, c_j \leq c_i$ ,第二维限制我们可以用双指针算法来解决，对于每一个i我们找到第一个$b_j &gt; b_i$的位置（线性复杂度）那么从区间起点到j-1的位置就是满足$b_j \leq b_i$的区间，然后我们需要在这个区间里面找到$c_j \leq c_i$ 的个数，这个可以采用树状数组的方法来解决，我们可以把所有的c离散化，变成从1~n的某个数，我们要想求$c_j \leq c_i$ 的个数相当于求1-$c_i$的总和，即求前缀和，每一次j往后移动一格，相当于在树状数组里面加上$c_j$</p><p>时间复杂度为$O(nlog^2n)$,一共有$logn$层，每层复杂度为$nlogn$</p><p>如果出现$a_j = a_i,$   $b_j  = b_i,$ $c_j = c_i$,我们可以发现排完序后这两个数一定挨在一起，我们对于后面这个元素我们可以正确求解，但对于前面这个元素来讲，它只考虑它前面的元素，没有考虑右侧的部分，那么他就会把和他相等的元素漏掉，对于这样完全相同的元素，我们要进行判重，在序列中去除掉，再记录下每个元素出现了多少次。我们对于同一种元素我们还要更新下答案，如果有k个元素和第i个元素完全相同，那么答案还需要加上k</p><h1><a href="https://www.acwing.com/problem/content/2817/">例题1 三维偏序</a></h1><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, c, s, res;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Data&amp;t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (a != t.a) <span class="hljs-keyword">return</span> a &lt; t.a;<br>        <span class="hljs-keyword">if</span> (b != t.b) <span class="hljs-keyword">return</span> b &lt; t.b;<br>        <span class="hljs-keyword">return</span> c &lt; t.c;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Data&amp;t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c;<br>    &#125;<br>&#125;q[N], w[N];<br><span class="hljs-type">int</span> tr[M], ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; M; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].b &lt;= q[j].b) <span class="hljs-built_in">add</span>(q[i].c, q[i].s), w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].c), w[k ++ ] = q[j ++ ];<br>        <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) <span class="hljs-built_in">add</span>(q[i].c, q[i].s), w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) q[j].res += <span class="hljs-built_in">query</span>(q[j].c), w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= mid; i ++ ) <span class="hljs-built_in">add</span>(q[i].c, -q[i].s);<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; i ++ , j ++ ) q[i] = w[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        q[i] = &#123;a, b, c, <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q, q + n);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<span class="hljs-comment">//q[0]直接入队，k从0开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">if</span> (q[i] == q[k - <span class="hljs-number">1</span>]) q[k - <span class="hljs-number">1</span>].s ++ ;<br>        <span class="hljs-keyword">else</span> q[k ++ ] = q[i];<br>        <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k ; i ++ )<br>        ans[q[i].res + q[i].s - <span class="hljs-number">1</span>] += q[i].s;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[i]);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/2849/">例题2 老C的任务</a></h1><h1>题意分析</h1><p>在一个城市里面有很多的点，每个点有一个权值，每次询问给我们一个一个矩形，问我们矩形内部的所有点权值和为多少<br><img src="https://cdn.acwing.com/media/article/image/2022/05/06/99310_83499672cd-1.png" alt="1.png"></p><p>我们可以用二维前缀和来求矩阵内部的权值和，对于每个点来说，我们要求一下这个点左下方所有点的权值和，只要我们可以求出这个权值和，那么我们就可以利用二维前缀和求出前缀和，此外我们要区分一下标记点和查询点，标记点我们标记为0，查询点我们标记为1。每个点的坐标为$(x_i,y_i,z_i)$ 其中$z_i \in {1, 0}$</p><p>那么问题就转换程对于每个i求$x_j \leq x_i y_j \leq y_i z_j \leq z_i$的所有点的权值和，所以该问题就可以转换为CQD分治，分析本题的z值比较特殊，我们求小于等于某个数的个数需要使用树状数组，但这个里面，z要么取0，要么取1，那我们每一次相当于求$z_i=0$的点的权值和，我们可以直接用sum来维护$z_i=0$的点的权值和<br>因为不需要使用树状数组所以时间复杂度为$O(nlogn)$</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> x, y, z, p, id, sign;<br>    LL sum;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Data&amp; t)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x != t.x) <span class="hljs-keyword">return</span> x &lt; t.x;<br>        <span class="hljs-keyword">if</span> (y != t.y) <span class="hljs-keyword">return</span> y &lt; t.y;<br>        <span class="hljs-keyword">return</span> z &lt; t.z;<br>    &#125;<br>&#125;q[N], w[N];<br>LL ans[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    LL sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].y &lt;= q[j].y) sum += !q[i].z * q[i].p, w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> q[j].sum += sum, w[k ++ ] = q[j ++ ];<br>        <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) sum += !q[i].z * q[i].p, w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) q[j].sum += sum, w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; i ++ , j ++ ) q[i] = w[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y, p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;p);<br>        q[i] = &#123;x, y, <span class="hljs-number">0</span>, p&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> k = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x1, x2, y1, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        q[k ++ ] = &#123;x2, y2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>&#125;;<br>        q[k ++ ] = &#123;x1 - <span class="hljs-number">1</span>, y2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">-1</span>&#125;;<br>        q[k ++ ] = &#123;x2, y1 - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">-1</span>&#125;;<br>        q[k ++ ] = &#123;x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q, q + k);<br>    <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++ )<br>        <span class="hljs-keyword">if</span> (q[i].z)<br>            ans[q[i].id] += q[i].sum * q[i].sign;<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/2821/">例题三 动态逆序对</a></h1><h1>题意分析</h1><p>对于序列 A，它的逆序对数定义为满足 $i&lt;j$，且 $A_i&gt;A_j$ 的数对 (i,j) 的个数。</p><p>给 1 到 n 的一个排列，按照某种顺序依次删除 m 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。</p><p>首先我们可以发现<br>$p_i$ i的下标</p><p>$A_i$ 元素的值</p><p>$T_i$ 表示元素i被删除的时间，定义删除的时序，如果没有被删我们任意给他分配一个后面的数，为了方便起见，只要有序就可以，我们可以倒着来分配，第一次删除的时候我们的时间戳是n，第二次是n-1，第m次删除的数位n-m+1，剩下的数按照某种顺序分配就可以，那这样的话，每一个数都会有一个唯一的时间戳，至于为什么要倒着分配，是因为你如果倒着来赋值的话，会发现第三维要满足的关系为$T_i \leq T_j$ 这是一个前缀和，如果正着赋值的话，会求一个后缀和，树状数组比较好处理前缀和。</p><p>然后我们考虑下怎么去统计答案，我们要统计的是每一次删除之前有多少个逆序对，因此我们统计的时候应该按照时间来看，我们要按照被删除的时间算答案，对于每一个时间戳$T_j$来说，我们要求和$T_j$可以构成逆序对的数目有多少个，我们把结果存到S[$T_j$]的数组里面，S[i]表示的是和第i个时间被删除的这个元素构成的逆序对的数量（只考虑$T_j$时刻仍然存在的元素）</p><p>我们规定每个数对（i，j），我们看一下那个数更后被删除我们就把这个数对累加到靠后删除的数对，这样不会导致逆序对被多算。</p><p>我们要求的是删除一个元素之前统计整个序列的逆序对数，相当于求两个数都在第i个时刻之后的部分的总数，这些数应该就是$S_1+S_2+…+S_i$也就是$S_i$的前缀和</p><p>现在问题就转换成如何求S[$T_j$]，我们看一下$T_j$的性质</p><ol><li>$T_i &lt; T_j$</li><li>第一种情况 $P_i &lt; P_j, A_i &gt; A_j$ 第二种情况 $P_j &lt; P_i, A_j &gt; A_i$</li></ol><p>因此我们要求两种偏序关系</p><ol><li>$T_i &lt; T_j, P_i &lt; P_j, A_i &gt; A_j$</li><li>$T_i &lt; T_j, P_j &lt; P_i, A_j &gt; A_i$</li></ol><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> a, t, res;<br>&#125;q[N], w[N];<br><span class="hljs-type">int</span> tr[N], pos[N];<br>LL ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = mid, j = r;<br>    <span class="hljs-keyword">while</span> (i &gt;= l &amp;&amp; j &gt; mid)<br>        <span class="hljs-keyword">if</span> (q[i].a &gt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i -- ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">while</span> (j &gt; mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt;= mid; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    j = l, i = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid &amp;&amp; i &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i ++ ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = mid + <span class="hljs-number">1</span>; k &lt; i; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) w[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; j ++ , i ++ ) q[i] = w[j]; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i].a);<br>        pos[q[i].a] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        q[pos[x]].t = j -- ;<br>        pos[x] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = n - m; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (pos[i] != <span class="hljs-number">-1</span>)<br>            q[pos[i]].t = j -- ;<br>            <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) ans[q[i].t] = q[i].res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) ans[i] += ans[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n; i &lt; m; i ++, j -- ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[j]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL总结</title>
      <link href="/2022/05/06/STL%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/06/STL%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分块之基本思想</title>
      <link href="/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
      <url>/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1>分块思想</h1><p>分块的思想其实就是一个朴素的暴力做法。<br>我们把一个区间分成$\sqrt{n}$段，对于查询的区间，我们可以将其分成最多两个不完整段（长度$\leq \sqrt{n}$）和不超过$\sqrt{n}$个完整段。因此我们可以把$O(N)$复杂度变为$O(logn)$</p><h2 id="例题1"><a href="https://www.acwing.com/activity/content/problem/content/2760/">例题1</a></h2><p>维护两个变量</p><ul><li>add使本段中所有值都要加上add（lazy）</li><li>sum本段的真实值使多少（算上add）</li></ul><ol><li>修改 $O(\sqrt(n))$</li></ol><ul><li>完整段，我们要对于这个段的所有数，$add=add+d,sum=sum+d*length$</li><li>段内，暴力，枚举所有数$w_i=w_i+d, sum=sum+d$</li></ul><ol start="2"><li>查询操作 $O(\sqrt(n))$</li></ol><ul><li>完整段，累加sum</li><li>段内，暴力每组求和</li></ul><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">350</span>;<br><br><span class="hljs-type">int</span> n, m, len;<br><span class="hljs-type">int</span> w[N], pos[N];<br>LL add[M], sum[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pos[l] == pos[r])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) w[i] += d, sum[pos[i]] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span> (pos[i] == pos[l]) w[i] += d, sum[pos[i]] += d, i ++ ; <br>        <span class="hljs-keyword">while</span> (pos[j] == pos[r]) w[j] += d, sum[pos[j]] += d, j -- ;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pos[i]; k &lt;= pos[j]; k ++ ) sum[k] += d * len, add[k] += d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pos[l] == pos[r])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) res += w[i] + add[pos[i]];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span> (pos[i] == pos[l]) res += w[i] + add[pos[i]], i ++ ;<br>        <span class="hljs-keyword">while</span> (pos[j] == pos[r]) res += w[j] + add[pos[j]], j -- ;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pos[i]; k &lt;= pos[j]; k ++ ) res += sum[k];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    len = <span class="hljs-built_in">sqrt</span>(n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>        pos[i] = i / len;<br>        sum[pos[i]] += w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);<br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;C&#x27;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> d;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d);<br>            <span class="hljs-built_in">change</span>(l, r, d);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(l, r));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块之块状链表</title>
      <link href="/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>块状链表</h1><p>把原来的序列分成若干块，每一块会用双向链表维护，每一段长度不定</p><ul><li>插入一段 $O(\sqrt(n))$ 首先分裂节点，然后在分裂点插入序列</li><li>删除一段 $O(\sqrt(n))$ 首先删除开头节点的后半部分，然后删除中间完整节点，最后删除结尾节点的前半部分</li><li>合并块状链表 遍历整个块状链表，若下一个点可以合并至当前点，则合并，该操作是保证时间复杂度的关键 $O(\sqrt(n))$</li></ul><h1><a href="https://www.acwing.com/problem/content/949/">例题</a></h1><h1>rope</h1><p>这里介绍下rope容器<br>Rope其主要是结合了链表和数组各自的优点，链表中的节点指向每个数据.<br>时间复杂度为$O(n \sqrt n)$可以在很短的时间内实现快速的插入、删除和查找字符串，是一个很厉害的神器！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/rope&gt;</span><span class="hljs-comment">///头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br>rope &lt;<span class="hljs-type">int</span>&gt; x;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    x.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">///在末尾加x</span><br>    x.<span class="hljs-built_in">insert</span>(pos, x); <span class="hljs-comment">///在pos位置加入x</span><br>    x.<span class="hljs-built_in">erase</span>(pos, x); <span class="hljs-comment">///从pos位置删除x个元素</span><br>    x.<span class="hljs-built_in">copy</span>(pos, len, x); <span class="hljs-comment">///从pos开始len个元素用x代替</span><br>    x.<span class="hljs-built_in">replace</span>(pos, x); <span class="hljs-comment">///从pos开始全部换为x</span><br>    x.<span class="hljs-built_in">substr</span>(pos, x); <span class="hljs-comment">///提取pos开始x个元素</span><br>    x.<span class="hljs-built_in">at</span>(x)/[x]; <span class="hljs-comment">///访问第x个元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次队内赛题解</title>
      <link href="/2022/05/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%9F%E5%86%85%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%9F%E5%86%85%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay</title>
      <link href="/2022/05/01/Splay/"/>
      <url>/2022/05/01/Splay/</url>
      
        <content type="html"><![CDATA[<h1>Splay</h1><p>平衡树里面有Splay，红黑树，treap，AVL，B树以及B+树</p><ul><li>treap好写，但比较局限</li><li>红黑树系统里面会用但代码太长</li><li>Splay代码适中，较为灵活，可以处理很多有关线段的问题</li></ul><p>首先Splay是一个平衡二叉树，但没有那么平衡<br>先讲解下左旋和右旋，旋转的目的是在保证树的中序遍历不变的情况下，降低树的高度<br><strong>平衡二叉树</strong><br>定义：二叉查找树（Binary Search Tree）它或者是一棵空树；或者是具有下列性质的二叉树：</p><ol><li>树中每个结点被赋予了一个权值；（下面假设不同结点的权值互不相同。）</li><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉查找树；</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_9d84988cc8-4.png" alt="4.png"></p><p>二叉查找树能够支持多种动态集合操作，只要所维护的数据集合存在偏序关系（简单来说就是定义了小于等于）</p><p>Splay保证树的高度的做法是什么呢？</p><p>它会在平衡树的操作上进行修改，核心在于每操作一个节点，均将该节点旋转到树根，可以证明每次操作的平均复杂度为$O(logn)$</p><ul><li>插入 将插入的节点旋转到树根</li><li>查询 将查询的节点旋转到树根</li></ul><p>接下来我们来看一下怎么把一个点旋转到树根。<br>我们定义函数Splay(x, k)将点x旋转至点k下面，Splay(x,0)代表把x旋转到根</p><p><strong>左旋右旋</strong><br>节点 x 的父节点 y 是根节点。这时，如果 x 是 y 的左孩子，我们进行一次 Zig（右旋）操作；如果 x 是 y 的右孩子，则我们进行一次 Zag（左旋）操作。经过旋转，x 成为二叉查找树 S 的根节点，调整结束。如图所示：<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_e554a3a9c8-1.png" alt="1.png"><br><strong>情况1</strong><br>节点x 的父节点y 不是根节点，y 的父节点为z，且x 与y 同时是各自父节点的左孩子或者同时是各自父节点的右孩子。这时，我们进行一次Zig-Zig操作或者Zag-Zag操作。也就是xyz为一条直线，先转y再转x，如图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_2c32fdf7c8-5.png" alt="5.png"><br><strong>情况2</strong><br>节点x的父节点y不是根节点，y的父节点为z，x与y中一个是其父节点的左孩子而另一个是其父节点的右孩子。这时，我们进行一次Zig-Zag操作或者Zag-Zig 操作。如果是折现的话就先转x再转x，如图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_412fd6f0c8-6.png" alt="6.png"></p><p>考虑插入的情况</p><ul><li>将x根据数值插入Splay首先在Splay遵循二叉搜索树的特点找到x的位置，然后将旋转到根节点</li><li>将一个序列插到y的后面，先找y的后继z<br>第一步将y转到根 Splay(y, 0)<br>第二步将z转到y的下面 Splay(z, y),分析可知z是y的右子树，而y的后继是z所以z的左子树一定为空，<br>第三步将这个序列直接放到z的左子树上就可以了</li><li>我们删除序列[L, R]<br>我们先找到L的前驱L-1，和R的后继R+1<br>第一步先将L-1这个点转到根节点 Splay(L - 1, 0)<br>第二步将R+1这个点转到根节点的下面 Splay(R + 1, L - 1),此时R+1这个点的左子树就是序列[L, R],直接把左子树置为空子树就可以了。</li></ul><p>下面讨论下Splay如何维护信息(以区间翻转为例)</p><ul><li>找第k个数 size</li><li>懒标记<br><strong>两个操作</strong><br>pushup()维护信息 旋转最后<br>root-&gt;size=root-&gt;left-&gt;size+root-&gt;right-&gt;size+1<br>pushdown()下传懒标记 递归前<br>swap(root-&gt;left, root-&gt;right)<br>标记下传，清空</li></ul><h3 id="例题一-Splay"><a href="https://www.acwing.com/problem/content/2439/">例题一:Splay</a></h3><h2 id="代码-7">代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.3与课后课程笔记</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>项目</h1><h2 id="问题描述">问题描述</h2><p>给定一个图，设计一个程序，找出一条从某一顶点A到另一顶点B边数最少的一条路径</p><p>输入：第一行输入两个数n、m，n表示图中有n个点，m表示接下来的m行每行输入两个数x、y，表示x,y间有一条无向边。最后输入a、b，表示询问一条从某一顶点a到另一顶点b边数最少的一条路径</p><p>输出：若a到b无路径，则输出“There is no path”，否则输出a到b路径上各顶点（各顶点之间用空格分隔）</p><h2 id="解题思路-9">解题思路</h2><ol><li><p>建立邻接矩阵：这个无向图用一个n*n大小的二维矩阵graph[][]来存储</p></li><li><p>寻路：采用广搜（bfs）的方法，从a开始依次访问与a邻接的点v1、v2、……、vk，若没有到达b，则继续访问与v1的邻接的点v11、v12、……、v1k，……。如此下去，直到访问到b。用这样的方法，最先到达b的路径一定是边数最少的路径</p></li><li><p>记录：采用队列来记录被访问过的点。每次访问与队列头部邻接的点，然后删去队列头部的点。如果队列为空队列，则说明a到b无路径</p></li></ol><h2 id="设计思想">设计思想</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_94dfdf64c8-1.png" alt="1.png"></p><h2 id="测试结果-2">测试结果</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9ae2231cc8-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9f9d4debc8-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_a200c7a8c8-5.png" alt="5.png"></p><h2 id="代码-68">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123; <br>    <span class="hljs-type">int</span> q[max];<br>    <span class="hljs-type">int</span> f,r;<br>&#125;q;<br>q Q;<br><br><span class="hljs-type">int</span> graph[max][max],z[max],path[max];;<br><span class="hljs-type">int</span> n,m,x,y,a,b; <br><span class="hljs-type">bool</span> judge;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enq</span><span class="hljs-params">(q *Q,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123; <br>    Q-&gt;q[Q-&gt;r]=x;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == max<span class="hljs-number">-1</span>) Q-&gt;r=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">else</span> Q-&gt;r++;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == Q-&gt;f) cout&lt;&lt;<span class="hljs-string">&quot;Error!&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">(q *Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == Q-&gt;f) cout&lt;&lt;<span class="hljs-string">&quot;Error!&quot;</span>&lt;&lt;endl; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Q-&gt;q[Q-&gt;f];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deq</span><span class="hljs-params">(q *Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == Q-&gt;f) cout&lt;&lt;<span class="hljs-string">&quot;Error!&quot;</span>&lt;&lt;endl; <br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(Q-&gt;f == max<span class="hljs-number">-1</span>) Q-&gt;f=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> Q-&gt;f++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(q Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.f == Q.r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   cin&gt;&gt;n&gt;&gt;m;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>   &#123;<br>       <span class="hljs-type">int</span> x,y;<br>       cin&gt;&gt;x&gt;&gt;y;<br>       graph[x][y]=<span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Q.f=<span class="hljs-number">0</span>;<br>    Q.r=<span class="hljs-number">0</span>;<br>    path[<span class="hljs-number">0</span>]=a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a == b) graph[a][a]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">enq</span>(&amp;Q,a);<br>        graph[a][a]=<span class="hljs-number">-1</span>;<br>        judge=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">compare</span>(Q) &amp;&amp; !judge)<br>        &#123;<br>            a=<span class="hljs-built_in">front</span>(&amp;Q);<br>            <span class="hljs-built_in">deq</span>(&amp;Q);<br>            <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; !judge)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(graph[a][j]==<span class="hljs-number">1</span> &amp; graph[j][j]!=<span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">enq</span>(&amp;Q,j);<br>                    graph[j][j]=<span class="hljs-number">1</span>;<br>                    z[j]=a; <br>                    <span class="hljs-keyword">if</span>(j == b &amp;&amp; graph[a][j] == <span class="hljs-number">1</span>) judge=<span class="hljs-literal">true</span>; <br>                &#125;<br>                <span class="hljs-keyword">if</span>(!judge) j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i=b;<br>    <span class="hljs-keyword">while</span>(i!=a)<br>    &#123;<br>        path[k]=i;<br>        k++;<br>        i=z[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Build</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;请输入起点和终点&quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-built_in">Init</span>();<br>    <span class="hljs-built_in">FindPath</span>(a,b);<br>    <span class="hljs-keyword">if</span>(judge) <span class="hljs-built_in">PrintPath</span>(a,b);<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;There is no path&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>课程笔记</h1><ol><li><p>对于一个具有n个顶点的无向图，若采用邻接矩阵表示，则该矩阵的大小是(D)</p><p>A. n         B. $(n-1)^2$   C.n-1  D. $n^2$</p></li><li><p>带权有向图G用邻接表矩阵A存储，则顶点i的入度等于A（D）</p><p>A．第i行非∞的元素之和       B. 第i列非∞的元素之和</p><p>C．第i行非∞且非0的元素个数  D. 第i列非∞且非0的元素个数</p></li><li><p>算法设计题<br>假设一个有向图G采用邻接矩阵存储，分别设计实现以下要求的算法：</p><p>求出图G中每个顶点的入度</p><p>求出图G中每个顶点的出度</p><p>求出图G中出度最大的一个顶点，并输出该顶点编号。</p><p>计算图G中出度为0的顶点数</p><p>判断图G中是否存在边&lt;I,j&gt;</p><p>输入：</p><p>第一行输入两个数num，n。num表示图G有num个点，n表示下面要输入n行信息。输入保证$i,j \leq num$。</p><p>接下来的n行，每行输入两个数字i,j，表示图G有一条由点i指向点j的有向边。</p><p>接着输入一个数m，m表示要询问m次图G中是否存在边&lt;i,j&gt;。</p><p>再接下来的m行，每行输入两个数字i,j，表示询问图G中是否存在边&lt;i,j&gt;。</p><p>输入保证$i,j \leq num$。</p><p>输出：</p><p>输出图G中每个顶点的入度；</p><p>输出图G中每个顶点的出度；</p><p>输出图G中出度最大的顶点的编号；</p><p>输出图G中出度为0的顶点数；</p><p>后面对于每次询问，若存在该边，则输出YES；否则输出NO。</p></li></ol><h2 id="代码-69">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m, q;<br><span class="hljs-type">int</span> g[N][N], in[N], out[N], id, cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        in[b] ++ , out[a] ++ ;<br>        <span class="hljs-keyword">if</span> (max &lt; out[a])<br>        &#123;<br>            max = out[a];<br>            id = a;<br>        &#125;<br>        g[a][b] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个节点的入度为%d 出度为%d\n&quot;</span>, i, in[i], out[i]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出度最大的点的编号为%d\n&quot;</span>, id);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!out[i])<br>            cnt ++ ;<br>            <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出度为0的点有%d个\n&quot;</span>, cnt);<br>            <br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span> (g[a][b]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-2">结果</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_e6b90461c8-1.png" alt="1.png"></p><ol start="4"><li>设计算法，打印连通图G中每个顶点一次且仅一次，并要求打印次序满足以下条件：距离顶点v0近的顶点先于距离远的顶点（以边数为单位）。<br>输入：</li></ol><p>第一行输入两个数n，m，n表示无向图的点的数量，m表示输入m条边的信息。</p><p>接下来的m行，每行输入i和j，表示点i和点j之间有一条无向边。</p><p>输出：</p><p>输出为一行，按距离顶点近的顶点先于距离远的顶点的次序打印连通图G中每个顶点一次且仅一次，点与点之间用空格分隔。</p><h2 id="解题思路-10">解题思路</h2><p>假设图G是无向图，建立好无向图后bfs（相当于二叉树的层序遍历，就是一一个点为中心，遍历他周围的节点）就能按距离顶点近的顶点先于距离远的顶点的次序打印连通图G中每个顶点一次且仅一次。</p><h2 id="算法实现">算法实现</h2><p>用q[ ]数组来存储bfs过程中的经过的点的顺序，用visit[ ]数组来记录是否访问过点，visit[ i ]=1表示访问过，否则没有。用head，tail配合q[ ]数组来模拟一个队列。从head处开始循环，将未经过的点进队。最后遍历输出q[ ]数组。<br>代码如下：</p><h2 id="代码-70">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], q[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a][b] = <span class="hljs-number">1</span>, g[b][a] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">if</span> (!st[i] &amp;&amp; g[t][i])<br>            &#123;<br>                q[ ++ tt] = i;<br>                st[i] = <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; n; i ++ )<br>        cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果展示-2">结果展示</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_d1d8d504c8-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_d4b79116c8-3.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.2与课后课程笔记</title>
      <link href="/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>项目1.2</h1><h2 id="题目描述-3">题目描述</h2><p>已知一个按先序序列输入的字符序列，如abc,de,g,f,(其中逗号表示空节点)。请建立二叉树并按中序和后序方式遍历二叉树，最后求出叶子节点个数和二叉树深度。<br>输入<br> 输入一个长度小于50个字符的字符串。<br>输出<br>输出共有4行：<br>第1行输出中序遍历序列；</p><p>第2行输出后序遍历序列；</p><p>第3行输出叶子节点个数；</p><p>第4行输出二叉树深度。</p><p>示例输入</p><p>abc,de,g,f,</p><p>示例输出</p><p>cbegdfa</p><p>cgefdba</p><p>3</p><p>5</p><h2 id="题意分析-61">题意分析</h2><p>本实验共需要完成五项任务：</p><ol><li>根据输入先序建立二叉树；</li><li>按中序方式遍历二叉树并输出序列；</li><li>按后序方式遍历二叉树并输出序列；</li><li>求出二叉树的叶子结点个数；</li><li>求出二叉树的深度。</li></ol><h2 id="实验思路">实验思路</h2><ol><li><p>定义二叉树结点数据结构</p><p>建立一个Node结构体，其中包含一个char类型的data用于存储字母，一个Node类型的<em>Lchild指针指向左子树和一个Node类型的</em>Rchild指针指向右子树。再建立一个指向Node这种结构的*p指针。</p></li><li><p>如何先序建立二叉树？</p><p>建立一个build(p &amp;T)函数用于先序建立二叉树，T为返回node的指针。函数中定义一个char类型的c用于读入输入，若c为“，”，则为空结点，T=NULL；若T为换行符“\n”，则输入结束并返回；否则c就是字母结点，则创建一个新的指针T，并让T-&gt;data=c，接着递归创建其左子树和右子树。</p></li><li><p>如何按中序、后序方式遍历二叉树并输出序列？</p><p>要按中序方式遍历二叉树，先访问左子树，再访问根节点，最后访问右子树；要按后序方式遍历二叉树，先访问左子树，再访问右子树，最后访问根节点；在访问根节点时打印该结点的data即可完成输出。</p></li><li><p>如何求出二叉树的叶子结点个数？</p><p>叶子结点就是左右子树都是空子树的结点，据此完成判断。如果二叉树为空，则叶子结点数为0；如果二叉树只有一个结点，则叶子结点数为1；否则，二叉树的叶子结点数为左右子树叶子结点数之和，据此完成递归。</p></li><li><p>如何求出二叉树的深度？</p><p>如果二叉树为空，则深度为0；如果二叉树只有一个结点，则深度为1；否则，二叉树的深度为左右子树深度的最大值+1。</p></li></ol><h2 id="代码-66">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jied</span><br>&#123;<br>    <span class="hljs-type">char</span> date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jied</span> *lchild,*rchild;<br>&#125; jied,*p;<br><span class="hljs-type">int</span> d = <span class="hljs-number">0</span>,ma = <span class="hljs-number">0</span>,num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jianshu</span> <span class="hljs-params">(p &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;,&#x27;</span>)<br>        T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        T = <span class="hljs-keyword">new</span> jied;<span class="hljs-comment">// 让指针实体化 new返回的是jied的指针</span><br>        T -&gt; date = ch;<br>        <span class="hljs-built_in">jianshu</span>(T -&gt; lchild);<br>        <span class="hljs-built_in">jianshu</span>(T -&gt; rchild);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zhongxu</span><span class="hljs-params">(p T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">zhongxu</span>(T -&gt; lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T -&gt; date);<br>        <span class="hljs-built_in">zhongxu</span>(T -&gt; rchild);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">houxu</span><span class="hljs-params">(p T,<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">houxu</span>(T -&gt; lchild,d+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">houxu</span>(T -&gt; rchild,d+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T -&gt; date);<br>        <span class="hljs-keyword">if</span>(ma&lt;d)<br>            ma = d;<span class="hljs-comment">//防止同一层多次相加</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">y</span><span class="hljs-params">(p T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(T -&gt; lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T -&gt; rchild == <span class="hljs-literal">NULL</span>)<br>            num++;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">y</span>(T -&gt; lchild);<br>            <span class="hljs-built_in">y</span>(T -&gt; rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    p T;<br>    <span class="hljs-built_in">jianshu</span>(T);<br>    <span class="hljs-built_in">zhongxu</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">houxu</span>(T,ma);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">y</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ma + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果">结果</h2><h3 id="生成的二叉树">生成的二叉树</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_ec2de90ac8-2.png" alt="2.png"></p><h3 id="程序结果">程序结果</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_79c34ec1c8-1.jpg" alt="1.jpg"></p><h1>课程笔记</h1><ol><li><p>一棵树的后序遍历和这棵树对应的二叉树的(B)相同。</p><p>A．先序遍历        B．中序遍历        C．后序遍历        D．层次遍历</p><p>解答：首先看这个树<br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_986b4bcdc8-1.jpg" alt="1.jpg"></p><p>它的后序遍历为25641，将它转换为一个二叉树<br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9bd29a88c8-4.jpg" alt="4.jpg"></p><p>它的中序遍历为256341</p></li><li><p>一棵二叉树的先序序列和中序序列分别我：A B C D E F G H J K L M N和C B E D G F A J H K M L N，则二叉树的后序序列为（A）。</p><p>A. C E G F D B J M N L K H A     B. C E D G F B J H K M N L A</p><p>C. C G F E D B J M N L K H A     D. C E G D F B M N J L K H A</p></li><li><p>【程序说明】本程序完成将二叉树中左、右孩子交换的操作。</p><p>本程序采用非递归的方法，设立一个堆栈stack存放还没有转换过的结点，它的栈顶指针为tp。交换左、右子树的算法为：</p><p>（1）把根结点放入堆栈。</p><p>（2）当堆栈不空时，取出栈顶元素，交换它的左、右子树，并把它的左、右子树分别入栈。</p><p>（3）重复（2）直到堆栈为空时为止。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span>  <span class="hljs-keyword">struct</span>  <span class="hljs-title class_">node</span>  *tree;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> data; tree lchild,rchild;&#125;<br><span class="hljs-built_in">exchange</span>(tree t)<br>&#123;  tree  r,p; tree  stack [<span class="hljs-number">500</span>]; <span class="hljs-type">int</span>  tp=<span class="hljs-number">0</span>;<br> stack[tp]=t;<br><span class="hljs-keyword">while</span> (tp&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>    p=stack[tp -- ];<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<br>    &#123;  r=p-&gt;lchild; p-&gt;lchild=p-&gt;rchild; p-&gt;rchild=r;<br>    stack[++tp]=p-&gt;lchild; stack[++tp]=p-&gt;rchild;<br>    &#125;<br>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>假设以双亲表示法作树的存储结构，写出双亲表示的类型说明，并编写求给定的树(结点数为n)的深度的算法。</p><p>以双亲表示法作树的存储结构，对每一个结点，找其双亲，直至根结点，即可得到它的层次。树的深度即所有结点的最大层次。</p><h3 id="代码-67">代码</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//类型说明</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    DataType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125;PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTree</span>&#123;<br>    PTNode nodes[Maxsize];<br>    <span class="hljs-type">int</span> k,n;<span class="hljs-comment">//k,n分别为根的位置和节点数</span><br>&#125;;<br>    <span class="hljs-comment">//函数编写</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Getlength</span><span class="hljs-params">(PTree t)</span></span>&#123;<br>        <span class="hljs-type">int</span> k,temp;<br>        <span class="hljs-type">int</span> maxdepth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t.n;i++)&#123;<br>            temp=<span class="hljs-number">0</span>;<br>            k=i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span>)&#123;<br>                temp++;<br>                k=t.nodes[k].parent;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp&gt;maxdepth) maxdepth=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxdepth;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.1与课后课程笔记</title>
      <link href="/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.1%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.1%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>项目1 约瑟夫生死游戏</h1><h2 id="题目描述-2">题目描述</h2><p>每30个乘客同乘一艘船，因为严重超载，加上风高浪大，危险万分，因此船长告诉乘客，只有将全船一半乘客投入海中，其余人才能幸免于难。无奈，大家只得同意这种办法，并议定30个人围成一圈，由第1个人数起，依次报数，数到第9人，便把他投入大海中，然后再从他的下一个人数起，数到第9人，再将他扔到大海中，如此循环地进行，直到剩下15个乘客为止。问哪些位置是将被扔下大海的位置。</p><h2 id="解题思路-8">解题思路</h2><p>采用数组模拟链表解决</p><h2 id="代码-65">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">500</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        a[i] = i + <span class="hljs-number">1</span>;<br><br>    a[n] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, x = <span class="hljs-number">1</span>, last = n;<br>    <span class="hljs-keyword">while</span> (n &gt; k)<br>    &#123;<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt == m)<br>        &#123;<br>            a[last] = a[x];<br>            n--;<br>            cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>        last = x;<br>        x = a[x];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果展示">结果展示</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_6e814e22c8-1.jpg" alt="1.jpg"></p><h1>课程笔记</h1><ol><li>在等概率情况下，顺序表中插入一个结点需平均移动$\frac{n}{2}$个节点，删除一个节点需平均移动$\frac{n-1}{2}$个节点。</li><li>设顺序表L设顺序表L是一个递增有序表，试写一算法，将元素x插入L中，并使L仍是一个有序表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSqlist</span><span class="hljs-params">(Sqlist *L,Elemtype number)</span></span>&#123;<br><span class="hljs-built_in">assert</span>(L-&gt;length &lt; L-&gt;listsize);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L-&gt;length;i&gt;<span class="hljs-number">0</span>&amp;&amp;L-&gt;elem[i<span class="hljs-number">-1</span>]&gt;number;i--)&#123;<br>L-&gt;elem[i]=L-&gt;elem[i<span class="hljs-number">-1</span>];<br>&#125;<br>L-&gt;elem[i]=number;<br>L-&gt;length++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在一个具有n个链接点的线性链表中查找某一个链接点，若查找成功，需要平均比较©个链接点。</p><p>A. n        B. n/2     C.  (n+1)/2      D.  (n-1)/2</p></li><li><p>下列排序算法中，稳定的排序算法是(AD)。</p><p>A．冒泡排序 B. 选择排序  C．希尔排序 D．简单插入排序</p></li><li><p>数据序列{8，9，10，4，5，6，20，1，2}只能是下列排序算法中的©的两趟排序后的结果。</p><p>A．选择排序 B.冒泡排序 C.插入排序  D.希尔排序</p></li><li><p>已知某链接存储的数据序列的第一个数据的地址为FIR，结点的结构为{key，data，next},请编写一算法，在该数据序列中确定关键字值为def的数据是否存在，若存在，返回数据所在结点的地址，否则，返回null。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span></span>&#123;<br>LNode *p;<br>p-&gt;next=FIR;<br><span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;next-&gt;key==def)<span class="hljs-keyword">break</span>;<br>p=p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周总结</title>
      <link href="/2022/04/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>装了2天，总算把博客建立的大差不差，现在只有一些基本的功能，这周感觉有点摆烂，晚上一定要坚持跑步，然后尽量多利用时光序做好规划，周三晚上算是摆烂，好好利用博客总结发现和分析问题吧，暂时先这样吧。有什么内容晚上再说吧,今天晚上写一下模板,分析下每周的问题。<br>还有就是ACM本周基本没有学习，五一要好好学一下，坚持，努力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP">password: <span class="hljs-number">13579</span><br>description: 有东西被加密了, 请输入密码查看.<br>message: 您好, 这里需要密码.<br>wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.<br>wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#inude <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>$RMSE = 1 - \dfrac{\sum_{i=1}^n (y_i - \hat{y}_i)^2} {\sum_{i=1}^n (y_i - \bar{y})^2}$</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
